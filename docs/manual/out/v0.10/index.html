<ul>
<li>1 <a href="#introduction">Introduction</a>
<ul>
<li>1.1 <a href="#synchronous-execution-model">Synchronous execution model</a>
<ul>
<li>1.1.1 <a href="#parallel-compositions-and-abortion">Parallel compositions and abortion</a></li>
<li>1.1.2 <a href="#bounded-execution">Bounded execution</a></li>
<li>1.1.3 <a href="#deterministic-execution">Deterministic execution</a></li>
<li>1.1.4 <a href="#internal-reactions">Internal reactions</a></li>
</ul></li>
<li>1.2 <a href="#organisms-as-abstractions">Organisms as abstractions</a></li>
</ul></li>
<li>2 <a href="#lexical-rules">Lexical rules</a>
<ul>
<li>2.1 <a href="#keywords">Keywords</a></li>
<li>2.2 <a href="#identifiers">Identifiers</a></li>
<li>2.3 <a href="#literals">Literals</a>
<ul>
<li>2.3.1 <a href="#booleans">Booleans</a></li>
<li>2.3.2 <a href="#integers">Integers</a></li>
<li>2.3.3 <a href="#floats">Floats</a></li>
<li>2.3.4 <a href="#null-pointer">Null pointer</a></li>
<li>2.3.5 <a href="#strings">Strings</a></li>
</ul></li>
<li>2.4 <a href="#comments">Comments</a></li>
</ul></li>
<li>3 <a href="#types">Types</a>
<ul>
<li>3.1 <a href="#primitive-types">Primitive types</a></li>
<li>3.2 <a href="#native-types">Native types</a></li>
<li>3.3 <a href="#class-and-interface-types">Class and Interface types</a></li>
<li>3.4 <a href="#type-modifiers">Type modifiers</a>
<ul>
<li>3.4.1 <a href="#references">References</a>
<ul>
<li>3.4.1.1 <a href="#alias">Alias</a></li>
<li>3.4.1.2 <a href="#pointer">Pointer</a></li>
</ul></li>
<li>3.4.2 <a href="#option">Option</a></li>
<li>3.4.3 <a href="#dimension">Dimension</a></li>
</ul></li>
</ul></li>
<li>4 <a href="#statements">Statements</a>
<ul>
<li>4.1 <a href="#blocks">Blocks</a>
<ul>
<li>4.1.1 <a href="#do-end">do-end</a></li>
<li>4.1.2 <a href="#pre">Pre</a></li>
</ul></li>
<li>4.2 <a href="#nothing">Nothing</a></li>
<li>4.3 <a href="#declarations">Declarations</a>
<ul>
<li>4.3.1 <a href="#variables">Variables</a>
<ul>
<li>4.3.1.1 <a href="#organisms">Organisms</a>
<ul>
<li>4.3.1.1.1 <a href="#constructors">Constructors</a></li>
</ul></li>
</ul></li>
<li>4.3.2 <a href="#pools">Pools</a></li>
<li>4.3.3 <a href="#functions">Functions</a>
<ul>
<li>4.3.3.1 <a href="#internal-functions">Internal functions</a></li>
<li>4.3.3.2 <a href="#external-functions">External functions</a>
<ul>
<li>4.3.3.2.1 <a href="#return">return</a></li>
</ul></li>
</ul></li>
<li>4.3.4 <a href="#interrupt-service-routines">Interrupt service routines</a></li>
<li>4.3.5 <a href="#events">Events</a>
<ul>
<li>4.3.5.1 <a href="#internal-events">Internal events</a></li>
<li>4.3.5.2 <a href="#external-events">External events</a>
<ul>
<li>4.3.5.2.1 <a href="#external-requests">External Requests</a></li>
</ul></li>
</ul></li>
<li>4.3.6 <a href="#classes-and-interfaces">Classes and Interfaces</a></li>
<li>4.3.7 <a href="#data-types">Data Types</a></li>
<li>4.3.8 <a href="#native-declarations">Native declarations</a>
<ul>
<li>4.3.8.1 <a href="#native-blocks">Native blocks</a></li>
<li>4.3.8.2 <a href="#native-annotations">Native annotations</a></li>
</ul></li>
<li>4.3.9 <a href="#deterministic-annotations">Deterministic annotations</a></li>
</ul></li>
<li>4.4 <a href="#assignments">Assignments</a>
<ul>
<li>4.4.1 <a href="#simple-assignment">Simple assignment</a></li>
<li>4.4.2 <a href="#block-assignment">Block assignment</a>
<ul>
<li>4.4.2.1 <a href="#escape">escape</a></li>
</ul></li>
<li>4.4.3 <a href="#await-assignment">Await assignment</a></li>
<li>4.4.4 <a href="#emit-assignment">Emit assignment</a></li>
<li>4.4.5 <a href="#data-assignment">Data assignment</a></li>
<li>4.4.6 <a href="#traverse-assignment">Traverse assignment</a></li>
<li>4.4.7 <a href="#vector-assignment">Vector assignment</a></li>
<li>4.4.8 <a href="#lua-assignment">Lua assignment</a></li>
<li>4.4.9 <a href="#do-organism-assignment">Do organism assignment</a></li>
<li>4.4.10 <a href="#spawn-assignment">Spawn assignment</a></li>
<li>4.4.11 <a href="#thread-assignment">Thread assignment</a></li>
</ul></li>
<li>4.5 <a href="#calls">Calls</a>
<ul>
<li>4.5.1 <a href="#internal-calls">Internal calls</a></li>
<li>4.5.2 <a href="#external-calls">External calls</a></li>
</ul></li>
<li>4.6 <a href="#event-handling">Event handling</a>
<ul>
<li>4.6.1 <a href="#await-statements">Await statements</a>
<ul>
<li>4.6.1.1 <a href="#await-event">Await event</a></li>
<li>4.6.1.2 <a href="#await-time">Await time</a></li>
<li>4.6.1.3 <a href="#await-organism">Await organism</a></li>
<li>4.6.1.4 <a href="#await-forever">Await FOREVER</a></li>
</ul></li>
<li>4.6.2 <a href="#emit-statements">Emit statements</a>
<ul>
<li>4.6.2.1 <a href="#emit-event">Emit event</a></li>
<li>4.6.2.2 <a href="#emit-time">Emit time</a></li>
</ul></li>
<li>4.6.3 <a href="#requests">Requests</a></li>
</ul></li>
<li>4.7 <a href="#organism-instantiation">Organism instantiation</a>
<ul>
<li>4.7.1 <a href="#do-organism">Do organism</a></li>
<li>4.7.2 <a href="#spawn">Spawn</a></li>
<li>4.7.3 <a href="#kill">Kill</a></li>
</ul></li>
<li>4.8 <a href="#conditional">Conditional</a></li>
<li>4.9 <a href="#loop">Loop</a>
<ul>
<li>4.9.1 <a href="#break">break</a></li>
<li>4.9.2 <a href="#continue">continue</a></li>
<li>4.9.3 <a href="#iterators">Iterators</a>
<ul>
<li>4.9.3.1 <a href="#incremental-index">Incremental index</a></li>
<li>4.9.3.2 <a href="#pool-instances">Pool instances</a></li>
</ul></li>
<li>4.9.4 <a href="#every">every</a></li>
<li>4.9.5 <a href="#traverse">Traverse</a></li>
</ul></li>
<li>4.10 <a href="#finalization">Finalization</a></li>
<li>4.11 <a href="#parallel-compositions">Parallel compositions</a>
<ul>
<li>4.11.1 <a href="#par-and">par/and</a></li>
<li>4.11.2 <a href="#par-or">par/or</a></li>
<li>4.11.3 <a href="#par">par</a></li>
<li>4.11.4 <a href="#watching">watching</a></li>
</ul></li>
<li>4.12 <a href="#pause-if">pause/if</a></li>
<li>4.13 <a href="#asynchronous-execution">Asynchronous execution</a>
<ul>
<li>4.13.1 <a href="#asynchronous-blocks">Asynchronous blocks</a>
<ul>
<li>4.13.1.1 <a href="#simulation">Simulation</a></li>
</ul></li>
<li>4.13.2 <a href="#threads">Threads</a>
<ul>
<li>4.13.2.1 <a href="#synchronous-blocks">Synchronous blocks</a></li>
<li>4.13.2.2 <a href="#atomic-blocks">Atomic blocks</a></li>
</ul></li>
</ul></li>
<li>4.14 <a href="#c-statements">C statements</a></li>
<li>4.15 <a href="#lua-statements">Lua statements</a></li>
</ul></li>
<li>5 <a href="#expressions">Expressions</a>
<ul>
<li>5.1 <a href="#primary">Primary</a></li>
<li>5.2 <a href="#arithmetic">Arithmetic</a></li>
<li>5.3 <a href="#relational">Relational</a></li>
<li>5.4 <a href="#logical">Logical</a></li>
<li>5.5 <a href="#bitwise">Bitwise</a></li>
<li>5.6 <a href="#vector-indexing">Vector indexing</a></li>
<li>5.7 <a href="#references">References</a>
<ul>
<li>5.7.1 <a href="#aliasing">Aliasing</a></li>
</ul></li>
<li>5.8 <a href="####-pointer-referencing-and-dereferencing">### Pointer referencing and dereferencing</a></li>
<li>5.9 <a href="#fields">Fields</a>
<ul>
<li>5.9.1 <a href="#structs">Structs</a></li>
<li>5.9.2 <a href="#organisms">Organisms</a></li>
</ul></li>
<li>5.10 <a href="#option">Option</a></li>
<li>5.11 <a href="#type-casting">Type casting</a></li>
<li>5.12 <a href="#sizeof">Sizeof</a></li>
<li>5.13 <a href="#precedence">Precedence</a></li>
<li>5.14 <a href="#assignable-expressions">Assignable expressions</a></li>
</ul></li>
<li>6 <a href="#static-analysis">Static analysis</a>
<ul>
<li>6.1 <a href="#types">Types</a></li>
<li>6.2 <a href="#loops">Loops</a></li>
<li>6.3 <a href="#finalization">Finalization</a></li>
<li>6.4 <a href="#organisms-references">Organisms references</a></li>
</ul></li>
<li>7 <a href="#environment">Environment</a>
<ul>
<li>7.1 <a href="#the-c-api">The C API</a>
<ul>
<li>7.1.1 <a href="#types">Types</a></li>
<li>7.1.2 <a href="#functions">Functions</a></li>
<li>7.1.3 <a href="#macros">Macros</a></li>
<li>7.1.4 <a href="#constants-and-defines">Constants and Defines</a></li>
</ul></li>
<li>7.2 <a href="#compiler">Compiler</a></li>
</ul></li>
<li>8 <a href="#errors">Errors</a>
<ul>
<li>8.1 <a href="#pointer-attributions-(11xx)">Pointer attributions (11xx)</a>
<ul>
<li>8.1.1 <a href="#1101----wrong-operator-">1101 : <em>wrong operator</em></a></li>
<li>8.1.2 <a href="#1102----attribution-does-not-require-%22finalize%22-">1102 : <em>attribution does not require &quot;finalize&quot;</em></a></li>
<li>8.1.3 <a href="#1103----wrong-operator-">1103 : <em>wrong operator</em></a></li>
<li>8.1.4 <a href="#1104----attribution-does-not-require-%22finalize%22-">1104 : <em>attribution does not require &quot;finalize&quot;</em></a></li>
<li>8.1.5 <a href="#1105----destination-pointer-must-be-declared-with-the-%22--%22-buffer-modifier-">1105 : <em>destination pointer must be declared with the &quot;[]&quot; buffer modifier</em></a></li>
<li>8.1.6 <a href="#1106----parameter-must-be-%22hold%22-">1106 : <em>parameter must be &quot;hold&quot;</em></a></li>
<li>8.1.7 <a href="#1107----pointer-access-across-%22await%22-">1107 : <em>pointer access across &quot;await&quot;</em></a></li>
<li>8.1.8 <a href="#1108----%22finalize%22-inside-constructor-">1108 : <em>&quot;finalize&quot; inside constructor</em></a></li>
<li>8.1.9 <a href="#1109----call-requires-%22finalize%22-">1109 : <em>call requires &quot;finalize&quot;</em></a></li>
<li>8.1.10 <a href="#1110----invalid-%22finalize%22-">1110 : <em>invalid &quot;finalize&quot;</em></a></li>
</ul></li>
</ul></li>
<li>9 <a href="#syntax">Syntax</a></li>
<li>10 <a href="#license">License</a></li>
</ul>
<title>
Céu 0.10 - Reference Manual - (warning, incomplete!)
</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</p>
<h2 id="section">1</h2>
<h1 id="introduction">Introduction</h1>
<blockquote>
<p><em>Warning:</em> <em>This manual is under a rewriting process and still mostly reflects version 0.8.</em></p>
</blockquote>
<p>Céu is an imperative, concurrent and reactive language in which then lines of execution, known as <em>trails</em>, react together continuously and in synchronous steps to external input events from the environment. Waiting for an event halts the running trail until that event occurs. The environment broadcasts an occurring event to all active trails, which share a single global time reference (the event itself).</p>
<p>The synchronous concurrency model of Céu greatly diverges from conventional multithreading (e.g. <em>pthreads</em> and <em>Java threads</em>) and the actor model (e.g. <em>erlang</em> and <em>Go</em>). On the one hand, trails can share variables in a deterministic and seamless way (e.g. no need for locks or semaphores). On the other hand, there is no real parallelism (e.g. multi-core execution) in the standard synchronous execution mode of the language.</p>
<p>Céu integrates well with C, being possible to define and call C functions from within Céu programs.</p>
<p>Céu is <a href="#license">free software</a>.</p>
<!--
Céu is a language for real-time concurrency with complex control 
specifications, but not for algorithm-intensive or distributed applications.
 "Structured Synchronous Reactive Programming"
(safe and deterministic concurrency with side effects)
Céu supports mutable data, with static memory and safe pointer manipulation.
Céu is a programming language for reactive applications and intends to offer a 
higher-level and safer alternative to C.
The two main peculiarities of Céu are the [synchronous execution 
model](#synchronous-execution-model) and the use of [organisms as 
abstractions](#organisms-as-abstractions).
Reactive applications interact in real time and continuously with external 
stimuli from the environment.
They represent a wide range of software areas and platforms: from games in 
powerful desktops, *"apps"* in capable smart phones, to the emerging internet 
of things in constrained embedded systems.
Céu supports concurrent lines of execution---known as *trails*---that react 
continuously to input events from the environment.
Céu has a memory footprint of around 2Kb of ROM and 50b of RAM (on embedded 
platform such as Arduino).
For a gentle introduction about Céu, see the [interactive 
tutorial](http://www.ceu-lang.org/try.php).
See also the complete [Syntax](#syntax) of Céu.
-->
<h3 id="section-1">1.1</h3>
<h2 id="synchronous-execution-model">Synchronous execution model</h2>
<p>Céu is grounded on a precise definition of <em>logical time</em> as a discrete sequence of external input events: a sequence because only a single input event is handled at a logical time; discrete because reactions to events are guaranteed to execute in bounded real time (see <a href="#bounded-execution">Bounded execution</a>).</p>
<p>The execution model for Céu programs is as follows:</p>
<ol style="list-style-type: decimal">
<li>The program initiates the <em>boot reaction</em> from the first line of code in a single trail.</li>
<li>Active trails<sup>1</sup>, one after another, execute until they await or terminate. This step is named a <em>reaction chain</em>, and always runs in bounded time.</li>
<li>The program goes idle and the environment takes control.</li>
<li>On the occurrence of a new external input event, the environment awakes <em>all</em> trails awaiting that event. It then goes to step 2.</li>
</ol>
<p>(<sup>1</sup> <em>Trails can be created with <a href="#parallel-compositions-and-abortion">parallel compositions</a>.</em>)</p>
<p>The synchronous execution model of Céu is based on the hypothesis that internal reactions run <em>infinitely faster</em> in comparison to the rate of external events. An internal reaction is the set of computations that execute when an external event occurs. Conceptually, a program takes no time on step 2 and is always idle on step 3. In practice, if a new external input event occurs while a reaction chain is running (step 2), it is enqueued to run in the next reaction. When multiple trails are active at a logical time (i.e. awaking on the same event), Céu schedules them in the order they appear in the program text. This policy is somewhat arbitrary, but provides a priority scheme for trails, and also ensures deterministic and reproducible execution for programs. At any time, at most one trail is executing.</p>
<p>The program and diagram below illustrate the behavior of the scheduler of Céu:</p>
<pre><code> 1:  <b>input void</b> A, B, C;
 2:  <b>par/and do</b>           // A, B, and C are external input events
 3:      // trail 1
 4:      &lt;...&gt;            // &lt;...&gt; represents non-awaiting statements
 5:      <b>await</b> A;
 6:      &lt;...&gt;
 7:  <b>with</b>
 8:      // trail 2
 9:      &lt;...&gt;
10:      <b>await</b> B;
11:      &lt;...&gt;
12:  <b>with</b>
13:      // trail 3
14:      &lt;...&gt;
15:      <b>await</b> A;
16:      &lt;...&gt;
17:      <b>await</b> B;
18:      <b>par/and do</b>
19:          // trail 3
20:          &lt;...&gt;
21:      <b>with</b>
22:          // trail 4
23:          &lt;...&gt;
24:      <b>end</b>
25:  <b>end</b>
</code></pre>
<div class="figure">
<img src="reaction.png" />

</div>
<p>The program starts in the boot reaction and splits in three trails (a <code>par/and</code> rejoins after all trails terminate). Following the order of declaration for the trails, they are scheduled as follows (<em>t0</em> in the diagram):</p>
<ul>
<li><em>trail-1</em> executes up to the <code>await A</code> (line 5);</li>
<li><em>trail-2</em>, up to the <code>await B</code> (line 10);</li>
<li><em>trail-3</em>, up to <code>await A</code> (line 15).</li>
</ul>
<p>As no other trails are pending, the reaction chain terminates and the scheduler remains idle until the event <code>A</code> occurs (<em>t1</em> in the diagram):</p>
<ul>
<li><em>trail-1</em> awakes, executes and terminates (line 6);</li>
<li><em>trail-2</em> remains suspended, as it is not awaiting <code>A</code>.</li>
<li><em>trail-3</em> executes up to <code>await B</code> (line 17).</li>
</ul>
<p>During this reaction, new instances of events <code>A</code>, <code>B</code>, and <code>C</code> occur (<em>t1</em> in the diagram) and are enqueued to be handled in the reactions that follow. As <code>A</code> happened first, it is used in the next reaction. However, no trails are awaiting it, so an empty reaction chain takes place (<em>t2</em> in the diagram). The next reaction dequeues the event <code>B</code> (<em>t3</em> in the diagram):</p>
<ul>
<li><em>trail-2</em> awakes, executes and terminates;</li>
<li><em>trail-3</em> splits in two and they both terminate.</li>
</ul>
<p>With all trails terminated, the program also terminates and does not react to the pending event <code>C</code>. Note that each step in the logical time line (<em>t0</em>, <em>t1</em>, etc.) is identified by the event it handles. Inside a reaction, trails only react to that identifying event (or remain suspended).</p>
<!--
A reaction chain may also contain emissions and reactions to internal events, 
which are presented in Section~\ref{sec.ceu.ints}.
-->
<h4 id="section-2">1.1.1</h4>
<h3 id="parallel-compositions-and-abortion">Parallel compositions and abortion</h3>
<p>The use of trails in parallel allows programs to wait for multiple events at the same time. Céu supports three kinds of parallel compositions differing in how they rejoin and proceed to the statement in sequence:</p>
<ol style="list-style-type: decimal">
<li>a <code>par/and</code> rejoins after all trails in parallel terminate;</li>
<li>a <code>par/or</code> rejoins after any trail in parallel terminates;</li>
<li>a <code>par</code> never rejoins (even if all trails terminate).</li>
</ol>
<p>The termination of a trail inside a <code>par/or</code> aborts the other trails in parallel, which must be necessarily awaiting (from rule 2 of <a href="#synchronous-execution-model">Execution model</a>). Before aborting, a trail has a last opportunity to execute all active <a href="#finalization">finalization statements</a>.</p>
<p>As mentioned in the introduction and emphasized in the execution model, trails inside parallel compositions do not execute with real parallelism. Therefore, inside compositions trails are <em>awaiting in parallel</em>, rather than <em>executing in parallel</em>.</p>
<h4 id="section-3">1.1.2</h4>
<h3 id="bounded-execution">Bounded execution</h3>
<p>Reaction chains should run in bounded time to guarantee that programs are responsive and can handle upcoming input events from the environment. For any loop statement in a program, Céu requires that every possible path inside its body contains at least one <code>await</code> or <code>break</code> statement, thus avoiding <em>tight loops</em> (i.e., unbounded loops that do not await).</p>
<p>In the example below, the <code>if</code> true branch may never execute, resulting in a tight loop (which the compiler complains about):</p>
<pre><code><b>loop do</b>
    <b>if</b> &lt;cond&gt; <b>then</b>
        <b>break</b>;
    <b>end</b>
<b>end</b>
</code></pre>
<p>For time-consuming algorithms that require unrestricted loops (e.g., cryptography, image processing), Céu provides <a href="#asynchronous-execution">Asynchronous execution</a>.</p>
<h4 id="section-4">1.1.3</h4>
<h3 id="deterministic-execution">Deterministic execution</h3>
<p><code>TODO (shared memory + deterministic scheduler + optional static analysis)</code></p>
<h4 id="section-5">1.1.4</h4>
<h3 id="internal-reactions">Internal reactions</h3>
<p>Céu provides inter-trail communication through <em>internal events</em>. Trails use the <code>await</code> and <code>emit</code> operations to manipulate internal events, i.e., a trail that emits an event can awake trails previously awaiting the same event.</p>
<p>An <code>emit</code> starts a new <em>internal reaction</em> in the program:</p>
<ol style="list-style-type: decimal">
<li>On an <code>emit</code>, the scheduler remembers the statement following it to execute later (i.e., its continuation).</li>
<li>All trails awaiting the emitted event awake and execute (like rule 2 for external reactions).</li>
<li>The emitting trail resumes execution from its continuation.</li>
</ol>
<p>If an awaking trail emits another internal event, a new internal reaction starts. The scheduler uses a stack policy (first in, last out) for saved continuation statements from rule 1.</p>
<p>Example:</p>
<pre><code>1:  <b>par/and do</b>
2:      <b>await</b> e;
3:      <b>emit</b> f;
4:  <b>with</b>
5:      <b>await</b> f;
6:  <b>with</b>
7:      ...
8:      <b>emit</b> e;
9:  <b>end</b>
</code></pre>
<p>The <code>emit e</code> in <em>trail-3</em> (line 8) starts an internal reaction that awakes the <code>await e</code> in <em>trail-1</em> (line 2). Then, the <code>emit f</code> (line 3) starts another internal reaction that awakes the <code>await f</code> in <em>trail-2</em> (line 5). <em>Trail-2</em> terminates and the <code>emit f</code> resumes in <em>trail-1</em>. <em>Trail-1</em> terminates and the <code>emit e</code> resumes in <em>trail-3</em>. <em>Trail-3</em> terminates. Finally, the <code>par/and</code> rejoins (all trails have terminated) and the program terminates.</p>
<h3 id="section-6">1.2</h3>
<h2 id="organisms-as-abstractions">Organisms as abstractions</h2>
<p>Céu uses an abstraction mechanism that reconciles data and control state into the single concept of an <em>organism</em>. Organisms provide an object-like interface (data state) as well as multiple lines of execution (control state).</p>
<p>A class of organisms is composed of an <em>interface</em> and a single <em>execution body</em>. The interface exposes public variables, methods, and internal events, just like objects. The body can contain any valid code in Céu, which starts on the organism instantiation and executes in parallel with the program. Organism instantiation can be either <a href="#variables">static</a> or <a href="#spawn">dynamic</a>.</p>
<p>The example below (in the right) blinks two LEDs in parallel with different frequencies. Each blinking LED is a static instance organism of the <code>Blink</code> class:</p>
<table width="100%">
<tr valign="top">
<td>
<pre><code>
 1:  <b>class</b> Blink <b>with</b>
 2:      <b>var int</b> led;
 3:      <b>var int</b> freq;
 4:  <b>do</b>
 5:      <b>loop do</b>
 6:          _on(<b>this</b>.led);
 7:          <b>await</b> (<b>this</b>.freq)s;
 8:          _off(<b>this</b>.led);
 9:          <b>await</b> (<b>this</b>.freq/2)s;
10:      <b>end</b>
11:  <b>end</b>
12:
13:  <b>var</b> Blink b1 <b>with</b>
14:       <b>this</b>.led  = 0;
15:       <b>this</b>.freq = 2;
16:  <b>end</b>
17:
18:  <b>var</b> Blink b2 <b>with</b>
19:       <b>this</b>.led  = 1;
20:       <b>this</b>.freq = 4;
21:  <b>end</b>
22:
23:  <b>await</b> 1min;
</code></pre>
</td>
<td>
<pre><code>
 1:  <b>var</b> _Blink b1 <b>with</b>
 2:      <b>this</b>.led  = 0;
 3:      <b>this</b>.freq = 2;
 4:  <b>end</b>
 5:
 6:  <b>var</b> _Blink b2 <b>with</b>
 7:      <b>this</b>.led  = 1;
 8:      <b>this</b>.freq = 4;
 9:  <b>end</b>
10:
11:  <b>par/or do</b>
12:      // body of b1
13:      <b>loop do</b>
14:          _on(b1.led);
15:          <b>await</b> (b1.freq)s;
16:          _off(b1.led);
17:          <b>await</b> (b1.freq)s;
18:      <b>end</b>
19:      <b>await FOREVER</b>;
20:  <b>with</b>
21:      // body of b2
22:      <b>loop do</b>
23:          _on(b2.led);
24:          <b>await</b> (b2.freq)s;
25:          _off(b2.led);
26:          <b>await</b> (b2.freq)s;
27:      <b>end</b>
28:      <b>await FOREVER</b>;
29:  <b>with</b>
30:      <b>await</b> 1min;
31:  <b>end</b>
</code></pre>
</td>
</tr>
</table>
<p>The <code>Blink</code> class (lines 1-11) exposes the <code>led</code> and <code>freq</code> fields, which correspond to the LED port and blinking frequency to be configured for each instance. The application creates two instances, specifying the fields in the constructors (lines 13-16 and 18-21). A constructor starts the instance body to execute in parallel with the application. When reaching the <code>await 1min</code> (line 23), each instance already has its body switching between <code>_on()</code> and <code>_off()</code> every <code>freq</code> milliseconds (lines 5-10).</p>
<p>The code in the left is semantically equivalent to the one in the right, which expands the organisms bodies (lines 13-18 and 22-27) in a <code>par/or</code> with the rest of the application (<code>await 1min</code>, in line 30). Note the <code>await FOREVER</code> statements (lines 19 and 28) that avoid the organisms bodies to terminate the <code>par/or</code>. The <code>_Blink</code> type corresponds to a simple datatype without execution body (i.e., conventional <em>structs</em> or <em>records</em> or objects).</p>
<p>See also <a href="#organisms">Organism declarations</a>, <a href="#classes-and-interfaces">Class and Interface declarations</a>, and <a href="#organism-instantiation">Organisms instantiation</a>.</p>
<!-- TODO
\footnote{\code{FOREVER} is a reserved keyword in \CEU, and represents an 
external input event that never occurs.}%
, meaning that only the enclosing block can terminate the \code{par/or}.

Note also that the block body runs first and properly initializes the organisms 
before they are spawned.

Once the enclosing block terminates, declared organisms are aborted and all 
memory can be reused, just as happens in standard parallel compositions.
The allocation and deallocation of organisms is static, with no runtime 
overhead such as garbage collection.
-->
<hr />
<h2 id="section-7">2</h2>
<h1 id="lexical-rules">Lexical rules</h1>
<h3 id="section-8">2.1</h3>
<h2 id="keywords">Keywords</h2>
<p>Keywords in Céu are reserved names that cannot be used as identifiers (e.g., variable and class names):</p>
<pre><code><b>

        and             async           async/thread    atomic          await

        bool            break           byte            call            call/rec

        char            class           continue        data            do

        else            else/if         emit            end             escape

        event           every           f32             f64             false

        finalize        float           FOREVER         function        global

        if              in              input           input/output    int

        interface       interrupt       kill            loop            native

        native/pre      new             not             nothing         null

        or              outer           output          output/input    par

        par/and         par/or          pause/if        pool            pre

        return          s16             s32             s64             s8

        request         sizeof          spawn           sync            tag

        then            this            traverse        true            u16

        u32             u64             u8              uint            until

        var             void            watching        with            word

        @const          @hold           @nohold         @plain          @pure

        @rec            @safe

</b></code></pre>
<h3 id="section-9">2.2</h3>
<h2 id="identifiers">Identifiers</h2>
<p>Céu uses identifiers to refer to <em>variables</em>, <em>internal events</em>, <em>external events</em>, <em>classes/interfaces</em>, <em>data types</em>, <em>data tags</em>, <em>fields</em>, and <em>native symbols</em>.</p>
<pre><code>ID       ::= &lt;a-z, A-Z, 0-9, _&gt;+
ID_var   ::= `_´ | ID           // [variables and internal events] beginning with a lowercase letter
ID_ext   ::= ID                 // [external events] all in uppercase, not beginning with a digit
ID_cls   ::= ID                 // [classes and interfaces] beginning with an uppercase letter
ID_data  ::= ID                 // [data types] beginning with an uppercase letter
ID_tag   ::= ID                 // [data tags] all in uppercase, not beginning with a digit
ID_field ::= ID                 // [fields] not beginning with a digit
ID_nat   ::= ID                 // [native symbols] beginning with an underscore
ID_type  ::= ( ID_nat | ID_cls  // [types]
             | &lt;b&gt;bool&lt;/b&gt;  | &lt;b&gt;byte&lt;/b&gt;  | &lt;b&gt;char&lt;/b&gt;  | &lt;b&gt;f32&lt;/b&gt;   | &lt;b&gt;f64&lt;/b&gt;   |
             | &lt;b&gt;float&lt;/b&gt; | &lt;b&gt;int&lt;/b&gt;   | &lt;b&gt;s16&lt;/b&gt;   | &lt;b&gt;s32&lt;/b&gt;   | &lt;b&gt;s64&lt;/b&gt;   |
             | &lt;b&gt;s8&lt;/b&gt;    | &lt;b&gt;u16&lt;/b&gt;   | &lt;b&gt;u32&lt;/b&gt;   | &lt;b&gt;u64&lt;/b&gt;   | &lt;b&gt;u8&lt;/b&gt;    |
             | &lt;b&gt;uint&lt;/b&gt;  | &lt;b&gt;void&lt;/b&gt;  | &lt;b&gt;word&lt;/b&gt; )</code></pre>
<p>Class, interface, and data <a href="#declarations">declarations</a> create new <a href="#types-2">types</a> which can be used as type identifiers.</p>
<p>Examples:</p>
<pre><code><b>var int</b> a;                    // "a" is a variable, "int" is a type
<b>emit</b> e;                       // "e" is an internal event
<b>await</b> E;                      // "E" is an external input event
<b>var</b> Sprite s;                 // "Sprite" is a class and a type
<b>var</b> List l;                   // "List" is a data type and a type
<b>return</b> list.CONS.head;        // "CONS" is a tag, "head" is a field
_printf("hello world!\n");    // "_printf" is a native symbol
</code></pre>
<h3 id="section-10">2.3</h3>
<h2 id="literals">Literals</h2>
<h4 id="section-11">2.3.1</h4>
<h3 id="booleans">Booleans</h3>
<p>Boolean types have the values <code>true</code> and <code>false</code>.</p>
<h4 id="section-12">2.3.2</h4>
<h3 id="integers">Integers</h3>
<p>Integer values can be written in different bases and also as ASCII characters:</p>
<ul>
<li>Decimals are written <em>as is</em>.</li>
<li>Octals are prefixed with <tt>0</tt>.</li>
<li>Hexadecimals are prefixed with <tt>0x</tt>.</li>
<li>ASCII characters and escape sequences are surrounded by apostrophes.</li>
<li><code>TODO: &quot;1e10&quot;</code></li>
</ul>
<p>Examples:</p>
<pre><code>// all following are equal to the decimal 127
v = 127;
v = 0777;
v = 0x7F;

// newline ASCII character = decimal 10
c = &#39;\n&#39;;</code></pre>
<h4 id="section-13">2.3.3</h4>
<h3 id="floats">Floats</h3>
<p><code>TODO (like C)</code></p>
<h4 id="section-14">2.3.4</h4>
<h3 id="null-pointer">Null pointer</h3>
<p>The <code>null</code> literal represents null <a href="#pointer">pointers</a>.</p>
<h4 id="section-15">2.3.5</h4>
<h3 id="strings">Strings</h3>
<p>A sequence of characters surrounded by <code>&quot;</code> is converted into a <em>null-terminated string</em>, just like in C:</p>
<p>Example:</p>
<pre><code>_printf(&quot;Hello World!\n&quot;);</code></pre>
<h3 id="section-16">2.4</h3>
<h2 id="comments">Comments</h2>
<p>Céu provides C-style comments.</p>
<p>Single-line comments begin with <code>//</code> and run to end of the line.</p>
<p>Multi-line comments use <code>/*</code> and <code>*/</code> as delimiters. Multi-line comments can be nested by using a different number of <code>*</code> as delimiters.</p>
<p>Examples:</p>
<pre><code><b>var int</b> a;    // this is a single-line comment

/** comments a block that contains comments

<b>var int</b> a;
/* this is a nested multi-line comment
a = 1;
*/

**/
</code></pre>
<hr />
<h2 id="section-17">3</h2>
<h1 id="types">Types</h1>
<p>Céu is statically typed, requiring all variables and events to be declared before they are used.</p>
<p>A type is composed of an identifier with a sequence of optional modifiers:</p>
<pre><code>Type ::= ID_type ( `&&´ | `&´ | `?´ | `[´ [NUM] `]´ )
</code></pre>
<p>A type identifier can be a <a href="#identifiers">native identifier</a>, a <a href="#identifiers">class identifier</a>, a <a href="#identifiers">data type identifier</a> or one of the primitive types:</p>
<pre><code>ID_type ::= ( ID_nat | ID_cls | ID_data
              <b>bool</b>  | <b>byte</b>  | <b>char</b>  | <b>f32</b>   | <b>f64</b>   |
              <b>float</b> | <b>int</b>   | <b>s16</b>   | <b>s32</b>   | <b>s64</b>   |
              <b>s8</b>    | <b>u16</b>   | <b>u32</b>   | <b>u64</b>   | <b>u8</b>    |
              <b>uint</b>  | <b>void</b>  | <b>word</b> )
</code></pre>
<p>Examples:</p>
<pre><code><b>var u8</b> v;       // "v" is of 8-bit unsigned integer type
<b>var</b> _rect r;    // "r" is of external native type "rect"
<b>var char</b>&& buf; // "buf" is a pointer to a "char"
<b>var</b> Send s;     // "s" is an organism of class "Send"
<b>var</b> Tree t;     // "t" is a data of type "Tree"
</code></pre>
<h3 id="section-18">3.1</h3>
<h2 id="primitive-types">Primitive types</h2>
<p>Céu has the following primitive types:</p>
<pre><code>    <b>void           </b>    // void type
    <b>word           </b>    // type with the size of platform dependent word
    <b>bool           </b>    // boolean type
    <b>char           </b>    // char type
    <b>byte           </b>    // 1-byte type
    <b>int      uint  </b>    // platform dependent signed and unsigned integer
    <b>s8       u8    </b>    // signed and unsigned  8-bit integer
    <b>s16      u16   </b>    // signed and unsigned 16-bit integer
    <b>s32      u32   </b>    // signed and unsigned 32-bit integer
    <b>s64      u64   </b>    // signed and unsigned 64-bit integer
    <b>float          </b>    // platform dependent float
    <b>f32      f64   </b>    // 32-bit and 64-bit floats
</code></pre>
<p>See also the <a href="#literals">literals</a> for these types.</p>
<h3 id="section-19">3.2</h3>
<h2 id="native-types">Native types</h2>
<p>Types defined externally in C can be prefixed by <code>_</code> to be used in Céu programs.</p>
<p>Example:</p>
<pre><code><b>var</b> _message_t msg;      // "message_t" is a C type defined in an external library
</code></pre>
<p>Native types support <a href="#native-symbols">annotations</a> which provide additional information to the compiler.</p>
<!--
The size of an external type must be explicitly [[#sec.stmts.decls.types|declared]].

Example:

    native _char = 1;  // declares the external native type `_char` of 1 byte
-->
<h3 id="section-20">3.3</h3>
<h2 id="class-and-interface-types">Class and Interface types</h2>
<p><code>TODO (brief description)</code></p>
<p>See <a href="#classes-and-interfaces">Classes and Interfaces</a>.</p>
<h3 id="section-21">3.4</h3>
<h2 id="type-modifiers">Type modifiers</h2>
<p>Types can be suffixed with the following modifiers: <code>&amp;</code>, <code>&amp;&amp;</code>, <code>?</code>, and <code>[N]</code>.</p>
<h4 id="section-22">3.4.1</h4>
<h3 id="references">References</h3>
<p><code>TODO</code></p>
<p>Céu supports two forms of references: <em>aliases</em> and <em>pointers</em>.</p>
<h5 id="section-23">3.4.1.1</h5>
<h4 id="alias">Alias</h4>
<p><code>TODO (like C++ references)</code></p>
<h5 id="section-24">3.4.1.2</h5>
<h4 id="pointer">Pointer</h4>
<p><code>TODO (like C)</code></p>
<p>restrictions - across yielding statements</p>
<h4 id="section-25">3.4.2</h4>
<h3 id="option">Option</h3>
<p><code>TODO (like Maybe)</code></p>
<h4 id="section-26">3.4.3</h4>
<h3 id="dimension">Dimension</h3>
<p><code>TODO (vectors, pools)</code></p>
<p>One-dimensional vectors are declared by suffixing the variable type with the vector length surrounded by <code>[</code> and <code>]</code>. The first index of a vector is zero.</p>
<p>Example:</p>
<pre><code><b>var int</b>[2] v;       // declares a vector "v" of 2 integers
</code></pre>
<hr />
<h2 id="section-27">4</h2>
<h1 id="statements">Statements</h1>
<h3 id="section-28">4.1</h3>
<h2 id="blocks">Blocks</h2>
<p>A block is a sequence of statements separated by semicolons (<code>;</code>):</p>
<pre><code>Block ::= { Stmt `;´ }</code></pre>
<p><em>Note: statements terminated with the <code>end</code> keyword do not require a terminating semicolon.</em></p>
<p>A block creates a new scope for <a href="#variables">variables</a>, which are only visible for statements inside the block.</p>
<p>Compound statements (e.g. <a href="#conditional">if-then-else</a>) create new blocks and can be nested for an arbitrary level.</p>
<h4 id="section-29">4.1.1</h4>
<h3 id="do-end">do-end</h3>
<p>A block can be explicitly created with the <code>do-end</code> statement:</p>
<pre><code>Do ::= <b>do</b> Block <b>end</b>
</code></pre>
<h4 id="section-30">4.1.2</h4>
<h3 id="pre">Pre</h3>
<p>TODO (&quot;static code&quot; appended in sequence to the beginning)</p>
<pre><code>Pre ::= <b>pre do</b> Block <b>end</b>
</code></pre>
<h3 id="section-31">4.2</h3>
<h2 id="nothing">Nothing</h2>
<p><code>nothing</code> is a innocuous statement:</p>
<pre><code>Nothing ::= <b>nothing</b>
</code></pre>
<h3 id="section-32">4.3</h3>
<h2 id="declarations">Declarations</h2>
<h4 id="section-33">4.3.1</h4>
<h3 id="variables">Variables</h3>
<p>The syntax for the definition of variables is as follows:</p>
<pre><code>DclVar ::= <b>var</b> Type ID_var [`=´ Assignment] { `,´ ID_var [`=´ Assignment] }
</code></pre>
<p>A variable has an associated <a href="#types">type</a> and can be optionally initialized (see <a href="#assignments">Assignments</a>).</p>
<p>Variables are only visible inside the <a href="#blocks">block</a> they are defined.</p>
<p>Examples:</p>
<pre><code><b>var int</b> a=0, b=3;   // declares and initializes integer variables "a" and "b"
<b>var int</b>[2] v;       // declares a vector "v" of size 2
</code></pre>
<h5 id="section-34">4.3.1.1</h5>
<h4 id="organisms">Organisms</h4>
<p>An organism is a variable whose type is the identifier of a <a href="#classes-and-interfaces">class declaration</a>. An optional constructor can initialize the organism fields:</p>
<pre><code>DclOrg ::= <b>var</b> Type ID_var [ <b>with</b>
              Block
           <b>end</b> ]
</code></pre>
<p>Example:</p>
<pre><code><b>class</b> T <b>with</b>
    <b>var int</b> v;
<b>do</b>
    &lt;body-of-T&gt;
<b>end</b>
<b>var</b> T t <b>with</b>       // "t" is an organism of class "T"
    <b>this</b>.v = 0;    // whose field "v" is initialized to "0"
<b>end</b>
</code></pre>
<p>After the declaration, the body of an organism starts to execute in [parallel](#parallel-compositions] with the rest of the application. The table below shows the equivalent expansion of an organism declaration to a <a href="#paror"><code>par/or</code></a> containing the class body:</p>
<table width="100%">
<tr valign="top">
<td>
<pre><code>&lt;code-pre-declaration&gt;
<b>var</b> T t <b>with</b>
    &lt;code-constructor-of-t&gt;
<b>end</b>;
&lt;code-pos-declaration&gt;
</code></pre>
</td>
<td>
<pre><code>&lt;code-pre-declaration&gt;
<b>par/or do</b>
    &lt;code-constructor-of-t&gt;
    &lt;code-body-of-class-T&gt;
    <b>await FOREVER;</b>
<b>with</b>
    &lt;code-pos-declaration&gt;
<b>end</b>
</code></pre>
</td>
</tr>
</table>
<p>Given that an organism is a variable, the block it is declared restricts its lifetime. In the expansion, the <code>par/or</code> makes the organism to go out of scope when <code>&lt;code-pos-declaration&gt;</code> terminates.</p>
<p><code>TODO (assumes code-pos-declaration closes the block exactly on the end)</code></p>
<p><code>TODO (vectors of organisms: copy the declaration N times)</code></p>
<h6 id="section-35">4.3.1.1.1</h6>
<h5 id="constructors">Constructors</h5>
<p>Inside constructors the expression <code>this</code> refers to the new organism, while the expression <code>outer</code> refers to the enclosing organism creating the new organism:</p>
<pre><code><b>class</b> U <b>with</b>
    <b>var int</b> v;
<b>do</b>
    ...
<b>end</b>

<b>class</b> T <b>with</b>
    <b>var int</b> v;
<b>do</b>
    <b>var</b> U u <b>with</b>
        <b>this</b>.v = <b>outer</b>.v;   // "this" is of class "U", "outer" is of class "T"
    <b>end</b>;
<b>end</b>
</code></pre>
<h4 id="section-36">4.3.2</h4>
<h3 id="pools">Pools</h3>
<p>A pool is a container for <a href="#spawn">dynamic instances of organisms</a> and <a href="#TODO">recursive data</a> of the same type:</p>
<pre><code>DclPool ::= <b>pool</b> Type ID_var [`=´ Assignment] { `,´ ID_var [`=´ Assignment] }
</code></pre>
<p>The type has to be a <a href="#identifiers">class, interface, or data type identifier</a> followed by a <a href="#dimension">dimension modifier</a>. For pools of classes and recursive data types, the number inside the dimension brackets represents the maximum number of instances supported by the pool. For pools of interfaces, the number represents the maximum number of bytes for all instances (as each instance may have a different size).</p>
<p>The number inside the vector modifier brackets is optional. If not specified, the number of instances in the pool is unbounded and all allocations go to the heap. When specified, allocation goes to a static memory pool preallocated at compile time.</p>
<p>Examples:</p>
<code>
<pre><b>pool</b> T[10]  ts;      // a pool of at most 10 instances of class "T"
<b>pool</b> T[]    ts;      // an unbounded pool of instances of class "T"
<b>pool</b> I[100] is;      // a pool of at most 100 bytes of instances of interface "I"
<b>pool</b> I[]    is;      // an unbounded pool of instances of interface "I"
<b>pool</b> D[100] ds;      // a pool of at most 100 instances of recursive data type "D"
<b>pool</b> D[]    ds;      // an unbounded pool of instances of recursive data type "D"
</code></pre>
<p>The lifetime of all instances inside a pool is restricted to the block it is declared. When a pool of organisms goes out of scope, all organism bodies are automatically aborted.</p>
<p>See <a href="#spawn">Dynamic execution</a> for organisms allocation. See <a href="#TODO">TODO</a> for recursive data allocation.</p>
<h4 id="section-37">4.3.3</h4>
<h3 id="functions">Functions</h3>
<p><code>TODO (intro/prototype/implementation)</code></p>
<pre><code>/* internal functions */
DclFun ::= <b>function</b> [<b>@rec</b>] `(´ParList`)´ `=>´ Type ID_var
              [ `do´ Block `end´ ]

/* external functions */
DclFunExt ::= <b>output</b> [<b>@rec</b>] `(´ParList`)´ `=>´ Type ID_var ID_ext { `,´ ID_ext }
            | <b>input</b>  [<b>@rec</b>] `(´ParList`)´ `=>´ Type ID_var ID_ext { `,´ ID_ext }
                 [ `do´ Block `end´ ]

Return ::= <b>return</b> [Exp]

ParList ::= ParItem { `,´ ParItem }
ParItem ::= [<b>@hold</b>] Type [ID_var]
</code></pre>
<h5 id="section-38">4.3.3.1</h5>
<h4 id="internal-functions">Internal functions</h4>
<p><code>TODO (like functions in any language)</code></p>
<h5 id="section-39">4.3.3.2</h5>
<h4 id="external-functions">External functions</h4>
<p><code>TODO (more or less like dynamically loaded functions)</code></p>
<h6 id="section-40">4.3.3.2.1</h6>
<h5 id="return">return</h5>
<p><code>TODO (like return in any language)</code></p>
<h4 id="section-41">4.3.4</h4>
<h3 id="interrupt-service-routines">Interrupt service routines</h3>
<p><code>TODO</code></p>
<pre><code>DclIsr ::= <b>interrupt</b> `[´ NUM `]´ [<b>@rec</b>]
              [ `do´ Block `end´ ]
</code></pre>
<h4 id="section-42">4.3.5</h4>
<h3 id="events">Events</h3>
<p>See also <a href="#event-handling">Event handling</a>.</p>
<h5 id="section-43">4.3.5.1</h5>
<h4 id="internal-events">Internal events</h4>
<p>Internal events have the same purpose of external events, but for <a href="#internal-reactions">communication within trails in a program</a>.</p>
<p>The declaration of internal events is as follows:</p>
<pre><code>DclInt ::= <b>event</b> (Type | `(´ TypeList `)´) ID_var { `,´ ID_var }
</code></pre>
<p>In contrast with external events, an internal event is for input and output at the same time.</p>
<p>Internal events cannot be of a vector type.</p>
<p><em>Note: <tt>void</tt> is a valid type for signal-only internal events.</em></p>
<p><span id="sec.stmts.decls.c"></span></p>
<h5 id="section-44">4.3.5.2</h5>
<h4 id="external-events">External events</h4>
<p>External events are used as interfaces between programs and devices from the real world:</p>
<ul>
<li><em>input</em> events represent input devices, such as sensors, switches, etc.</li>
<li><em>output</em> events represent output devices, such as LEDs, motors, etc.</li>
</ul>
<p>Being reactive, programs in Céu have input events as their sole entry points through <a href="#await-statements">await statements</a>.</p>
<p>The declaration of input and output events is as follows:</p>
<pre><code>DclExt ::= <b>output</b> (Type | `(´ TypeList `)´) ID_ext { `,´ ID_ext }
         | <b>input</b>  (Type | `(´ TypeList `)´) ID_ext { `,´ ID_ext }

TypeList ::= Type { `,´ Type }
</code></pre>
<p>Events communicate values between the environment and the application (and vice-versa). The declaration includes the <a href="#types">type</a> of the value, which can be also a list of types when the event communicates multiple values.</p>
<p><em>Note: <code>void</code> is a valid type for signal-only events.</em></p>
<p>The visibility of external events is always global, regardless of the block they are declared.</p>
<p>Examples:</p>
<pre><code><b>input void</b> A,B;      // "A" and "B" are input events carrying no values
<b>output int</b> MY_EVT;   // "MY_EVT" is an output event carrying integer values
</code></pre>
<p>The availability of external events depends on the platform in use. Therefore, external declarations just make pre-existing events visible to a program.</p>
<p>Refer to <a href="#environment">Environment</a> for information about interfacing with external events in the platform level.</p>
<h6 id="section-45">4.3.5.2.1</h6>
<h5 id="external-requests">External Requests</h5>
<p><code>TODO (emit + await)</code></p>
<pre><code>DclReq ::= <b>output/input</b> `[´ [Exp] `]´ `(´ParList`)´ `=>´ Type ID_ext { `,´ ID_ext }
         | <b>input/output</b> `[´ [Exp] `]´ `(´ParList`)´ `=>´ Type ID_ext { `,´ ID_ext }
            [ `do´ Block `end´ ]
</code></pre>
<!--
An external event is either of type input or output, never being both at the 
same time.
For devices that perform input and output (e.g. radio transceivers), the 
underlying platform must provide different events for each functionality.
-->
<h4 id="section-46">4.3.6</h4>
<h3 id="classes-and-interfaces">Classes and Interfaces</h3>
<p>A <code>class</code> is a template for creating organisms. It contains an <em>interface</em> and a <em>body</em> common to all instances of the class. The interface exposes internal variables, events, and methods that other organisms can manipulate directly. The body specifies the behavior of the organism and executes when it is instantiated.</p>
<p>An <code>interface</code> is a template for classes that shares the same interface<sup>1</sup>. The body and method implementations may vary among classes sharing the same interface.</p>
<p>(<sup>1</sup> <em>The term &quot;interface&quot; is overload with two possible meanings: the set of members exposed by a class; and a template that defines a set of members that classes can reuse.</em>)</p>
<p>The declaration of classes and interfaces is as follows:</p>
<pre><code>DclCls ::= <b>class</b> ID_cls <b>with</b>
                Dcls    // interface
            <b>do</b>
                Block   // body
            <b>end</b>

DclIfc ::= <b>interface</b> ID_cls <b>with</b>
                Dcls    // interface
            <b>end</b>

Dcls ::= { (DclVar | DclInt | DclPool | DclFun | DclImp) `;´ }

DclImp ::= <b>interface</b> ID_cls { `,´ ID_cls }
</code></pre>
<p><code>Dcls</code> is a sequence of variables, events, pools, and functions (methods) declarations. It can also refer to other interfaces through a <code>DclImp</code> clause, which copies all declarations from the referred interfaces.</p>
<h4 id="section-47">4.3.7</h4>
<h3 id="data-types">Data Types</h3>
<p><code>TODO</code></p>
<pre><code>DclData ::= <b>data</b> ID_data <b>with</b>
                (Struct | Union)
            <b>end</b>

Struct ::= DclVar `;´ { DclVar `;´ }
Union  ::= DclTag { <b>or</b> DclTag }

DclVar ::= <b>var</b> Type ID_var { `,´ ID_var }
DclTag ::= <b>tag</b> ID_tag <b>with</b>
               DclVar `;´ { DclVar `;´ }
           <b>end</b>
</code></pre>
<p>Example (structured data type)</p>
<pre><code><b>data</b> Foo <b>with</b>
    <b>var u8</b> a;
    <b>var int</b> b;
    <b>var s16</b> c;
<b>end</b>
</code></pre>
<p>Example (tagged data type)</p>
<pre><code><b>data</b> Foo <b>with</b>
    // declare 'BAR' as one possible structure of 'Foo'
    <b>tag</b> BAR <b>with</b>
        <b>var u8</b> a;
        <b>var int</b> b;
        <b>var s16</b> c;
    <b>end</b>
    
    <b>or</b>
    
    // declare 'BAZ' as another possible structure of 'Foo'
    <b>tag</b> BAZ <b>with</b> 
        <b>var int</b> d;
        <b>var s8</b> e;
    <b>end</b>
<b>end</b>
</code></pre>
<p><i>Note: Céu vectors are not yet supported within data types!</i></p>
<h4 id="section-48">4.3.8</h4>
<h3 id="native-declarations">Native declarations</h3>
<h5 id="section-49">4.3.8.1</h5>
<h4 id="native-blocks">Native blocks</h4>
<p><code>TODO (native/pre)</code></p>
<p>Native blocks define new types, variables, and functions in C:</p>
<pre><code>Native ::= (<b>native</b> | <b>native/pre</b>) <b>do</b>
               &lt;code_in_C&gt;
           <b>end</b>
</code></pre>
<!--
Whatever is written inside a C block is placed on the top of the final output of the Céu parser (which is a C file).
-->
<p>Example:</p>
<pre><code><b>native do</b>
    #include <assert.h>
    int inc (int i) {
        return i+1;
    }
<b>end</b>
_assert(_inc(0) == 1);
</code></pre>
<p>If the code in C contains the terminating <code>end</code> keyword of Céu, the <code>native</code> block should be delimited with any matching comments to avoid confusing the parser:</p>
<pre><code><b>native do</b>
    /*** c code ***/
    char str = "This `end` confuses the parser";
    /*** c code ***/
<b>end</b>
</code></pre>
<h5 id="section-50">4.3.8.2</h5>
<h4 id="native-annotations">Native annotations</h4>
<p>Native declarations provide additional information about external C symbols. A declaration is an annotation followed by a list of symbols:</p>
<pre><code>DclNat   ::= <b>native</b> [<b>@pure</b>|<b>@const</b>|<b>@nohold</b>|<b>@plain</b>] Nat_list
Nat_list  ::= (Nat_type|Nat_func|Nat_var) { `,` (Nat_type|Nat_func|Nat_var) }
Nat_type  ::= ID_nat `=´ NUM
Nat_func  ::= ID_nat `(´ `)´
Nat_var   ::= ID_nat
</code></pre>
<p>A type declaration may define its size in bytes to help the compiler organizing memory. A type of size <code>0</code> is an <em>opaque type</em> and cannot be instantiated as a variable that is not a pointer.</p>
<p>Functions and variables are distinguished by the <code>()</code> that follows function declarations.</p>
<p>Native symbols can have the following annotations:</p>
<p><strong><span class="citation">@plain</span></strong> states that the type is not a pointer to another type. <strong><span class="citation">@const</span></strong> states that the symbol is a constant (e.g. a <code>#define</code>). <strong><span class="citation">@pure</span></strong> states that the function has no side effects. <strong><span class="citation">@nohold</span></strong> states that the function does not hold pointers passed as parameters.</p>
<p>The <a href="#static-analysis">static analysis</a> of Céu relies on annotations.</p>
<!--
By default, [concurrent](#concurrency) accesses to external symbols are 
considered [non-deterministic](#deterministic), because the Céu compiler has no 
information about them.
For the same reason, functions are considered to be impure (i.e. performing 
side-effects), and C variables to point to any memory location.

Annotations are discussed in more depth in sections [do-finally-end](#do) and 
TODO(determinism).
-->
<p>Examples:</p>
<pre><code><b>native</b> _char=1, _FILE=0;              // "char" is a 1-byte type, while `FILE` is "opaque"
<b>native @plain</b>  _rect;                  // "rect" is not a pointer type
<b>native @const</b>  _NULL;                  // "NULL" is a constant
<b>native @pure</b>   _abs(), _pow();         // "abs" and "pow" are pure functions
<b>native @nohold</b> _fprintf(), _sprintf(); // functions receive pointers but do not hold references to them
</code></pre>
<p><span id="sec.stmts.decls.det"></span></p>
<h4 id="section-51">4.3.9</h4>
<h3 id="deterministic-annotations">Deterministic annotations</h3>
<p>A variable or function can be declared as <code>@safe</code> with a set of other functions or variables:</p>
<pre><code>DclDet ::= <b>@safe</b> ID <b>with</b> ID { `,´ ID }
</code></pre>
<p>Example:</p>
<pre><code><b>native</b> _p, _f1(), _f2();
<b>@safe</b> _f1 <b>with</b> _f2;
<b>var int</b>* p;
<b>@safe</b> p <b>with</b> _p;
<b>par do</b>
    _f1(...);    // `f1` is safe with `f2`
    *p = 1;      // `p`  is safe with `_p`
    ...
<b>with</b>
    _f2(...);    // `f2` is safe with `f1`
    *_p = 2;     // `_p` is safe with `p`
    ...
<b>end</b>
</code></pre>
<p>See also <a href="#static-analysis">Static analysis</a>.</p>
<h3 id="section-52">4.4</h3>
<h2 id="assignments">Assignments</h2>
<p>Céu supports many kinds of assignments:</p>
<pre><code>Set ::= (Exp | `(´VarList`)´) `=´ Assignment

VarList ::= ID_var  { `,´ ID_var } `)´

Assignment ::= Exp
             | AssignableBlock
             | &lt;await&gt;
             | ( [ `(´ ] &lt;emit-ext&gt
                       | &lt;call-ext&gt;
                       | &lt;request-ext&gt;
                 [ `)´ ] )
             | [ `new´ ] Data
             | &lt;traverse-loop&gt;
             | &lt;traverse-rec&gt;
             | Vector
             | &lt;lua&gt;
             | &lt;do-org&gt;
             | &lt;spawn&gt;
             | &lt;thread&gt;
</code></pre>
<p>The expression on the left side must be <a href="#assignable">assignable</a>.</p>
<p>TODO (Exp, VarList)</p>
<h4 id="section-53">4.4.1</h4>
<h3 id="simple-assignment">Simple assignment</h3>
<p>The simpler form of assignment uses <a href="#expressions">expressions</a> as values.</p>
<p>Example:</p>
<pre><code><b>var int</b> a,b;
a = b + 1;
</code></pre>
<h4 id="section-54">4.4.2</h4>
<h3 id="block-assignment">Block assignment</h3>
<p>A whole block can be used as an assignment value by escaping from it. The following block statements can be used in assignments: <a href="#do-end"><code>do-end</code></a> <a href="#conditional"><code>if-then-else</code></a>, <a href="#loop"><code>loop</code></a>, <a href="#every"><code>every</code></a>, and <a href="#par"><code>par</code></a>:</p>
<pre><code>AssignableBlock ::= &lt;do-end&gt; | &lt;if-then-else&gt; | &lt;loop&gt; | &lt;every&gt; | &lt;par&gt;
</code></pre>
<h5 id="section-55">4.4.2.1</h5>
<h4 id="escape">escape</h4>
<p>An <code>escape</code> statement escapes the deepest block being assigned to a variable. The expression following it is then assigned to the respective variable:</p>
<pre><code>Escape ::= <b>escape</b> Exp
</code></pre>
<p>Every possible path inside the block must reach a <code>escape</code> statement whose expression becomes the final value of the assignment. <!--[TODO: static analysis or halt]--></p>
<p>Example:</p>
<pre><code>a = <b>loop do</b>              // a=1, when "cond" is satisfied
        ...
        <b>if</b> cond <b>then</b>
            <b>escape</b> 1;    // "loop" is the deepest assignment block
        <b>end</b>
        ...
    <b>end</b>
</code></pre>
<p>Every program in Céu contains an implicit <code>do-end</code> surrounding it, assigning to a special integer variable <code>$ret</code> holding the return value for the program execution.</p>
<p>Therefore, a program such as</p>
<pre><code><b>escape</b> 1;
</code></pre>
<p>should read as</p>
<pre><code><b>var int</b> $ret =
    <b>do</b>
        <b>escape</b> 1;
    <b>end</b>;
</code></pre>
<h4 id="section-56">4.4.3</h4>
<h3 id="await-assignment">Await assignment</h3>
<p>See <a href="#await-statements">Await statements</a>.</p>
<h4 id="section-57">4.4.4</h4>
<h3 id="emit-assignment">Emit assignment</h3>
<p>See <a href="#emit-statements">Emit statements</a>.</p>
<h4 id="section-58">4.4.5</h4>
<h3 id="data-assignment">Data assignment</h3>
<p><code>TODO</code></p>
<pre><code>Data ::= ID_data [`.´ ID_tag] `(´ List `)´
List ::= [ (Data|Exp) { `,´ (Data|Exp) } ]
</code></pre>
<p>Example (structured data type)</p>
<pre><code>// calls the constructor for 'Foo' and uses the provided values for struct initialization
<b>var</b> Foo f = Foo(4, 7, 1);
</code></pre>
<p>Example (tagged data type)</p>
<pre><code>// calls the constructor for 'Foo' (using tag BAZ) and uses the provided values for struct initialization
<b>var</b> Foo f = Foo.BAZ(2, -9);
</code></pre>
<h4 id="section-59">4.4.6</h4>
<h3 id="traverse-assignment">Traverse assignment</h3>
<p><code>TODO</code></p>
<h4 id="section-60">4.4.7</h4>
<h3 id="vector-assignment">Vector assignment</h3>
<p><code>TODO</code></p>
<pre><code>Vector ::= Item { `..´ Item }
Item   ::= Exp | `[´ [ExpList] `]´
</code></pre>
<p>Example</p>
<pre><code><b>var int</b>[3] v;        // declare an empty vector of length 3
v = v .. [8];        // append value '8' to the empty vector
v = v .. [1] .. [5]; // append the values '1' and '5' to the vector
                     // here: v = {8, 1, 5}
</code></pre>
<h4 id="section-61">4.4.8</h4>
<h3 id="lua-assignment">Lua assignment</h3>
<p><code>TODO</code></p>
<h4 id="section-62">4.4.9</h4>
<h3 id="do-organism-assignment">Do organism assignment</h3>
<p><code>TODO</code></p>
<h4 id="section-63">4.4.10</h4>
<h3 id="spawn-assignment">Spawn assignment</h3>
<p>See <a href="#spawn">Spawn</a>.</p>
<h4 id="section-64">4.4.11</h4>
<h3 id="thread-assignment">Thread assignment</h3>
<p>See <a href="#threads">Threads</a>.</p>
<h3 id="section-65">4.5</h3>
<h2 id="calls">Calls</h2>
<p>The syntax for function calls is as follows:</p>
<pre><code>/* internal calls */
CallInt ::= [<b>call</b>|<b>call/rec</b>] Exp * `(´ [ExpList] `)´

/* external calls */
CallExt ::= (<b>call</b>+<b>call/rec</b>) ID_ext [ `=>´ (Exp | `(´ [ExpList] `)´)

ExpList = Exp { `,´ Exp }
</code></pre>
<!--
The called expression has to evaluate to a [internal](#internal-functions), 
[external](#external-functions)), or [native](#native-symbols) function.
For internal and native calls, the `call` operator is optional, but recursive 
functions must use the `call/rec` operator (see [Static 
analysis](#static-analysis)).

Examples:

```
_printf("Hello World!\n");  // calls native "printf"
o.f();                      // calls method "f" of organism "o"
F(1,2,3);                   // calls external function "F"
```

TODO: unbounded execution
Native functions cannot be \CEU does not extend the bounded execution analysis 
to $C$ function calls.
On the one hand, $C$ calls must be carefully analyzed in order to keep programs
responsive.
On the other hand, they also provide means to circumvent the rigor of \CEU in a
well-marked way (the special underscore syntax).
-->
<h4 id="section-66">4.5.1</h4>
<h3 id="internal-calls">Internal calls</h3>
<p><code>TODO</code></p>
<h4 id="section-67">4.5.2</h4>
<h3 id="external-calls">External calls</h3>
<p><code>TODO</code></p>
<h3 id="section-68">4.6</h3>
<h2 id="event-handling">Event handling</h2>
<p>Events are the most fundamental concept of Céu, accounting for its reactive nature. Programs manipulate events through the <code>await</code> and <code>emit</code> statements. An <code>await</code> halts the running trail until that event occurs. An event occurrence is broadcast to all trails trails awaiting that event, awaking them to resume execution.</p>
<p>Céu supports external and internal events. External events are triggered by the <a href="#environment">environment</a>, while internal events, by the <code>emit</code> statement. See also <a href="#synchronous-execution-model">Synchronous execution model</a> for the differences between external and internal reactions.</p>
<h4 id="section-69">4.6.1</h4>
<h3 id="await-statements">Await statements</h3>
<p>The <code>await</code> statement halts the running trail until the referred <em>wall-clock</em> time, <a href="#external">input event</a>, or <a href="#internal">internal event</a> occurs.</p>
<pre><code>Await ::= ( <b>await</b> ID_ext |
            <b>await</b> Exp    |
            <b>await</b> (WCLOCKK|WCLOCKE)
          ) [ <b>until</b> Exp ]
       | <b>await</b> <b>FOREVER</b>

WCLOCKK ::= [NUM <b>h</b>] [NUM <b>min</b>] [NUM <b>s</b>] [NUM <b>ms</b>] [NUM <b>us</b>]
WCLOCKE ::= `(´ Exp `)´ (<b>h</b>|<b>min</b>|<b>s</b>|<b>ms</b>|<b>us</b>)
</code></pre>
<p>Examples:</p>
<pre><code><b>await</b> A;                  // awaits the input event `A`
<b>await</b> a;                  // awaits the internal event `a`

<b>await</b> 10min3s5ms100us;    // awaits the specified time
<b>await</b> (t)ms;              // awaits the current value of the variable `t` in milliseconds
    
<b>await FOREVER</b>;            // awaits forever
</code></pre>
<p>An <code>await</code> may evaluate to zero or more values which can be captured with the optional assignment syntax.</p>
<p>The optional <code>until</code> clause tests an additional condition required to awake. It can be understood as the expansion below:</p>
<pre><code><b>loop do</b>
    <b>await</b> &lt;...&gt;;
    <b>if</b> &lt;Exp&gt; <b>then</b>
        <b>break</b>;
    <b>end</b>
<b>end</b>
</code></pre>
<h5 id="section-70">4.6.1.1</h5>
<h4 id="await-event">Await event</h4>
<p>For await statements with <a href="#internal">internal</a> or <a href="#external">external</a> events, the running trail awakes when the referred event is emitted. The <code>await</code> evaluates to the type of the event.</p>
<pre><code><b>input int</b> E;
<b>var int</b> v = <b>await</b> E;

<b>event</b> (<b>int</b>,<b>int</b>*) e;
<b>var int</b>  v;
<b>var int</b>* ptr;
(v,ptr) = <b>await</b> e;
</code></pre>
<p><code>TODO (awake rule for internal events, unless &quot;every&quot;)</code></p>
<h5 id="section-71">4.6.1.2</h5>
<h4 id="await-time">Await time</h4>
<p>For await statements with <em>wall-clock</em> time (i.e., time measured in minutes, milliseconds, etc.), the running trail awakes when the referred time elapses.</p>
<p>A constant time is expressed with a sequence of value/unit-of-time pairs (see <code>WCLOCKK</code> above). An expression time is specified with an expression in parenthesis followed by a single unit of time (see <code>WCLOCKE</code> above).</p>
<p>The <code>await</code> evaluates to the <em>residual delta time (dt)</em> (i.e. elapsed time <em>minus</em> requested time), measured in microseconds:</p>
<pre><code><b>var int</b> dt = <b>await</b> 30ms;    // if 31ms elapses, then dt=1000
</code></pre>
<p><em>Note: <code>dt</code> is always greater than or equal to 0.</em></p>
<!--
Refer to [[#Environment]] for information about storage types for *wall-clock* 
time.
-->
<p><span id="sec.stmts.events.await.forever"></span></p>
<h5 id="section-72">4.6.1.3</h5>
<h4 id="await-organism">Await organism</h4>
<p><code>TODO</code></p>
<h5 id="section-73">4.6.1.4</h5>
<h4 id="await-forever">Await FOREVER</h4>
<p>The <code>await FOREVER</code> halts the running trail forever. It cannot be used in assignments, because it never evaluates to anything.</p>
<h4 id="section-74">4.6.2</h4>
<h3 id="emit-statements">Emit statements</h3>
<p>The <code>emit</code> statement triggers the referred <em>wall-clock</em> time, <a href="#external">input event</a>, or <a href="#internal">internal event</a>, awaking all trails waiting for it.</p>
<pre><code>Emit ::= <b>emit</b> Exp    [ `=>´ (Exp | `(´ [ExpList] `)´)
      |  <b>emit</b> ID_ext [ `=>´ (Exp | `(´ [ExpList] `)´)
      |  <b>emit</b> (WCLOCKK|WCLOCKE)
</code></pre>
<h5 id="section-75">4.6.2.1</h5>
<h4 id="emit-event">Emit event</h4>
<p>Emit statements with <a href="#internal">internal</a> or <a href="#external">external</a> events expect parameters that match the event type (unless the event is of type <code>void</code>).</p>
<p>Examples:</p>
<pre><code><b>output int</b> E;
<b>emit</b> E => 1;

<b>event</b> (<b>int</b>,<b>int</b>) e;
<b>emit</b> e => (1,2);
</code></pre>
<p>External input events can only be emitted inside <a href="#asynchronous-blocks">asynchronous blocks</a>.</p>
<p>The emission of internal events start new <a href="#internal-reactions">internal reactions</a>.</p>
<p><code>TODO (emit output evaluates to &quot;int&quot;)</code></p>
<!--
: An emit on an output event returns immediately a status code of the action 
that runs asynchronously with the program.
: Both the status code and that asynchronous actions are platform dependent. The status code is always of type <tt>int</tt>.
:
: Example:

<pre><code><b>output int</b> SEND;
<b>if not emit</b> SEND=>1 then
   <b>return</b> 0;
<b>end</b>
</code></pre>
:
-->
<h5 id="section-76">4.6.2.2</h5>
<h4 id="emit-time">Emit time</h4>
<p>Emit statements with <em>wall-clock</em> time expect expressions with units of time, as described in <a href="#await-time">Await time</a>.</p>
<p>Like input events, time can only be emitted inside <a href="#asynchronous-blocks">asynchronous blocks</a>.</p>
<h4 id="section-77">4.6.3</h4>
<h3 id="requests">Requests</h3>
<p><code>TODO (emit+await)</code></p>
<pre><code>Request ::= <b>request</b> ID_ext [ `=>´ (Exp | `(´ [ExpList] `)´)
</code></pre>
<h3 id="section-78">4.7</h3>
<h2 id="organism-instantiation">Organism instantiation</h2>
<h4 id="section-79">4.7.1</h4>
<h3 id="do-organism">Do organism</h3>
<p><code>TODO</code></p>
<pre><code>DoOrg ::= <b>do</b> ID_cls [<b>with</b>
              Constructor
          <b>end</b>]
</code></pre>
<h4 id="section-80">4.7.2</h4>
<h3 id="spawn">Spawn</h3>
<p>The <code>spawn</code> statement creates instances of organisms dynamically:</p>
<pre><code>Spawn ::= <b>spawn</b> ID_cls [<b>in</b> Exp] [<b>with</b>
              Constructor
          <b>end</b>]
</code></pre>
<p>TODO(option return) <!--
The `spawn` returns a pointer to the allocated organism, or `null` in the case 
of failure.
--></p>
<p>The optional <code>in</code> clause allows the statement to specify in which <a href="#pools">pool</a> the organisms will live. If absent, the organism is allocated on an implicit pool in the outermost block of the class the allocation happens.</p>
<p>On allocation, the body of the organism starts to execute in parallel with the rest of the application, just like <a href="#organisms">static organisms</a>. The constructor clause is also the same as for <a href="#constructors">static organisms</a>.</p>
<p>In contrast to static organisms, the lifetime of a dynamic instance is attached to the scope of the pool and not to the scope of the <code>spawn</code> instantiation. Furthermore, a dynamic organism is automatically deallocated when its execution body terminates.</p>
<p>See <a href="#organisms-references">Static analysis</a> for the restrictions on manipulating pointers and references to organisms.</p>
<h4 id="section-81">4.7.3</h4>
<h3 id="kill">Kill</h3>
<p><code>TODO</code></p>
<pre><code><b>kill</b> * Exp * [ `=>´ Exp ]
</code></pre>
<h3 id="section-82">4.8</h3>
<h2 id="conditional">Conditional</h2>
<p>Conditional flow uses the <code>if-then-else</code> statement:</p>
<pre><code>If ::= <b>if</b> Exp <b>then</b>
           Block
       { <b>else/if</b> Exp <b>then</b>
           Block }
       [ <b>else</b>
           Block ]
       <b>end</b>
</code></pre>
<p>The block following <code>then</code> executes if the condition expression after the <code>if</code> evaluates to a non-zero value. Otherwise, the same process holds each <code>else/if</code> alternative. Finally, it they all fail, the block following the <code>else</code> executes.</p>
<h3 id="section-83">4.9</h3>
<h2 id="loop">Loop</h2>
<p>A <code>loop</code> continuously executes its body block:</p>
<pre><code>Loop ::= <b>loop</b>[`/´ Exp] [ ID_var [<b>in</b> Exp] ] <b>do</b>
             Block
         <b>end</b>
</code></pre>
<p>A <code>loop</code> terminates when it reaches a <a href="#break"><code>break</code></a> or its (optional) <a href="#iterators">iterator</a> terminates.</p>
<p><code>TODO (hard limit)</code></p>
<h4 id="section-84">4.9.1</h4>
<h3 id="break">break</h3>
<p>A <code>break</code> escapes the innermost enclosing loop:</p>
<pre><code>Break ::= <b>break</b>
</code></pre>
<p>Example:</p>
<pre><code><b>loop do</b>                   // loop 1
    ...
    <b>loop do</b>               // loop 2
        <b>if</b> &lt;cond-1&gt; <b>then</b>
            <b>break</b>;        // escapes loop 2
        <b>end</b>
        ...
    <b>end</b>
    ...
    <b>if</b> &lt;cond-2&gt; <b>then</b>
        <b>break</b>;            // escapes loop 1
    <b>end</b>
    ...
<b>end</b>
</code></pre>
<h4 id="section-85">4.9.2</h4>
<h3 id="continue">continue</h3>
<p>A <code>continue</code> restarts the innermost enclosing loop:</p>
<pre><code>Continue ::= <b>continue</b>
</code></pre>
<p>Example:</p>
<pre><code><b>loop do</b>                   // loop 1
    ...
    <b>loop do</b>               // loop 2
        <b>if</b> &lt;cond-1&gt; <b>then</b>
            <b>continue</b>;        // restarts loop 2
        <b>end</b>
        ...
    <b>end</b>
    ...
    <b>if</b> &lt;cond-2&gt; <b>then</b>
        <b>break</b>;            // restarts loop 1
    <b>end</b>
    ...
<b>end</b>
</code></pre>
<p>A <code>continue</code> can only be used inside an <a href="#conditional"><code>if-then-else</code></a> with an empty <code>else</code> branch and exactly one level deeper than the enclosing <code>loop</code>:</p>
<pre><code><b>loop do</b>
    <b>par do</b>    // makes the "continue" illegal
        <b>if</b> &lt;cond&gt; <b>then</b>
            <b>continue</b>;
        <b>else</b>  // makes the "continue" illegal
            ...
        <b>end</b>
    <b>with</b>
        ...
    <b>end</b>
<b>end</b>
</code></pre>
<h4 id="section-86">4.9.3</h4>
<h3 id="iterators">Iterators</h3>
<p>A <code>loop</code> may specify an iterator that yields a new value on each loop iteration.</p>
<h5 id="section-87">4.9.3.1</h5>
<h4 id="incremental-index">Incremental index</h4>
<p>For iterators in which <code>Exp</code> is empty or is of type <code>int</code>, <code>ID_var</code> is incremented after each loop iteration. <code>ID_var</code> is automatically declared read-only, with visibility restricted to the loop body, and is initialized to zero. The optional <code>Exp</code> limits the number of iterations, and is evaluated once before the loop starts.</p>
<p>Example:</p>
<pre><code><b>loop</b> i <b>in</b> 10 <b>do</b>
    _printf("i = %d\n", i);     // prints "i = 0" up to "i = 9"
<b>end</b>
</code></pre>
<h5 id="section-88">4.9.3.2</h5>
<h4 id="pool-instances">Pool instances</h4>
<p>For iterators in which <code>Exp</code> evaluates to a pool of organisms, <code>ID_var</code> evaluates to pointers to instances in the pool, one at a time, from the oldest to the newest created. <code>ID_var</code> is automatically declared read-only, with visibility restricted to the loop body.</p>
<p><code>TODO (example)</code></p>
<h4 id="section-89">4.9.4</h4>
<h3 id="every">every</h3>
<p>The <code>every</code> statement continuously awaits an event and executes its body:</p>
<pre><code>Every ::= <b>every</b> (Var | `(´VarList`)´) <b>in</b> (WCLOCKK|WCLOCKE|ID_ext|Exp) <b>do</b>
              Block
          <b>end</b>
</code></pre>
<p>An <code>every</code> expands to a <code>loop</code> as illustrated below:</p>
<table width="100%">
<tr valign="top">
<td>
<pre><code><b>every</b> &lt;attr&gt; <b>in</b> &lt;event&gt; <b>do</b>
    &lt;block&gt;
<b>end</b>
</code></pre>
</td>
<td>
<pre><code><b>loop do</b>
    &lt;attr&gt; = <b>await</b> &lt;event&gt;
    &lt;block&gt;
<b>end</b>
</code></pre>
</td>
</tr>
</table>
<p>The body of an <code>every</code> cannot contain an <code>await</code>, ensuring that no occurrences of <code>&lt;event&gt;</code> are ever missed.</p>
<p><code>TODO (restrictions, escape/break)</code></p>
<p><code>TODO (exception to the rule for internal events)</code></p>
<h4 id="section-90">4.9.5</h4>
<h3 id="traverse">Traverse</h3>
<p><code>TODO</code></p>
<pre><code>TraverseLoop ::= <b>traverse</b> ID_var <b>in</b> (`[´ Exp `]´ | Exp)
                    [ <b>with</b> Dcls <b>end</b> ]
                 <b>do</b>
                     Block
                 <b>end</b>
TraverseRec  ::= <b>traverse</b>['/' NUM] Exp
                     [ <b>with</b> Block <b>end</b> ]
</code></pre>
<h3 id="section-91">4.10</h3>
<h2 id="finalization">Finalization</h2>
<p>The <code>finalize</code> statement postpones the execution of its body to happen when its associated block goes out of scope:</p>
<pre><code>Finalize ::= <b>finalize</b>
                 [Exp `=´ Assignment]
             <b>with</b>
                 Block
             <b>end</b>
</code></pre>
<p>The presence of the optional attribution clause determines which block to associate with the <code>finalize</code>:</p>
<ol style="list-style-type: decimal">
<li>The enclosing block, if the attribution is absent.</li>
<li>The block of the variable being assigned, if the attribution is present.</li>
</ol>
<p>Example:</p>
<pre><code>
<b>input int</b> A;
<b>par/or do</b>
    <b>var</b> _FILE* f;
    <b>finalize</b>
        f = _fopen("/tmp/test.txt");
    <b>with</b>
        _fclose(f);
    <b>end</b>
    <b>every</b> v <b>in</b> A <b>do</b>
        fwrite(&v, ..., f);
    <b>end</b>
<b>with</b>
    <b>await</b> 1s;
<b>end</b>
</code></pre>
<p>The program opens <code>f</code> and writes to it on every occurrence of <code>A</code>. The writing trail is aborted after one second, but the <code>finalize</code> safely closes the file, because it is associated to the block that declares <code>f</code>.</p>
<p>The <a href="#static-analysis">static analysis</a> of Céu enforces the use of <code>finalize</code> for unsafe attributions.</p>
<h3 id="section-92">4.11</h3>
<h2 id="parallel-compositions">Parallel compositions</h2>
<p>The parallel statements <code>par/and</code>, <code>par/or</code>, and <code>par</code> split the running trail in multiple others:</p>
<pre><code>Pars ::= (<b>par/and</b>|<b>par/or</b>|<b>par</b>) <b>do</b>
               Block
          <b>with</b>
               Block
          { <b>with</b>
               Block }
           <b>end</b>
</code></pre>
<p>They differ only on how trails terminate (rejoin).</p>
<p>See <a href="#synchronous-execution-model">Synchronous execution model</a> for a detailed description of parallel execution.</p>
<h4 id="section-93">4.11.1</h4>
<h3 id="parand">par/and</h3>
<p>The <code>par/and</code> statement stands for <em>parallel-and</em> and rejoins when all trails terminate:</p>
<h4 id="section-94">4.11.2</h4>
<h3 id="paror">par/or</h3>
<p>The <code>par/or</code> statement stands for <em>parallel-or</em> and rejoins when any of the trails terminate:</p>
<h4 id="section-95">4.11.3</h4>
<h3 id="par">par</h3>
<p>The <code>par</code> statement never rejoins and should be used when the trails in parallel are supposed to run forever:</p>
<!--[TODO: static analysis or halt]-->
<h4 id="section-96">4.11.4</h4>
<h3 id="watching">watching</h3>
<p>The <code>watching</code> statement aborts its body when its associated event occurs:</p>
<pre><code> Watching ::= <b>watching</b> [ (Var | `(´VarList`)´) <b>in</b> ] (WCLOCKK|WCLOCKE|ID_ext|Exp)
                 Block
             <b>end</b>
</code></pre>
<p>A <code>watching</code> expands to a <code>par/or</code> as illustrated below:</p>
<table width="100%">
<tr valign="top">
<td>
<pre><code><b>watching</b> &lt;...&gt; in &lt;event&gt; <b>do</b>
    &lt;block&gt;
<b>end</b>
</code></pre>
</td>
<td>
<pre><code><b>par/or do</b>
    &lt;...&gt; <b>await</b> &lt;event&gt;
<b>with</b>
    &lt;block&gt;
<b>end</b>
</code></pre>
</td>
</tr>
</table>
<p><code>TODO (Var/VarList is implicitly declared)</code></p>
<p><code>TODO: strong abortion</code></p>
<p><code>TODO: see Await for supported events</code></p>
<h3 id="section-97">4.12</h3>
<h2 id="pauseif">pause/if</h2>
<p><code>TODO</code></p>
<pre><code>Pause ::= <b>pause/if</b> Exp <b>do</b>
              Block
          <b>end</b>
</code></pre>
<h3 id="section-98">4.13</h3>
<h2 id="asynchronous-execution">Asynchronous execution</h2>
<p>Asynchronous execution permit that programs execute time consuming computations without interfering with the <em>synchronous side</em> of applications (i.e., everything, except asynchronous statements).</p>
<pre><code>Async ::= (<b>async</b> | <b>async/thread</b>) [ `(´VarList`)´ ] <b>do</b>
              Block
          <b>end</b>
</code></pre>
<h4 id="section-99">4.13.1</h4>
<h3 id="asynchronous-blocks">Asynchronous blocks</h3>
<p>Asynchronous blocks (<code>async</code>) are the simplest alternative for asynchronous execution.</p>
<p>An <code>async</code> body can contain non-awaiting loops (<em>tight loops</em>), which are <a href="#bounded">disallowed</a> on the synchronous side to ensure that programs remain reactive.</p>
<p>The optional list of variables copies values between the synchronous and asynchronous scopes. With the prefix <code>&amp;</code>, the variable is passed by reference and can be altered from inside the <code>async</code>.</p>
<p>The next example uses an <code>async</code> to execute a time-consuming computation, keeping the synchronous side reactive. In a parallel trail, the program awaits one second to kill the computation if it takes too long:</p>
<pre><code><b>var int</b> fat;
<b>par/or do</b>
    <b>var int</b> v = ...

    // calculates the factorial of v
    fat = <b>async</b> (v) <b>do</b>
        <b>var int</b> fat = 1;
        <b>loop</b> i <b>in</b> v <b>do</b>   // a tight loop
            // v varies from 0 to (v-1)
            fat = fat * (i+1);
        <b>end</b>
        <b>return</b> fat;
    <b>end</b>;
<b>with</b>
    <b>await</b> 1s;          // watchdog to kill the async if it takes too long
    fat = 0;
<b>end</b>
<b>return</b> fat;
</code></pre>
<p>An <code>async</code> has the following restrictions:</p>
<ol style="list-style-type: decimal">
<li>Only executes if there are no pending input events.</li>
<li>Yields control on every <code>loop</code> iteration on its body.</li>
<li>Cannot use parallel compositions.</li>
<li>Cannot nest other asyncs.</li>
<li>Cannot <code>await</code> events.</li>
<li>Cannot <code>emit</code> internal events.</li>
</ol>
<!--
A lower priority for `async` is fundamental to ensure that input events are 
handled as fast as possible.
-->
<h5 id="section-100">4.13.1.1</h5>
<h4 id="simulation">Simulation</h4>
<p>An <code>async</code> is allowed to trigger <a href="#emit-event">input events</a> and the <a href="#emit-time">passage of time</a>, providing a way to test programs in the language itself:</p>
<pre><code><b>input int</b> A;

// tests a program with a simulation in parallel
<b>par do</b>

    // original program
    <b>var int</b> v = <b>await</b> A;
    <b>loop</b> i <b>do</b>
        <b>await</b> 10ms;
        _printf("v = %d\n", v+i);
    <b>end</b>

<b>with</b>

    // input simulation
    <b>async do</b>
        <b>emit</b> A=>0;      // initial value for "v"
        <b>emit</b> 1s35ms;    // the loop executes 103 times
    <b>end</b>
    <b>return</b> 0;
<b>end</b>
</code></pre>
<p>Every time the <code>async</code> emits an event, it suspends (due to rule <code>1</code> of previous section). The example prints the <code>v = &lt;v+i&gt;</code> message exactly 103 times.</p>
<h4 id="section-101">4.13.2</h4>
<h3 id="threads">Threads</h3>
<p><code>TODO(async/thread)</code></p>
<h5 id="section-102">4.13.2.1</h5>
<h4 id="synchronous-blocks">Synchronous blocks</h4>
<p><code>TODO</code></p>
<pre><code>Sync ::= <b>sync do</b>
             Block
         <b>end</b>
</code></pre>
<h5 id="section-103">4.13.2.2</h5>
<h4 id="atomic-blocks">Atomic blocks</h4>
<p><code>TODO(mutual exclusion isr and sync)</code></p>
<pre><code>Atomic ::= <b>atomic do</b>
             Block
         <b>end</b>
</code></pre>
<h3 id="section-104">4.14</h3>
<h2 id="c-statements">C statements</h2>
<p><code>TODO</code></p>
<pre><code>C ::= `{´ &lt;C code&gt; `}´
</code></pre>
<h3 id="section-105">4.15</h3>
<h2 id="lua-statements">Lua statements</h2>
<p><code>TODO</code></p>
<pre><code>Lua ::= `[´ {`=´} `[´
                       { <i>&lt;lua code&gt;</i> | `@´ Exp }
                   `]´ {`=´} `]´
</code></pre>
<hr />
<h2 id="section-106">5</h2>
<h1 id="expressions">Expressions</h1>
<p>The syntax for expressions in Céu is as follows:</p>
<pre><code>Exp ::= Prim
        |  Exp <b>or</b> Exp
        |  Exp <b>and</b> Exp
        |  Exp (`!=´|`==´|`&lt;=´|`&lt;´|`&gt;´|`&gt;=´) Exp
        |  Exp `|´ Exp
        |  Exp `^´ Exp
        |  Exp `&´ Exp
        |  Exp (`&lt;&lt;´|`&gt;&gt;´) Exp
        |  Exp (`+´|`-´) Exp
        |  Exp (`*´|`/´|`%´) Exp
        |  (<b>not</b>|`+´|`-´|`~´|`*´|`&&´|`&´|`$$´|`$´) Exp
        |  `(´ Type `)´ Exp     /* same precedence as previous */
        |  Exp `[´ Exp `]´      /* same precedence for all following */
        |  Exp (`.´|`:´) (ID_field | ID_tag)
        |  Exp (`?´|`!´)
        |  Exp `(´ [ExpList] `)´ [<b>finalize with</b> Block <b>end</b>]

Prim ::= `(´ Exp `)´
        |  <b>sizeof</b> `(´ (Type|Exp) `)´
        |  ID_var | ID_nat
        |  <b>null</b> | NUM | String
        |  <b>true</b> | <b>false</b>
        |  <b>global</b> | <b>this</b> | <b>outer</b>
        |  (<b>call</b> | <b>call/rec</b>) Exp
        |  &lt;c-stat&gt
</code></pre>
<p><em>Note: assignments are not expressions in Céu.</em></p>
<h3 id="section-107">5.1</h3>
<h2 id="primary">Primary</h2>
<p><code>TODO: global, this, outer, ID_var, ID_nat, null, NUM, String, true, false,  call/call/rec/finalize, C, parens</code></p>
<h3 id="section-108">5.2</h3>
<h2 id="arithmetic">Arithmetic</h2>
<p>The arithmetic operators of Céu are</p>
<pre><code>    +      -      %      *      /      +      -</code></pre>
<p>which correspond to <em>addition</em>, <em>subtraction</em>, <em>modulo (remainder)</em>, <em>multiplication</em>, <em>division</em>, <em>unary-plus</em>, and <em>unary-minus</em>. <!-- *Note: Céu has no support for pointer arithmetic.* --></p>
<h3 id="section-109">5.3</h3>
<h2 id="relational">Relational</h2>
<p>The relational operators of Céu are</p>
<pre><code>    ==      !=      &gt;      &lt;      &gt;=      &lt;=</code></pre>
<p>which correspond to <em>equal-to</em>, <em>not-equal-to</em>, <em>greater-than</em>, <em>less-than</em>, <em>greater-than-or-equal-to</em>, and <em>less-than-or-equal-to</em>.</p>
<p>Relational expressions evaluate to 1 (<em>true</em>) or 0 (<em>false</em>).</p>
<h3 id="section-110">5.4</h3>
<h2 id="logical">Logical</h2>
<p>The logical operators of Céu are</p>
<pre><code>    <b>not      and      or</b>
</code></pre>
<!--
which correspond to *not*, *and*, *or*.
-->
<h3 id="section-111">5.5</h3>
<h2 id="bitwise">Bitwise</h2>
<p>The bitwise operators of Céu are</p>
<pre><code>    ~      &amp;      |      ^      &lt;&lt;      &gt;&gt;</code></pre>
<p>which correspond to <em>not</em>, <em>and</em>, <em>or</em>, <em>xor</em>, <em>left-shift</em>, and <em>right-shift</em>.</p>
<h3 id="section-112">5.6</h3>
<h2 id="vector-indexing">Vector indexing</h2>
<p>Céu uses square brackets to index <a href="#Vectors">vectors</a>:</p>
<pre><code>Index ::= Exp `[´ Exp `]´</code></pre>
<p>The expression on the left side is expected to evaluate to a vector.</p>
<p>Vector indexes start at zero. <!-- TODO: limites e recolocar "pointer arith" --></p>
<h3 id="section-113">5.7</h3>
<h2 id="references-1">References</h2>
<p><code>TODO</code></p>
<h4 id="section-114">5.7.1</h4>
<h3 id="aliasing">Aliasing</h3>
<p><code>TODO</code></p>
<pre><code>Alias ::= `&amp;´ Exp</code></pre>
<p>The operand to <code>&amp;amp;</code> must be an [[#sec.exps.assignable|assignable expression]].</p>
<h3 id="section-115">5.8</h3>
<h2 id="pointer-referencing-and-dereferencing">### Pointer referencing and dereferencing</h2>
<p><code>TODO</code></p>
<p>The operator <code>&amp;amp;&amp;amp;</code> returns the address of its operand, while the operator <code>*</code> dereferences its pointer operand.</p>
<pre><code>Address ::= `&amp;&amp;´ Exp
Deref   ::= `*´ Exp</code></pre>
<p>The operand to <code>&amp;amp;&amp;amp;</code> must be an [[#sec.exps.assignable|assignable expression]].</p>
<h3 id="section-116">5.9</h3>
<h2 id="fields">Fields</h2>
<p><code>TODO (tags,fields)</code></p>
<h4 id="section-117">5.9.1</h4>
<h3 id="structs">Structs</h3>
<p>The operators <code>.´ and</code>:´ access the fields of structs.</p>
<pre><code>Dot   ::= Exp `.´ Exp
Colon ::= Exp `:´ Exp</code></pre>
<p>The operator <code>.</code> expects a <code>struct</code> as its left operand, while the operator <code>:</code> expects a reference to a <code>struct</code>.</p>
<p>Example:</p>
<pre><code><b>native do</b>
    typedef struct {
        int v;
    } mystruct;
end
<b>var</b> _mystruct s;
<b>var</b> _mystruct* p = &s;
s.v = 1;
p:v = 0;
</code></pre>
<p><em>Note: <code>struct</code> must be declared in C, as Céu currently has no support for it.</em></p>
<h4 id="section-118">5.9.2</h4>
<h3 id="organisms-1">Organisms</h3>
<p><code>TODO</code></p>
<p><code>TODO (index clash)</code></p>
<h3 id="section-119">5.10</h3>
<h2 id="option-1">Option</h2>
<p><code>TODO (?!)</code></p>
<h3 id="section-120">5.11</h3>
<h2 id="type-casting">Type casting</h2>
<p>Céu uses parenthesis for type casting:</p>
<pre><code>Cast ::= `(´ ID_type `)´
</code></pre>
<h3 id="section-121">5.12</h3>
<h2 id="sizeof">Sizeof</h2>
<p>A <code>sizeof</code> expression returns the size of a type or expression, in bytes:</p>
<pre><code>Sizeof ::= <b>sizeof</b> `(´ (Type|Exp) `)´
</code></pre>
<!--
The expression is evaluated at compile time.
-->
<h3 id="section-122">5.13</h3>
<h2 id="precedence">Precedence</h2>
<p>Céu follows the same precedence of C operators:</p>
<pre><code>    /* lowest priority */

    <b>or</b>

    <b>and</b>

    !=    ==    &lt;=    &gt;=    &lt;     &gt;

    |

    ^

    &

    &gt;&gt;    &lt;&lt;

    +     -

    *     /     %

    <b>not</b>    +    -    ~    *    &&    &    $$    $    (Type)

    ()    []    :    .    ?    !

    /* highest priority */
</code></pre>
<h3 id="section-123">5.14</h3>
<h2 id="assignable-expressions">Assignable expressions</h2>
<p>An assignable expression (also known as an <em>l-value</em>) can be a variable, vector index, pointer dereference, or struct access. L-values are required in [[#sec.stmts.assignments|assignments]] and [[#sec.exps.pointers|references]].</p>
<p>Examples:</p>
<pre><code><b>var int</b> a;
a = 1;

<b>var int</b>[2] v;
v[0] = 1;

<b>var int</b>&& p;
*p = 1;

<b>var</b> _mystruct s;
s.v = 1;

<b>var</b> _mystruct&& ps;
ps:v = 1;
</code></pre>
<hr />
<h2 id="section-124">6</h2>
<h1 id="static-analysis">Static analysis</h1>
<p><code>TODO (introduction)</code></p>
<h3 id="section-125">6.1</h3>
<h2 id="types-1">Types</h2>
<p><code>TODO (weakly typed, like C)</code></p>
<p><code>TODO (index clash)</code></p>
<h3 id="section-126">6.2</h3>
<h2 id="loops">Loops</h2>
<p><code>TODO</code></p>
<h3 id="section-127">6.3</h3>
<h2 id="finalization-1">Finalization</h2>
<p><code>TODO</code></p>
<p><code>TODO (index clash)</code></p>
<h3 id="section-128">6.4</h3>
<h2 id="organisms-references">Organisms references</h2>
<p><code>TODO</code></p>
<hr />
<h2 id="section-129">7</h2>
<h1 id="environment">Environment</h1>
<p>As a reactive language, Céu depends on an external environment (the host platform) to provide input and output events to programs. The environment is responsible for sensing the world and notifying Céu about changes. The actual events vary from environment to environment, as well as the implementation for the notification mechanism (e.g. <em>polling</em> or <em>interrupt-driven</em>).</p>
<h3 id="section-130">7.1</h3>
<h2 id="the-c-api">The C API</h2>
<p>The final output of the compiler of Céu is a program in C that follows a standard application programming interface. The interface specifies some types, macros, and functions, which the environment has to manipulate in order to guide the execution of the original program in Céu.</p>
<p>The example below illustrates a possible <code>main</code> for a host platform:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&quot;_ceu_app.c&quot;</span>

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">char</span> mem[<span class="kw">sizeof</span>(CEU_Main)];
    tceu_app app;
        app.data = &amp;mem;
    ceu_app_init(&amp;app);

    <span class="cf">while</span>(app-&gt;isAlive) {
        ceu_sys_go(app, CEU_IN__ASYNC,  CEU_EVTP((<span class="dt">void</span>*)NULL));
        ceu_sys_go(app, CEU_IN__WCLOCK, CEU_EVTP(&lt;how-much-time-since-previous-iteration&gt;));
        <span class="cf">if</span> (occuring(CEU_IN_EVT1)) {
            ceu_sys_go(app, CEU_IN__EVT1, param1);
        }
        ...
        <span class="cf">if</span> (occuring(CEU_IN_EVTn)) {
            ceu_sys_go(app, CEU_IN__EVTn, paramN);
        }
    }
    <span class="cf">return</span> app-&gt;ret;
}

<span class="dt">int</span> occurring (<span class="dt">int</span> evt_id) {
    &lt;platform dependent&gt;
}</code></pre></div>
<p><code>tceu_app</code> is a type that represents an application in Céu. The field <code>app.data</code> expects a pointer to the memory of the application, which has to be previously declared.</p>
<p><code>TODO</code></p>
<h4 id="section-131">7.1.1</h4>
<h3 id="types-2">Types</h3>
<p><code>TODO</code></p>
<p><code>TODO (index clash)</code></p>
<h4 id="section-132">7.1.2</h4>
<h3 id="functions-1">Functions</h3>
<p><code>TODO</code></p>
<p><code>TODO (index clash)</code></p>
<h4 id="section-133">7.1.3</h4>
<h3 id="macros">Macros</h3>
<p><code>TODO</code></p>
<h4 id="section-134">7.1.4</h4>
<h3 id="constants-and-defines">Constants and Defines</h3>
<p><code>TODO</code></p>
<!--

The following functions should be called by the environment to command the execution of Céu programs:

* <tt>int ceu_go_init (int* ret)</tt>
: Initializes and starts the program.
: Should be called by the environment once, to start the Céu program.
: If the program terminates, the function returns <tt>1</tt> and sets <tt>ret</tt> to the return value of the program.
: Otherwise, the function returns <tt>0</tt>.
:
* <tt>int ceu_go_event (int* ret, int id, void* data)</tt>
: Signals the occurrence of the given event to the Céu runtime.
: The function receives the identifier of the input event (see [[#sec.env.api.constants|constants]]) and a pointer to its data.
: The program resumes on the trails awaiting the event, whose awaiting expressions return the received <tt>data</tt>.
: The return procedure of the function behaves as <tt>ceu_go_init</tt>.
:
* <tt>int ceu_go_async (int* ret, int* count)</tt>
: Executes a suspended asynchronous block for a time slice.
: The time slice is not specified, however the execution is interrupted when <tt>ceu_out_pending</tt> is true (see [[#sec.env.api.macros|macros]]).
: The return procedure of the function behaves as <tt>ceu_go_init</tt>, but also sets <tt>count</tt> to the number of suspended asynchronous blocks.
:
* <tt>int ceu_go_wclock (int* ret, s32 dt)</tt>
: Notifies the Céu runtime about the elapsed wall-clock time.
: The function receives the elapsed time in microseconds as <tt>dt</tt>.
: The program resumes on the trails whose wall-clock awaits have expired.
: The return procedure of the function behaves as <tt>ceu_go_init</tt>.
:

Other functions:

* <tt>int ceu_go_all ()</tt>
: Combines <tt>ceu_go_init</tt> with an infinite loop that continuously calls <tt>ceu_go_async</tt>.
: Expects that all events are generated from asynchronous blocks (see [[#sec.stmts.asyncs.simulation|simulation]]).

<span id="sec.env.api.macros"></span>

--### Macros

The following macros can be optionally defined by the environment to customize the behavior of the Céu runtime:

* <tt>ceu_out_pending()</tt>
: Probes the environment for the existence of pending input events.
: The expected return value is 1 (true) or 0 (false).
: This macro is called from the Céu runtime to interrupt the execution of asynchronous blocks when the environment has a pending input event.
: By default <tt>ceu_out_pending()</tt> translates to <tt>(1)</tt>, meaning that asynchronous blocks execute the least possible time slice before giving control back to the environment.
:
* <tt>ceu_out_wclock(us)</tt>
: Notifies the environment that the next wall-clock await will expire in <tt>us</tt> microseconds.
: This macro must be defined in interrupt-based platforms to remind the environment to call <tt>ceu_go_wclock</tt>.
: The special value <tt>CEU_WCLOCK_NONE</tt> represents the absence of wall-clock awaits.
: *Note: <tt>us</tt> can be sometimes less or equal to zero.*
: By default this macro is not defined, hence, the environment should call <tt>ceu_go_wclock</tt> periodically.
:
* <tt>ceu_out_event(id, len, data)</tt>
: Executes whenever the program emits an output event.
: This macro specifies the side effect associated with output events.
: The returned integer becomes the result of the <tt>emit</tt> in the program.
: <tt>id</tt> is a number that identifies the event (see [[#sec.env.api.constants|constants]]); <tt>len</tt> is the size of the event type; <tt>data</tt> is a pointer to the value emitted.
:
* <tt>ceu_out_event_XXX(data)</tt>
: Per-event version of <tt>ceu_out_event(id,len,data)</tt>.
: <tt>XXX</tt> is the name of the event.
: If this macro is defined for a given event, only this macro is called on the occurrence of that event.
:

--### Constants & Defines

The following constants and defines are generated by the Céu compiler to be used by the environment.

* <tt>CEU_WCLOCKS</tt>, defined if the program uses wall-clock awaits.
: The environment can conditionally compile code for calling system timers and <tt>ceu_go_wclock</tt>.
:
* <tt>CEU_ASYNCS</tt>, defined if the program uses asynchronous blocks.
: The environment can conditionally compile code for calling <tt>ceu_go_async</tt>.
:
* <tt>CEU_FUNC_XXX</tt>, defined for each called C function.
: <tt>XXX</tt> is the name of the function (e.g. CEU_FUNC_printf).
:
* <tt>CEU_IN_XXX</tt>, defined for each input event.
: Every external input event has a unique identifier associated with a number.
: The identifier is the name of the event prefixed with <tt>CEU_IN_</tt> (e.g. CEU_IN_Button).
:
* <tt>CEU_OUT_XXX</tt>, defined for each input event.
: Every external output event has a unique identifier associated with a number.
: The identifier is the name of the event prefixed with <tt>CEU_OUT_</tt> (e.g. CEU_IN_Led).
:
: As an example, consider the following Céu definitions:
:
    input int A, B;
    output void C, D;
:
: The compiler may generate the following constants for them:
:
<pre><code>#define CEU_IN_A    0;
#define CEU_IN_B    5;
#define CEU_OUT_C   0;
#define CEU_OUT_D   1;
</code></pre>
:
: Two input events never have the same associated value. The same holds for output events.
: The values between input and output events are unrelated.
: Also, the values need not to be continuous.

--### Types

Céu expects the following scalar types to be defined by the environment: <tt>s32</tt>, <tt>s16</tt>, <tt>s8</tt>, <tt>u32</tt>, <tt>u16</tt>, and <tt>u8</tt>.
They correspond to signed and unsigned variations of the referred sizes in bits.

Follows an example of possible definitions for the scalar types:

<pre><code>typedef long long  s64;
typedef long       s32;
typedef short      s16;
typedef char       s8;
typedef unsigned long long u64;
typedef unsigned long      u32;
typedef unsigned short     u16;
typedef unsigned char      u8;
</code></pre>

These types are used internally by the language runtime, and can also be used by programmers in Céu programs.
For instance, Céu internally uses a <tt>u64</tt> type to represent wall-clock time.

-->
<h3 id="section-135">7.2</h3>
<h2 id="compiler">Compiler</h2>
<p>Céu provides a command line compiler that generates C code for a given input program. The compiler is independent of the target platform.</p>
<p>The generated C output should be included in the main application, and is supposed to be integrated with the specific platform through the presented [[#sec.env.api|API]].</p>
<p>The command line options for the compiler are as follows:</p>
<pre><code>./ceu &lt;filename&gt;              # Ceu input file, or `-` for stdin

    --output &lt;filename&gt;       # C output file (stdout)

    --defs-file &lt;filename&gt;    # define constants in a separate output file (no)

    --join (--no-join)        # join lines enclosed by /*{-{*/ and /*}-}*/ (join)

    --dfa (--no-dfa)          # perform DFA analysis (no-dfa)
    --dfa-viz (--no-dfa-viz)  # generate DFA graph (no-dfa-viz)

    --m4 (--no-m4)            # preprocess the input with `m4` (no-m4)
    --m4-args                 # preprocess the input with `m4` passing arguments in between `&quot;` (no)</code></pre>
<p>The values in parenthesis show the defaults for the options that are omitted.</p>
<hr />
<h2 id="section-136">8</h2>
<h1 id="errors">Errors</h1>
<h3 id="section-137">8.1</h3>
<h2 id="pointer-attributions-11xx">Pointer attributions (11xx)</h2>
<h4 id="section-138">8.1.1</h4>
<h3 id="wrong-operator">1101 : <em>wrong operator</em></h3>
<p>Use of the unsafe operator &quot;:=&quot; for non-pointer attributions.</p>
<p>Instead, use <code>=</code>.</p>
<p>Example:</p>
<pre><code><b>var int</b> v := 1;

>>> ERR [1101] : file.ceu : line 1 : wrong operator
</code></pre>
<h4 id="section-139">8.1.2</h4>
<h3 id="attribution-does-not-require-finalize">1102 : <em>attribution does not require &quot;finalize&quot;</em></h3>
<p>Use of <code>finalize</code> for non-pointer attributions.</p>
<p>Instead, do not use <code>finalize</code>.</p>
<p>Example:</p>
<pre><code><b>var int</b> v;
<b>finalize</b>
    v = 1;
<b>with</b>
    <...>
<b>end</b>

>>> ERR [1102] : file.lua : line 3 : attribution does not require "finalize"
</code></pre>
<h4 id="section-140">8.1.3</h4>
<h3 id="wrong-operator-1">1103 : <em>wrong operator</em></h3>
<p>Use of the unsafe operator <code>:=</code> for constant pointer attributions.</p>
<p>Instead, use <code>=</code>.</p>
<p>Example:</p>
<pre><code><b>var int</b> ptr := null;

>>> ERR [1103] : file.ceu : line 1 : wrong operator
</code></pre>
<h4 id="section-141">8.1.4</h4>
<h3 id="attribution-does-not-require-finalize-1">1104 : <em>attribution does not require &quot;finalize&quot;</em></h3>
<p>Use of <code>finalize</code> for constant pointer attributions.</p>
<p>Instead, do not use <code>finalize</code>.</p>
<p>Example:</p>
<pre><code><b>var int</b> ptr;
<b>finalize</b>
    ptr = null;
<b>with</b>
    <...>
<b>end</b>

>>> ERR [1104] : file.lua : line 3 : attribution does not require `finalize´
</code></pre>
<h4 id="section-142">8.1.5</h4>
<h3 id="destination-pointer-must-be-declared-with-the-buffer-modifier">1105 : <em>destination pointer must be declared with the &quot;[]&quot; buffer modifier</em></h3>
<p>Use of normal pointer <code>*</code> to hold pointer to acquired resource.</p>
<p>Instead, use <code>[]</code>.</p>
<p>Example:</p>
<pre><code><b>var int</b>* ptr = _malloc();

>>> ERR [1105] : file.ceu : line 1 : destination pointer must be declared with the `[]´ buffer modifier
</code></pre>
<h4 id="section-143">8.1.6</h4>
<h3 id="parameter-must-be-hold">1106 : <em>parameter must be &quot;hold&quot;</em></h3>
<p>Omit <code>@hold</code> annotation for function parameter held in the class or global.</p>
<p>Instead, annotate the parameter declaration with <code>@hold</code>.</p>
<p>Examples:</p>
<pre><code><b>class</b> T <b>with</b>
    <b>var void</b>* ptr;
    <b>function</b> (<b>void</b>* v)=><b>void</b> f;
<b>do</b>
    <b>function</b> (<b>void</b>* v)=><b>void</b> f <b>do</b>
        ptr := v;
    <b>end</b>
<b>end</b>

>>> ERR [1106] : file.ceu : line 6 : parameter must be `hold´

/*****************************************************************************/

<b>native do</b>
    <b>void</b>* V;
<b>end</b>
<b>function</b> (<b>void</b>* v)=><b>void</b> f <b>do</b>
    _V := v;
<b>end</b>

>>> ERR [1106] : file.ceu : line 5 : parameter must be `hold´
</code></pre>
<h4 id="section-144">8.1.7</h4>
<h3 id="pointer-access-across-await">1107 : <em>pointer access across &quot;await&quot;</em></h3>
<p>Access to pointer across an <code>await</code> statement. The pointed data may go out of scope between reactions to events.</p>
<p>Instead, don't do it. :)</p>
<p>(Or check if the pointer is better represented as a buffer pointer (<code>[]</code>).)</p>
<p>Examples:</p>
<pre><code><b>event int</b>* e;
<b>var int</b>* ptr = <b>await</b> e;
<b>await</b> e;     // while here, what "ptr" points may go out of scope
<b>escape</b> *ptr;

>>> ERR [1107] : file.ceu : line 4 : pointer access across `await´

/*****************************************************************************/

<b>var int</b>* ptr = <...>;
<b>par/and do</b>
    <b>await</b> 1s;   // while here, what "ptr" points may go out of scope
<b>with</b>
    <b>event int</b>* e;
    ptr = <b>await</b> e;
<b>end</b>
<b>escape</b> *ptr;

>>> ERR [1107] : file.ceu : line 8 : pointer access across `await´
</code></pre>
<h4 id="section-145">8.1.8</h4>
<h3 id="finalize-inside-constructor">1108 : <em>&quot;finalize&quot; inside constructor</em></h3>
<p>Use of <code>finalize</code> inside constructor.</p>
<p>Instead, move it to before the constructor or to inside the class.</p>
<p>Examples:</p>
<pre><code><b>class</b> T <b>with</b>
    <b>var void</b>* ptr;
<b>do</b>
    <...>
<b>end</b>

<b>var</b> T t <b>with</b>
    <b>finalize</b>
        this.ptr = _malloc(10);
    <b>with</b>
        _free(this.ptr);
    <b>end</b>
<b>end</b>;

>>> ERR [1008] : file.ceu : line 7 : `finalize´ inside constructor

/*****************************************************************************/

<b>class</b> T <b>with</b>
    <b>var void</b>* ptr;
<b>do</b>
    <...>
<b>end</b>

<b>spawn</b> T <b>with</b>
    <b>finalize</b>
        this.ptr = _malloc(10);
    <b>with</b>
        _free(this.ptr);
    <b>end</b>
<b>end</b>;

>>> ERR [1008] : file.ceu : line 7 : `finalize´ inside constructor
</code></pre>
<h4 id="section-146">8.1.9</h4>
<h3 id="call-requires-finalize">1109 : <em>call requires &quot;finalize&quot;</em></h3>
<p>Call missing <code>finalize</code> clause.</p>
<p>Call passes a pointer. Function may hold the pointer indefinitely. Pointed data goes out of scope and yields a dangling pointer.</p>
<p>Instead, <code>finalize</code> the call.</p>
<p>Example:</p>
<pre><code><b>var char</b>[255] buf;
_enqueue(buf);

>>> ERR [1009] : file.ceu : line 2 : call requires `finalize´'
</code></pre>
<h4 id="section-147">8.1.10</h4>
<h3 id="invalid-finalize">1110 : <em>invalid &quot;finalize&quot;</em></h3>
<p>Call a function that does not require a <code>finalize</code>.</p>
<p>Instead, don't use it.</p>
<p>Example:</p>
<pre><code>_f() <b>finalize with</b>
        <...>
     <b>end</b>;

>>> ERR [1010] : file.ceu : line 1 : invalid `finalize´
</code></pre>
<hr />
<h2 id="section-148">9</h2>
<h1 id="syntax">Syntax</h1>
<pre><code>
Stmt ::= &lt;empty-string&gt;
      |  <b>nothing</b>
      |  <b>escape</b> Exp
      |  <b>return</b> [Exp]
      |  <b>break</b>
      |  <b>continue</b>

  /* Declarations */

      /* variables, organisms, pools, and internal events */
      | <b>var</b> Type ID_var [`=´ &lt;Assignment&gt;] { `,´ ID_var [`=´ &lt;Assignment&gt;] }
      | <b>var</b> Type ID_var <b>with</b>
            Block
        <b>end</b>
      | <b>pool</b> Type ID_var [`=´ &lt;Assignment&gt;] { `,´ ID_var [`=´ &lt;Assignment&gt;] }
      | <b>event</b> (Type | `(´ TypeList `)´) ID_var { `,´ ID_var }

      /* internal functions */
      | <b>function</b> [<b>@rec</b>] `(´ParList`)´ `=>´ Type ID_var
            [ `do´ Block `end´ ]

      /* external functions */
      | <b>output</b> [<b>@rec</b>] `(´ParList`)´ `=>´ Type ID_var ID_ext { `,´ ID_ext }
      | <b>input</b>  [<b>@rec</b>] `(´ParList`)´ `=>´ Type ID_var ID_ext { `,´ ID_ext }
            [ `do´ Block `end´ ]

      /* interrupts */
      | <b>interrupt</b> `[´ NUM `]´ [<b>@rec</b>]
            [ `do´ Block `end´ ]

      /* external events */
      | <b>output</b> (Type | `(´ TypeList `)´) ID_ext { `,´ ID_ext }
      | <b>input</b>  (Type | `(´ TypeList `)´) ID_ext { `,´ ID_ext }

      /* external requests */
      | <b>output/input</b> `[´ [Exp] `]´ `(´ParList`)´ `=>´ Type ID_ext { `,´ ID_ext }
      | <b>input/output</b> `[´ [Exp] `]´ `(´ParList`)´ `=>´ Type ID_ext { `,´ ID_ext }
            [ `do´ Block `end´ ]

      /* classes & interfaces */
      | <b>class</b> ID_cls <b>with</b>
            Dcls
        <b>do</b>
            Block
        <b>end</b>
      | <b>interface</b> ID_cls <b>with</b>
            Dcls
        <b>end</b>
          <i>where</i>
              Dcls   ::= { (&lt;var&gt; | &lt;event-int&gt; | &lt;pool&gt; | &lt;function&gt; | DclImp) `;´ }
              DclImp ::= <b>interface</b> ID_cls { `,´ ID_cls }

      /* data types */
      | <b>data</b> ID_data <b>with</b>
            (Struct | Union)
        <b>end</b>
          <i>where</i>
              Struct ::= DclVar `;´ { DclVar `;´ }
              Union  ::= DclTag { <b>or</b> DclTag }
                  <i>where</i>
                      DclVar ::= <b>var</b> Type ID_var { `,´ ID_var }
                      DclTag ::= <b>tag</b> ID_tag <b>with</b>
                                     DclVar `;´ { DclVar `;´ }
                                 <b>end</b>

      /* C integration */
      | <b>native</b> [<b>@pure</b>|<b>@const</b>|<b>@nohold</b>|<b>@plain</b>] Nat_list
          <i>where</i>
              Nat_list  ::= (Nat_type|Nat_func|Nat_var) { `,` (Nat_type|Nat_func|Nat_var) }
              Nat_type  ::= ID_nat `=´ NUM
              Nat_func  ::= ID_nat `(´ `)´
              Nat_var   ::= ID_nat
      | (<b>native/pre</b> | <b>native</b>) <b>do</b>
            <i>&lt;C code definitions&gt;</i>
        <b>end</b>

      /* deterministic annotations */
      | <b>@safe</b> ID <b>with</b> ID { `,´ ID }

  /* Assignments */

      | (Exp | `(´VarList`)´) `=´
          /* <i>Assignment</i> */
          ( Exp
          | AssignableBlock
          | &lt;await&gt;
          | ( [ `(´ ] &lt;emit-ext&gt
                    | &lt;call-ext&gt;
                    | &lt;request-ext&gt;
              [ `)´ ] )
          | [ `new´ ] Data
          | &lt;traverse-loop&gt;
          | &lt;traverse-rec&gt;
          | Vector
          | &lt;lua&gt;
          | &lt;do-org&gt;
          | &lt;spawn&gt;
          | &lt;thread&gt;
          )
              <i>where</i>
                  Data ::= ID_data [`.´ ID_tag] `(´ List `)´
                  List ::= [ (Data|Exp) { `,´ (Data|Exp) } ]

                  Vector ::= Item { `..´ Item }
                  Item   ::= Exp | `[´ [ExpList] `]´

                  AssignableBlock ::= &lt;do-end&gt; | &lt;if-then-else&gt; | &lt;loop&gt; | &lt;every&gt; | &lt;par&gt;

  /* Function calls */

      /* internal calls */
      | [<b>call</b>|<b>call/rec</b>] Exp * `(´ [ExpList] `)´

      /* external calls */
      | (<b>call</b>+<b>call/rec</b>) ID_ext [ `=>´ (Exp | `(´ [ExpList] `)´)

  /* Event handling */

      /* internal/external await */
      | ( <b>await</b> ID_ext
        | <b>await</b> Exp
        | <b>await</b> (WCLOCKK|WCLOCKE)
        ) [ <b>until</b> Exp ]
      | <b>await</b> <b>FOREVER</b>

      /* internal/external emit */
      | <b>emit</b> Exp    [ `=>´ (Exp | `(´ [ExpList] `)´)
      | <b>emit</b> ID_ext [ `=>´ (Exp | `(´ [ExpList] `)´)
      | <b>emit</b> (WCLOCKK|WCLOCKE)

      /* external request */
      | <b>request</b> ID_ext [ `=>´ (Exp | `(´ [ExpList] `)´)

  /* Organism instantiation */

      /* do organism */
      | <b>do</b> ID_cls <b>with</b>
            Block
        <b>end</b>

      /* spawn */
      | <b>spawn</b> * ID_cls * [<b>in</b> Exp]
            [ <b>with</b> Block <b>end</b> ]

      /* kill */
      | <b>kill</b> * Exp * [ `=>´ Exp ]

  /* Flow control */

      /* explicit block */
      |  <b>do</b> Block <b>end</b>

      /* pre (top level) execution */
      | <b>pre do</b>
            Block
        <b>end</b>

      /* conditional */
      | <b>if</b> Exp <b>then</b>
            Block
        { <b>else/if</b> Exp <b>then</b>
            Block }
        [ <b>else</b>
            Block ]
        <b>end</b>

      /* loops */
      | <b>loop</b>[`/´ Exp] [ ID_var [<b>in</b> Exp] ] <b>do</b>
            Block
        <b>end</b>
      | <b>every</b> (Var | `(´VarList`)´) <b>in</b> (WCLOCKK|WCLOCKE|ID_ext|Exp) <b>do</b>
            Block
        <b>end</b>

      /* traverse */
      | <b>traverse</b> ID_var <b>in</b> (`[´ Exp `]´ | Exp)
            [ <b>with</b> Dcls <b>end</b> ]
            <b>do</b>
                Block
            <b>end</b>
      | <b>traverse</b>['/' NUM] Exp
            [ <b>with</b> Block <b>end</b> ]

      /* finalization */
      | <b>finalize</b> [&lt;assignment&gt;] <b>with</b>
            Block
        <b>end</b>

      /* parallel compositions */
      | (<b>par/and</b>|<b>par/or</b>|<b>par</b>) <b>do</b>
            Block
        <b>with</b>
            Block
        { <b>with</b>
            Block }
         <b>end</b>
      | <b>watching</b> [ (Var | `(´VarList`)´) <b>in</b> ] (WCLOCKK|WCLOCKE|ID_ext|Exp)
        <b>do</b>
            Block
        <b>end</b>

      /* pause */
      | <b>pause/if</b> Exp <b>do</b>
            Block
        <b>end</b>

      /* asynchronous execution */
      | (<b>async</b> | [<b>async/thread</b>]) [ `(´VarList`)´ ] <b>do</b>
            Block
        <b>end</b>

      /* synchronization */
      | <b>sync do</b>
            Block
        <b>end</b>
      | <b>atomic do</b>
            Block
        <b>end</b>

  /* C integration */

     | `{´ &lt;C code&gt; `}´

  /* Lua integration */

      | `[´ {`=´} `[´
            { <i>&lt;lua code&gt;</i> | `@´ Exp }
        `]´ {`=´} `]´

/* Block */

Block ::= { Stmt `;´ }

/* Identifiers */

ID       ::= &lt;a-z, A-Z, 0-9, _&gt; +
ID_var   ::= `_´ | ID    // beginning with a lowercase letter
ID_ext   ::= ID          // all in uppercase, not beginning with a digit
ID_cls   ::= ID          // beginning with an uppercase letter
ID_data  ::= ID          // beginning with an uppercase letter
ID_tag   ::= ID          // all in uppercase, not beginning with a digit
ID_field ::= ID          // not beginning with a digit
ID_nat   ::= ID          // beginning with an underscore
ID_type  ::= ( ID_nat | ID_cls | ID_data
             | <b>bool</b>  | <b>byte</b>  | <b>char</b>  | <b>f32</b>   | <b>f64</b>   |
             | <b>float</b> | <b>int</b>   | <b>s16</b>   | <b>s32</b>   | <b>s64</b>   |
             | <b>s8</b>    | <b>u16</b>   | <b>u32</b>   | <b>u64</b>   | <b>u8</b>    |
             | <b>uint</b>  | <b>void</b>  | <b>word</b> )

/* Types */

Type ::= ID_type ( `&&´ | `&´ | `?´ | `[´ [NUM] `]´ )

/* Lists */

TypeList ::= Type    { `,´ Type    }
ExpList  ::= Exp     { `,´ Exp     }
VarList  ::= ID_var  { `,´ ID_var  }
ParList  ::= ParItem { `,´ ParItem }
                <i>where</i>
                    ParItem ::= [<b>@hold</b>] Type [ID_var] 

/* Wall-clock values */

WCLOCKK ::= [NUM <b>h</b>] [NUM <b>min</b>] [NUM <b>s</b>] [NUM <b>ms</b>] [NUM <b>us</b>]
WCLOCKE ::= `(´ Exp `)´ (<b>h</b>|<b>min</b>|<b>s</b>|<b>ms</b>|<b>us</b>)

/* Expressions */

Exp ::= Prim
        |  (`$$´|`$´) Exp
        |  Exp (`?´|`!´)
        |  Exp `(´ [ExpList] `)´ [<b>finalize with</b> Block <b>end</b>]

Prim ::= `(´ Exp `)´
        |  ID_var | ID_nat
        |  <b>null</b> | NUM | String
        |  <b>true</b> | <b>false</b>
        |  (<b>call</b> | <b>call/rec</b>) Exp
        |  &lt;c-code&gt

/* Operator precedence */

    /* lowest priority */
    <b>or</b>
    <b>and</b>
    !=    ==    &lt;=    &gt;=    &lt;     &gt;
    |
    ^
    &
    &gt;&gt;    &lt;&lt;
    +     -
    *     /     %
    <b>not</b>    +    -    ~    *    &&    &    $$    $    (Type)
    ()    []    :    .    ?    !
    /* highest priority */

/* Other */

    // single-line comment

    /** nested
        /* multi-line */
        comments **/

    # preprocessor directive

</code></pre>
<hr />
<h2 id="section-149">10</h2>
<h1 id="license">License</h1>
<p>Céu is distributed under the MIT license reproduced below:</p>
<pre><code> Copyright (C) 2012 Francisco Sant&#39;Anna
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of
 this software and associated documentation files (the &quot;Software&quot;), to deal in
 the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do
 so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.</code></pre>
