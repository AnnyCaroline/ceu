{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nC\u00e9u provides \nStructured Synchronous Reactive Programming\n, extending classical\nstructured programming with two main functionalities:\n\n\n\n\nEvent Handling:\n\n\nAn \nawait\n statement to suspend a line of execution and wait for an input\n  event from the environment.\n\n\nAn \nemit\n statement to signal an output event back to the environment.\n\n\n\n\n\n\nConcurrency:\n\n\nA set of parallel constructs to compose concurrent lines of execution.\n\n\n\n\n\n\n\n\nThe lines of execution in C\u00e9u, known as \ntrails\n, react all together to input\nevents one after another, in discrete steps.\nAn input event is broadcast to all active trails, which share the event as\ntheir unique and global time reference.\n\n\nThe program that follows blinks a LED every second and terminates on a button\npress:\n\n\ninput  void BUTTON;\noutput bool LED;\npar/or do\n    await BUTTON;\nwith\n    loop do\n        await 1s;\n        emit LED(true);\n        await 1s;\n        emit LED(false);\n    end\nend\n\n\n\n\nThe synchronous concurrency model of C\u00e9u greatly diverges from multithreaded\nand actor-based models (e.g. \npthreads\n and \nerlang\n).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, accesses to shared variables among trails are deterministic\nand do not require synchronization primitives (i.e., \nlocks\n or\n\nqueues\n).\n\n\nC\u00e9u provides static memory management based on lexical scopes and does not\nrequire a garbage collector.\n\n\nC\u00e9u integrates safely with C, particularly when manipulating external resources\n(e.g., file handles).\nPrograms can make native calls seamlessly while avoiding common pitfalls such\nas memory leaks and dangling pointers.\n\n\nC\u00e9u is \nfree software\n.\n\n\nEnvironments\n\n\nAs a reactive language, C\u00e9u depends on an external host platform, known as an\n\nenvironment\n, which exposes \ninput\n and \noutput\n events programs can use.\n\n\nAn environment senses the world and broadcasts \ninput\n events to programs.\nIt also intercepts programs signalling \noutput\n events to actuate in the\nworld:\n\n\n\n\nAs examples of typical environments, an embedded system may provide button\ninput and LED output, and a video game engine may provide keyboard input and\nvideo output.\n\n\n\n\n\nSynchronous Execution Model\n\n\nC\u00e9u is grounded on a precise definition of \nlogical time\n (as opposed to\n\nphysical\n) as a discrete sequence of input events:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see \nBounded Execution\n).\n\n\nThe execution model for C\u00e9u programs is as follows:\n\n\n\n\nThe program initiates the \nboot reaction\n from the first line of code in a\n   single trail.\n\n\nActive trails, one after another, execute until they await or terminate.\n   This step is named a \nreaction chain\n, and always runs in bounded time.\n   New trails can be created with\n   \nparallel compositions\n.\n\n\nThe program goes idle.\n\n\nOn the occurrence of a new input event, \nall\n trails awaiting that event\n   awake.\n   It then goes to step 2.\n\n\n\n\nThe synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run \ninfinitely faster\n in comparison to the rate of input events.\nA reaction chain, aka \nexternal reaction\n, is the set of computations that\nexecute when an input event occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is arbitrary, but provides a priority scheme for trails, and also\nensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.\n\n\nThe program and diagram below illustrate the behavior of the scheduler of C\u00e9u:\n\n\n 1:  input void A, B, C;  // A, B, and C are input events\n 2:  par/and do\n 3:      // trail 1\n 4:      \n...\n            // \n...\n represents non-awaiting statements\n 5:      await A;\n 6:      \n...\n\n 7:  with\n 8:      // trail 2\n 9:      \n...\n\n10:      await B;\n11:      \n...\n\n12:  with\n13:      // trail 3\n14:      \n...\n\n15:      await A;\n16:      \n...\n\n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:          \n...\n\n21:      with\n22:          // trail 4\n23:          \n...\n\n24:      end\n25:  end\n\n\n\n\n\n\nThe program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows (\nt0\n in the diagram):\n\n\n\n\ntrail-1\n executes up to the \nawait A\n (line 5);\n\n\ntrail-2\n executes up to the \nawait B\n (line 10);\n\n\ntrail-3\n executes up to the \nawait A\n (line 15).\n\n\n\n\nAs no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event \nA\n occurs (\nt1\n in the diagram):\n\n\n\n\ntrail-1\n awakes, executes and terminates (line 6);\n\n\ntrail-2\n remains suspended, as it is not awaiting \nA\n.\n\n\ntrail-3\n executes up to \nawait B\n (line 17).\n\n\n\n\nDuring the reaction \nt1\n, new instances of events \nA\n, \nB\n, and \nC\n occur and\nare enqueued to be handled in the reactions in sequence.\nAs \nA\n happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n(\nt2\n in the diagram).\nThe next reaction dequeues the event \nB\n (\nt3\n in the diagram):\n\n\n\n\ntrail-2\n awakes, executes and terminates;\n\n\ntrail-3\n splits in two and they both terminate immediately.\n\n\n\n\nSince a \npar/and\n rejoins after all trails terminate, the program also\nterminates and does not react to the pending event \nC\n.\n\n\nNote that each step in the logical time line (\nt0\n, \nt1\n, etc.) is identified \nby the unique occurring event.\nInside a reaction, trails only react to the same shared global event (or remain \nsuspended).\n\n\n\n\n\nParallel Compositions and Abortion\n\n\nThe use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:\n\n\n\n\na \npar/and\n rejoins after all trails in parallel terminate;\n\n\na \npar/or\n rejoins after any trail in parallel terminates, aborting all\n   other trails automatically;\n\n\na \npar\n never rejoins, even if all trails terminate.\n\n\n\n\nAs mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions support \nawaiting in parallel\n, rather than\n\nexecuting in parallel\n.\n\n\n\n\n\nBounded Execution\n\n\nReaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle incoming input events.\nFor this reason, C\u00e9u requires every path inside the body of a \nloop\n statement\nto contain at least one \nawait\n or \nbreak\n statement.\nThis prevents \ntight loops\n, i.e., unbounded loops that do not await.\n\n\nIn the example below, the true branch of the \nif\n may never execute, resulting\nin a tight loop when the condition is false:\n\n\nloop do\n    if \ncond\n then\n        break;\n    end\nend\n\n\n\n\nC\u00e9u warns about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides\n\nAsynchronous Execution\n.\n\n\nDeterministic Execution\n\n\nTODO (shared memory + deterministic scheduler + optional static analysis)\n\n\nInternal Reactions\n\n\nC\u00e9u supports inter-trail communication through \nawait\n and \nemit\n statements\nfor \ninternal events\n.\nA trail can \nawait\n an internal event to suspend it.\nThen, another trail can \nemit\n and broadcast an event, awaking all trails\nawaiting that event.\n\n\nUnlike input events, multiple internal events can coexist during an external\nreaction.\nAn \nemit\n starts a new \ninternal reaction\n in the program which relies on a\nruntime stack:\n\n\n\n\nThe \nemit\n suspends the current trail and its continuation is pushed into\n    the stack (i.e., the statement in sequence with the \nemit\n).\n\n\nAll trails awaiting the emitted event awake and execute in sequence\n    (see \nrule 2\n for external reactions).\n    If an awaking trail emits another internal event, a nested internal\n    reaction starts with \nrule 1\n.\n\n\nThe top of stack is popped and the last emitting trail resumes execution\n    from its continuation.\n\n\n\n\nExample:\n\n\n1:  par/and do      // trail 1\n2:      await e;\n3:      emit f;\n4:  with            // trail 2\n5:      await f;\n6:  with            // trail 3\n8:      emit e;\n9:  end\n\n\n\n\nThe \nemit e\n in \ntrail-3\n (line 7) starts an internal reaction that awakes the \n\nawait e\n in \ntrail-1\n (line 2).\nThen, the \nemit f\n (line 3) starts another internal reaction that awakes the \n\nawait f\n in \ntrail-2\n (line 5).\n\nTrail-2\n terminates and the \nemit f\n resumes in \ntrail-1\n.\n\nTrail-1\n terminates and the \nemit e\n resumes in \ntrail-3\n.\n\nTrail-3\n terminates.\nFinally, the \npar/and\n rejoins and the program terminates.", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "C\u00e9u provides  Structured Synchronous Reactive Programming , extending classical\nstructured programming with two main functionalities:   Event Handling:  An  await  statement to suspend a line of execution and wait for an input\n  event from the environment.  An  emit  statement to signal an output event back to the environment.    Concurrency:  A set of parallel constructs to compose concurrent lines of execution.     The lines of execution in C\u00e9u, known as  trails , react all together to input\nevents one after another, in discrete steps.\nAn input event is broadcast to all active trails, which share the event as\ntheir unique and global time reference.  The program that follows blinks a LED every second and terminates on a button\npress:  input  void BUTTON;\noutput bool LED;\npar/or do\n    await BUTTON;\nwith\n    loop do\n        await 1s;\n        emit LED(true);\n        await 1s;\n        emit LED(false);\n    end\nend  The synchronous concurrency model of C\u00e9u greatly diverges from multithreaded\nand actor-based models (e.g.  pthreads  and  erlang ).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, accesses to shared variables among trails are deterministic\nand do not require synchronization primitives (i.e.,  locks  or queues ).  C\u00e9u provides static memory management based on lexical scopes and does not\nrequire a garbage collector.  C\u00e9u integrates safely with C, particularly when manipulating external resources\n(e.g., file handles).\nPrograms can make native calls seamlessly while avoiding common pitfalls such\nas memory leaks and dangling pointers.  C\u00e9u is  free software .", 
            "title": "Overview"
        }, 
        {
            "location": "/#environments", 
            "text": "As a reactive language, C\u00e9u depends on an external host platform, known as an environment , which exposes  input  and  output  events programs can use.  An environment senses the world and broadcasts  input  events to programs.\nIt also intercepts programs signalling  output  events to actuate in the\nworld:   As examples of typical environments, an embedded system may provide button\ninput and LED output, and a video game engine may provide keyboard input and\nvideo output.", 
            "title": "Environments"
        }, 
        {
            "location": "/#synchronous-execution-model", 
            "text": "C\u00e9u is grounded on a precise definition of  logical time  (as opposed to physical ) as a discrete sequence of input events:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see  Bounded Execution ).  The execution model for C\u00e9u programs is as follows:   The program initiates the  boot reaction  from the first line of code in a\n   single trail.  Active trails, one after another, execute until they await or terminate.\n   This step is named a  reaction chain , and always runs in bounded time.\n   New trails can be created with\n    parallel compositions .  The program goes idle.  On the occurrence of a new input event,  all  trails awaiting that event\n   awake.\n   It then goes to step 2.   The synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run  infinitely faster  in comparison to the rate of input events.\nA reaction chain, aka  external reaction , is the set of computations that\nexecute when an input event occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is arbitrary, but provides a priority scheme for trails, and also\nensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.  The program and diagram below illustrate the behavior of the scheduler of C\u00e9u:   1:  input void A, B, C;  // A, B, and C are input events\n 2:  par/and do\n 3:      // trail 1\n 4:       ...             //  ...  represents non-awaiting statements\n 5:      await A;\n 6:       ... \n 7:  with\n 8:      // trail 2\n 9:       ... \n10:      await B;\n11:       ... \n12:  with\n13:      // trail 3\n14:       ... \n15:      await A;\n16:       ... \n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:           ... \n21:      with\n22:          // trail 4\n23:           ... \n24:      end\n25:  end   The program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows ( t0  in the diagram):   trail-1  executes up to the  await A  (line 5);  trail-2  executes up to the  await B  (line 10);  trail-3  executes up to the  await A  (line 15).   As no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event  A  occurs ( t1  in the diagram):   trail-1  awakes, executes and terminates (line 6);  trail-2  remains suspended, as it is not awaiting  A .  trail-3  executes up to  await B  (line 17).   During the reaction  t1 , new instances of events  A ,  B , and  C  occur and\nare enqueued to be handled in the reactions in sequence.\nAs  A  happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n( t2  in the diagram).\nThe next reaction dequeues the event  B  ( t3  in the diagram):   trail-2  awakes, executes and terminates;  trail-3  splits in two and they both terminate immediately.   Since a  par/and  rejoins after all trails terminate, the program also\nterminates and does not react to the pending event  C .  Note that each step in the logical time line ( t0 ,  t1 , etc.) is identified \nby the unique occurring event.\nInside a reaction, trails only react to the same shared global event (or remain \nsuspended).", 
            "title": "Synchronous Execution Model"
        }, 
        {
            "location": "/#parallel-compositions-and-abortion", 
            "text": "The use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:   a  par/and  rejoins after all trails in parallel terminate;  a  par/or  rejoins after any trail in parallel terminates, aborting all\n   other trails automatically;  a  par  never rejoins, even if all trails terminate.   As mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions support  awaiting in parallel , rather than executing in parallel .", 
            "title": "Parallel Compositions and Abortion"
        }, 
        {
            "location": "/#bounded-execution", 
            "text": "Reaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle incoming input events.\nFor this reason, C\u00e9u requires every path inside the body of a  loop  statement\nto contain at least one  await  or  break  statement.\nThis prevents  tight loops , i.e., unbounded loops that do not await.  In the example below, the true branch of the  if  may never execute, resulting\nin a tight loop when the condition is false:  loop do\n    if  cond  then\n        break;\n    end\nend  C\u00e9u warns about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides Asynchronous Execution .", 
            "title": "Bounded Execution"
        }, 
        {
            "location": "/#deterministic-execution", 
            "text": "TODO (shared memory + deterministic scheduler + optional static analysis)", 
            "title": "Deterministic Execution"
        }, 
        {
            "location": "/#internal-reactions", 
            "text": "C\u00e9u supports inter-trail communication through  await  and  emit  statements\nfor  internal events .\nA trail can  await  an internal event to suspend it.\nThen, another trail can  emit  and broadcast an event, awaking all trails\nawaiting that event.  Unlike input events, multiple internal events can coexist during an external\nreaction.\nAn  emit  starts a new  internal reaction  in the program which relies on a\nruntime stack:   The  emit  suspends the current trail and its continuation is pushed into\n    the stack (i.e., the statement in sequence with the  emit ).  All trails awaiting the emitted event awake and execute in sequence\n    (see  rule 2  for external reactions).\n    If an awaking trail emits another internal event, a nested internal\n    reaction starts with  rule 1 .  The top of stack is popped and the last emitting trail resumes execution\n    from its continuation.   Example:  1:  par/and do      // trail 1\n2:      await e;\n3:      emit f;\n4:  with            // trail 2\n5:      await f;\n6:  with            // trail 3\n8:      emit e;\n9:  end  The  emit e  in  trail-3  (line 7) starts an internal reaction that awakes the  await e  in  trail-1  (line 2).\nThen, the  emit f  (line 3) starts another internal reaction that awakes the  await f  in  trail-2  (line 5). Trail-2  terminates and the  emit f  resumes in  trail-1 . Trail-1  terminates and the  emit e  resumes in  trail-3 . Trail-3  terminates.\nFinally, the  par/and  rejoins and the program terminates.", 
            "title": "Internal Reactions"
        }, 
        {
            "location": "/lexical_rules/", 
            "text": "Lexical Rules\n\n\n\n\n\nKeywords\n\n\nKeywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):\n\n\n    and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    lock            loop            lua             native          new\n\n    nohold          not             nothing         nil             null\n\n    or              outer           output          par             pause\n\n    plain           pool            pos             pre             pure\n\n    recursive       request         resume          sizeof          spawn\n\n    static          then            thread          tight           traverse\n\n    true            until           val             var             vector\n\n    watching        with            bool            byte            f32\n\n    f64             float           int             s16             s32\n\n    s64             s8              ssize           u16             u32\n\n    u64             u8              uint            usize           void\n\n\n\n\nIdentifiers\n\n\nC\u00e9u uses identifiers to refer to \ntypes\n (\nID_type\n), \nvariables\n (\nID_int\n),\n\nvectors\n (\nID_int\n), \npools\n (\nID_int\n), \ninternal events\n (\nID_int\n),\n\nexternal events\n (\nID_ext\n), \ncode abstractions\n (\nID_abs\n),\n\ndata abstractions\n (\nID_abs\n), \nfields\n (\nID_field\n),\n\nnative symbols\n (\nID_nat\n), and \nblock labels\n (\nID_int\n).\n\n\nID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\n\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n\n\n\nDeclarations for \ncode\n and \ndata\n create new\n\ntypes\n which can be used as type identifiers.\n\n\nExamples:\n\n\nvar int a;                    // \na\n is a variable, \nint\n is a type\nemit e;                       // \ne\n is an internal event\nawait E;                      // \nE\n is an external input event\nspawn Move();                 // \nMove\n is a code abstraction and a type\nvar Rect r;                   // \nRect\n is a data abstraction and a type\nreturn r.width;               // \nwidth\n is a field\n_printf(\nhello world!\\n\n);    // \n_printf\n is a native symbol\n\n\n\n\nLiterals\n\n\nC\u00e9u supports literals for \nbooleans\n, \nintegers\n, \nfloats\n, \nstrings\n, and\n\nnull pointers\n.\n\n\n\n\n\nBooleans\n\n\nThe boolean type has only two possible values: \ntrue\n and \nfalse\n.\n\n\nIntegers\n\n\nC\u00e9u supports decimal and hexadecimal integers:\n\n\n\n\nDecimals: a sequence of digits (i.e., \n[0-9]+\n).\n\n\nHexadecimals: a sequence of hexadecimal digits (i.e., \n[0-9, a-f, A-F]+\n)\n                prefixed by \n0x\n.\n\n\n\n\n\n\n\nExamples:\n\n\n// both are equal to the decimal 127\nv = 127;    // decimal\nv = 0x7F;   // hexadecimal\n\n\n\n\nFloats\n\n\nTODO (like C)\n\n\nStrings\n\n\nA sequence of characters surrounded by \n\"\n is converted into a \nnull-terminated \nstring\n, just like in C:\n\n\nExample:\n\n\n_printf(\nHello World!\\n\n);\n\n\n\n\nNull pointer\n\n\nTODO (like C)\n\n\nComments\n\n\nC\u00e9u provides C-style comments:\n\n\n\n\nSingle-line comments begin with \n//\n and run to end of the line.\n\n\nMulti-line comments use \n/*\n and \n*/\n as delimiters.\n  Multi-line comments can be nested by using a different number of \n*\n as\n  delimiters.\n\n\n\n\nExamples:\n\n\nvar int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Lexical Rules"
        }, 
        {
            "location": "/lexical_rules/#lexical-rules", 
            "text": "", 
            "title": "Lexical Rules"
        }, 
        {
            "location": "/lexical_rules/#keywords", 
            "text": "Keywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):      and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    lock            loop            lua             native          new\n\n    nohold          not             nothing         nil             null\n\n    or              outer           output          par             pause\n\n    plain           pool            pos             pre             pure\n\n    recursive       request         resume          sizeof          spawn\n\n    static          then            thread          tight           traverse\n\n    true            until           val             var             vector\n\n    watching        with            bool            byte            f32\n\n    f64             float           int             s16             s32\n\n    s64             s8              ssize           u16             u32\n\n    u64             u8              uint            usize           void", 
            "title": "Keywords"
        }, 
        {
            "location": "/lexical_rules/#identifiers", 
            "text": "C\u00e9u uses identifiers to refer to  types  ( ID_type ),  variables  ( ID_int ), vectors  ( ID_int ),  pools  ( ID_int ),  internal events  ( ID_int ), external events  ( ID_ext ),  code abstractions  ( ID_abs ), data abstractions  ( ID_abs ),  fields  ( ID_field ), native symbols  ( ID_nat ), and  block labels  ( ID_int ).  ID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\n\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )  Declarations for  code  and  data  create new types  which can be used as type identifiers.  Examples:  var int a;                    //  a  is a variable,  int  is a type\nemit e;                       //  e  is an internal event\nawait E;                      //  E  is an external input event\nspawn Move();                 //  Move  is a code abstraction and a type\nvar Rect r;                   //  Rect  is a data abstraction and a type\nreturn r.width;               //  width  is a field\n_printf( hello world!\\n );    //  _printf  is a native symbol", 
            "title": "Identifiers"
        }, 
        {
            "location": "/lexical_rules/#literals", 
            "text": "C\u00e9u supports literals for  booleans ,  integers ,  floats ,  strings , and null pointers .", 
            "title": "Literals"
        }, 
        {
            "location": "/lexical_rules/#booleans", 
            "text": "The boolean type has only two possible values:  true  and  false .", 
            "title": "Booleans"
        }, 
        {
            "location": "/lexical_rules/#integers", 
            "text": "C\u00e9u supports decimal and hexadecimal integers:   Decimals: a sequence of digits (i.e.,  [0-9]+ ).  Hexadecimals: a sequence of hexadecimal digits (i.e.,  [0-9, a-f, A-F]+ )\n                prefixed by  0x .    Examples:  // both are equal to the decimal 127\nv = 127;    // decimal\nv = 0x7F;   // hexadecimal", 
            "title": "Integers"
        }, 
        {
            "location": "/lexical_rules/#floats", 
            "text": "TODO (like C)", 
            "title": "Floats"
        }, 
        {
            "location": "/lexical_rules/#strings", 
            "text": "A sequence of characters surrounded by  \"  is converted into a  null-terminated \nstring , just like in C:  Example:  _printf( Hello World!\\n );", 
            "title": "Strings"
        }, 
        {
            "location": "/lexical_rules/#null-pointer", 
            "text": "TODO (like C)", 
            "title": "Null pointer"
        }, 
        {
            "location": "/lexical_rules/#comments", 
            "text": "C\u00e9u provides C-style comments:   Single-line comments begin with  //  and run to end of the line.  Multi-line comments use  /*  and  */  as delimiters.\n  Multi-line comments can be nested by using a different number of  *  as\n  delimiters.   Examples:  var int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Comments"
        }, 
        {
            "location": "/types/", 
            "text": "Types\n\n\nC\u00e9u is statically typed, requiring all variables, events, and other entities to\nbe declared before they are used in programs.\n\n\nA type is composed of a \ntype identifier\n,\nfollowed by an optional sequence of \npointer modifiers\n \n,\nfollowed by an optional \noption modifier\n \n?\n:\n\n\nType ::= ID_type {`\n\u00b4} [`?\u00b4]\n\n\n\n\nExamples:\n\n\nvar   u8     v;    // \nv\n is of 8-bit unsigned integer type\nvar   _rect  r;    // \nr\n is of external native type \nrect\n\nvar   Tree   t;    // \nt\n is a data of type \nTree\n\nvar   int?   ret;  // \nret\n is either unset or is of integer type\ninput byte\n RECV; // \nRECV\n is an input event carrying a pointer to a \nbyte\n\n\n\n\n\nPrimitives\n\n\nC\u00e9u has the following primitive types:\n\n\nvoid               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integers\ns16      u16       // signed and unsigned 16-bit integers\ns32      u32       // signed and unsigned 32-bit integers\ns64      u64       // signed and unsigned 64-bit integers\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types\n\n\n\n\n\n\n\nNatives\n\n\nTypes defined externally in C can be prefixed by \n_\n to be used in C\u00e9u programs.\n\n\nExample:\n\n\nvar _message_t msg;      // \nmessage_t\n is a C type defined in an external library\n\n\n\n\nNative types support \nmodifiers\n to provide\nadditional information to the compiler.\n\n\nAbstractions\n\n\n\n\n\nSee \nAbstractions\n.\n\n\nModifiers\n\n\nTypes can be suffixed with the pointer modifier \n and the option modifier\n\n?\n.\n\n\nPointer\n\n\nTODO (like in C)\n\n\nTODO cannot cross yielding statements\n\n\nOption\n\n\nTODO (like \"Maybe\")\n\n\nTODO: nil", 
            "title": "Types"
        }, 
        {
            "location": "/types/#types", 
            "text": "C\u00e9u is statically typed, requiring all variables, events, and other entities to\nbe declared before they are used in programs.  A type is composed of a  type identifier ,\nfollowed by an optional sequence of  pointer modifiers   ,\nfollowed by an optional  option modifier   ? :  Type ::= ID_type {` \u00b4} [`?\u00b4]  Examples:  var   u8     v;    //  v  is of 8-bit unsigned integer type\nvar   _rect  r;    //  r  is of external native type  rect \nvar   Tree   t;    //  t  is a data of type  Tree \nvar   int?   ret;  //  ret  is either unset or is of integer type\ninput byte  RECV; //  RECV  is an input event carrying a pointer to a  byte", 
            "title": "Types"
        }, 
        {
            "location": "/types/#primitives", 
            "text": "C\u00e9u has the following primitive types:  void               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integers\ns16      u16       // signed and unsigned 16-bit integers\ns32      u32       // signed and unsigned 32-bit integers\ns64      u64       // signed and unsigned 64-bit integers\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types", 
            "title": "Primitives"
        }, 
        {
            "location": "/types/#natives", 
            "text": "Types defined externally in C can be prefixed by  _  to be used in C\u00e9u programs.  Example:  var _message_t msg;      //  message_t  is a C type defined in an external library  Native types support  modifiers  to provide\nadditional information to the compiler.", 
            "title": "Natives"
        }, 
        {
            "location": "/types/#abstractions", 
            "text": "See  Abstractions .", 
            "title": "Abstractions"
        }, 
        {
            "location": "/types/#modifiers", 
            "text": "Types can be suffixed with the pointer modifier   and the option modifier ? .", 
            "title": "Modifiers"
        }, 
        {
            "location": "/types/#pointer", 
            "text": "TODO (like in C)  TODO cannot cross yielding statements", 
            "title": "Pointer"
        }, 
        {
            "location": "/types/#option", 
            "text": "TODO (like \"Maybe\")  TODO: nil", 
            "title": "Option"
        }, 
        {
            "location": "/storage_entities/", 
            "text": "Storage Entities\n\n\nStorage entities represent all objects that are stored in memory during\nexecution.\nC\u00e9u supports \nvariables\n, \nvectors\n, \nevents\n (external and internal), and\n\npools\n as entity classes.\n\n\nAn \nentity declaration\n consists of an entity\nclass, a \ntype\n, and an \nidentifier\n.\n\n\nExamples:\n\n\nvar       int    v;     // \nv\n is a variable of type \nint\n\nvector[9] byte   buf;   // \nbuf\n is a vector with at most 9 values of type \nbyte\n\ninput     void\n A;     // \nA\n is an input event that carries values of type \nvoid\n\nevent     bool   e;     // \ne\n is an internal event that carries values of type \nbool\n\npool[]    Anim   anims; // \nanims\n is a dynamic \npool\n for instances of type \nAnim\n\n\n\n\n\nA declaration binds the identifier with a memory location that holds values of\nthe associated type.\n\n\nLexical Scope\n\n\nStorage entities have lexical scope, i.e., they are visible only in the\n\nblock\n in which they are declared.\n\n\nThe lifetime of entities, which is the period between allocation and\ndeallocation in memory, is also limited to the scope of the enclosing block.\nHowever, individual elements inside \nvector\n and \npool\n entities have dynamic\nlifetime, but which never outlive the scope of the declaration.\n\n\nEntity Classes\n\n\nVariables\n\n\nA variable in C\u00e9u holds a value of a \ndeclared\n\n\ntype\n that may vary during program execution.\nThe value of a variable can be read in\n\nexpressions\n or written in\n\nassignments\n.\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.\n\n\n\n\n\nExample:\n\n\nvar int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)\n\n\n\n\nVectors\n\n\nA vector In C\u00e9u is a dynamic and contiguous collection of elements of the same\ntype.\n\n\nA \nvector declaration\n specifies its type and maximum\nnumber of elements (possibly unlimited).\nThe current length of a vector is dynamic and can be accessed through the\n\noperator \n$\n.\n\n\nIndividual elements of a vector can be accessed through an\n\nindex\n starting from \n0\n.\nC\u00e9u generates an \nerror\n for out-of-bounds vector accesses.\n\n\nExample:\n\n\nvector[9] byte buf = [1,2,3];   // write access\nbuf = buf .. [4];               // write access\nescape buf[1];                  // read access (yields 2)\n\n\n\n\nEvents\n\n\nEvents account for the reactive nature of C\u00e9u.\nPrograms manipulate events through the \nawait\n and\n\nemit\n\nstatements.\nAn \nawait\n halts the running trail until the specified event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.\n\n\nUnlike all other entity classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through \nemit\n and \nawait\n statements.\nA \ndeclaration\n includes the type of value the occurring\nevent carries.\n\n\nNote: \nvoid\n is a valid type for signal-only events.\n\n\nExample:\n\n\ninput  void I;           // \nI\n is an input event that carries no values\noutput int  O;           // \nO\n is an output event that carries values of type \nint\n\nevent  int  e;           // \ne\n is an internal event that carries values of type \nint\n\npar/and do\n    await I;             // awakes when \nI\n occurs\n    emit e(10);          // broadcasts \ne\n passing 10, awakes the \nawait\n below\nwith\n    var int v = await e; // awaits \ne\n assigning the received value to \nv\n\n    emit O(v);           // emits \nO\n back to the environment passing \nv\n\nend\n\n\n\n\nAs described in \nInternal Reactions\n, C\u00e9u supports\nexternal and internal events with different behavior.\n\n\nExternal Events\n\n\nExternal events are used as interfaces between programs and devices from the \nreal world:\n\n\n\n\ninput events\n represent input devices such as sensor, button, mouse, etc.\n\n\noutput events\n represent output devices such as LED, motor, screen, etc.\n\n\n\n\nThe availability of external events depends on the\n\nenvironment\n in use.\n\n\nPrograms can \nemit\n output events and \nawait\n input events.\n\n\n\n\n\n\n\n\nInternal Events\n\n\nInternal events, unlike external events, do not represent real devices and are\ndefined by the programmer.\nInternal events serve as signalling and communication mechanisms among trails\nin a program.\n\n\nPrograms can \nemit\n and \nawait\n internal events.\n\n\nPools\n\n\nA pool is a dynamic container to hold running \ncode abstractions\n.\n\n\nA \npool declaration\n specifies the type of the\nabstraction and maximum number of concurrent instances (possibly unlimited).\nIndividual elements of pools can only be accessed through\n\niterators\n.\nNew elements are created with \nspawn\n and are\nremoved automatically when the code execution terminates.\n\n\nExample:\n\n\ncode/await Anim (void) =\n void do       // defines the \nAnim\n code abstraction\n    \n...\n                               // body of \nAnim\n\nend\npool[] Anim ms;                         // declares an unlimited container for \nAnim\n instances\nloop i in [0-\n10[ do\n    spawn Anim() in ms;                 // creates 10 instances of \nAnim\n into \nms\n\nend\n\n\n\n\nWhen a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.\n\n\n\n\n\nLocations\n\n\nA location (aka \nl-value\n) is a path to a memory location holding a storage\nentity (\nID_int\n) or a native symbol\n(\nID_nat\n).\n\n\nLocations appear in assignments, event manipulation, iterators, and\nexpressions.\n\n\nThe list that follows summarizes all valid locations:\n\n\n\n\nstorage entity: variable, vector, internal event (but not external), or pool\n\n\nnative expression or symbol\n\n\ndata field (which are storage entities)\n\n\nvector index\n\n\nvector length \n$\n\n\npointer dereferencing \n*\n\n\noption unwrapping \n!\n\n\n\n\nLocations are detailed in \nLocations and Expressions\n.\n\n\nExamples:\n\n\nemit e(1);          // \ne\n is an internal event\n_UDR = 10;          // \n_UDR\n is a native symbol\nperson.age = 70;    // \nage\n is a variable in \nperson\n\nvec[0] = $vec;      // \nvec[0]\n is a vector index\n$vec = 1;           // \n$vec\n is a vector length\n*ptr = 1;           // \nptr\n is a pointer to a variable\na! = 1;             // \na\n is of an option type\n\n\n\n\nReferences\n\n\nC\u00e9u supports \naliases\n and \npointers\n as references to entities, aka \nstrong\n\nand \nweak\n references, respectively.\n\n\nAn alias is an alternate view for an entity: after the entity and alias are\nbounded, they are indistinguishable.\n\n\nA pointer is a value that is the address of an entity, providing indirect\naccess to it.\n\n\nAs an analogy with a person's identity,\na family nickname referring to a person is an alias;\na job position referring to a person is a pointer.\n\n\nAliases\n\n\nC\u00e9u support aliases to all storage entity classes, except external events and\npointer types.\nC\u00e9u also supports option variable aliases which are aliases that may remain or\nbecome unassigned.\n\n\nAn alias is declared by suffixing the entity class with the modifier\n\n and is acquired by prefixing an entity with the operator \n.\n\n\nAn alias must have a narrower scope than the entity it refers to.\nThe \nassignment\n to the alias is immutable and must\noccur between its declaration and first access or next\n\nyielding statement\n.\n\n\nExample:\n\n\nvar  int v = 0;\nvar\n int a = \nv;        // \na\n is an alias to \nv\n\n...\na = 1;                  // \na\n and \nv\n are indistinguishable\n_printf(\n%d\\n\n, v);     // prints 1\n\n\n\n\nAn option variable alias, declared as \nvar\n?\n, serves two purposes:\n\n\n\n\nMap a \nnative resource\n to a variable\n  in C\u00e9u.\n  The alias is acquired by prefixing the associated\n  \nnative call\n with the operator \n.\n  Since the allocation may fail, the alias may remain unassigned.\n\n\nTrack the lifetime of a variable.\n  The alias is acquired by prefixing the associated variable with\n  the operator \n.\n  Since the tracked variable may go out of scope, the alias may become\n  unassigned.\n\n\n\n\nAccesses to option variable aliases must always use\n\noption checking or unwrapping\n.\n\n\nExamples:\n\n\nvar\n? _FILE f = \n_fopen(\n...\n) finalize with\n                    _fclose(f);\n                end;\nif f? then\n    \n...\n   // \nf\n is assigned\nelse\n    \n...\n   // \nf\n is not assigned\nend\n\n\n\n\nvar\n? int x;\ndo\n    var int y = 10;\n    x = \ny;\n    _printf(\n%d\\n\n, x!);    // prints 10\nend\n_printf(\n%d\\n\n, x!);        // error!\n\n\n\n\nPointers\n\n\nA pointer is declared by suffixing the type with the modifier\n\n and is acquired by prefixing an entity with the operator \n.\nApplying the operator \n*\n to a pointer provides indirect access to its\nreferenced entity.\n\n\nExample:\n\n\nvar int   v = 0;\nvar int\n p = \nv;      // \np\n holds a pointer to \nv\n\n...\n*p = 1;                 // \np\n provides indirect access to \nv\n\n_printf(\n%d\\n\n, v);     // prints 1\n\n\n\n\nThe following restrictions apply to pointers in C\u00e9u:\n\n\n\n\n\n\n\nNo support for pointers to events, vectors, or pools (only variables).\n\n\nA pointer is only accessible between its declaration and the next\n  \nyielding statement\n.", 
            "title": "Storage Entities"
        }, 
        {
            "location": "/storage_entities/#storage-entities", 
            "text": "Storage entities represent all objects that are stored in memory during\nexecution.\nC\u00e9u supports  variables ,  vectors ,  events  (external and internal), and pools  as entity classes.  An  entity declaration  consists of an entity\nclass, a  type , and an  identifier .  Examples:  var       int    v;     //  v  is a variable of type  int \nvector[9] byte   buf;   //  buf  is a vector with at most 9 values of type  byte \ninput     void  A;     //  A  is an input event that carries values of type  void \nevent     bool   e;     //  e  is an internal event that carries values of type  bool \npool[]    Anim   anims; //  anims  is a dynamic  pool  for instances of type  Anim   A declaration binds the identifier with a memory location that holds values of\nthe associated type.", 
            "title": "Storage Entities"
        }, 
        {
            "location": "/storage_entities/#lexical-scope", 
            "text": "Storage entities have lexical scope, i.e., they are visible only in the block  in which they are declared.  The lifetime of entities, which is the period between allocation and\ndeallocation in memory, is also limited to the scope of the enclosing block.\nHowever, individual elements inside  vector  and  pool  entities have dynamic\nlifetime, but which never outlive the scope of the declaration.", 
            "title": "Lexical Scope"
        }, 
        {
            "location": "/storage_entities/#entity-classes", 
            "text": "", 
            "title": "Entity Classes"
        }, 
        {
            "location": "/storage_entities/#variables", 
            "text": "A variable in C\u00e9u holds a value of a  declared  type  that may vary during program execution.\nThe value of a variable can be read in expressions  or written in assignments .\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.   Example:  var int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)", 
            "title": "Variables"
        }, 
        {
            "location": "/storage_entities/#vectors", 
            "text": "A vector In C\u00e9u is a dynamic and contiguous collection of elements of the same\ntype.  A  vector declaration  specifies its type and maximum\nnumber of elements (possibly unlimited).\nThe current length of a vector is dynamic and can be accessed through the operator  $ .  Individual elements of a vector can be accessed through an index  starting from  0 .\nC\u00e9u generates an  error  for out-of-bounds vector accesses.  Example:  vector[9] byte buf = [1,2,3];   // write access\nbuf = buf .. [4];               // write access\nescape buf[1];                  // read access (yields 2)", 
            "title": "Vectors"
        }, 
        {
            "location": "/storage_entities/#events", 
            "text": "Events account for the reactive nature of C\u00e9u.\nPrograms manipulate events through the  await  and emit \nstatements.\nAn  await  halts the running trail until the specified event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.  Unlike all other entity classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through  emit  and  await  statements.\nA  declaration  includes the type of value the occurring\nevent carries.  Note:  void  is a valid type for signal-only events.  Example:  input  void I;           //  I  is an input event that carries no values\noutput int  O;           //  O  is an output event that carries values of type  int \nevent  int  e;           //  e  is an internal event that carries values of type  int \npar/and do\n    await I;             // awakes when  I  occurs\n    emit e(10);          // broadcasts  e  passing 10, awakes the  await  below\nwith\n    var int v = await e; // awaits  e  assigning the received value to  v \n    emit O(v);           // emits  O  back to the environment passing  v \nend  As described in  Internal Reactions , C\u00e9u supports\nexternal and internal events with different behavior.", 
            "title": "Events"
        }, 
        {
            "location": "/storage_entities/#external-events", 
            "text": "External events are used as interfaces between programs and devices from the \nreal world:   input events  represent input devices such as sensor, button, mouse, etc.  output events  represent output devices such as LED, motor, screen, etc.   The availability of external events depends on the environment  in use.  Programs can  emit  output events and  await  input events.", 
            "title": "External Events"
        }, 
        {
            "location": "/storage_entities/#internal-events", 
            "text": "Internal events, unlike external events, do not represent real devices and are\ndefined by the programmer.\nInternal events serve as signalling and communication mechanisms among trails\nin a program.  Programs can  emit  and  await  internal events.", 
            "title": "Internal Events"
        }, 
        {
            "location": "/storage_entities/#pools", 
            "text": "A pool is a dynamic container to hold running  code abstractions .  A  pool declaration  specifies the type of the\nabstraction and maximum number of concurrent instances (possibly unlimited).\nIndividual elements of pools can only be accessed through iterators .\nNew elements are created with  spawn  and are\nremoved automatically when the code execution terminates.  Example:  code/await Anim (void) =  void do       // defines the  Anim  code abstraction\n     ...                                // body of  Anim \nend\npool[] Anim ms;                         // declares an unlimited container for  Anim  instances\nloop i in [0- 10[ do\n    spawn Anim() in ms;                 // creates 10 instances of  Anim  into  ms \nend  When a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.", 
            "title": "Pools"
        }, 
        {
            "location": "/storage_entities/#locations", 
            "text": "A location (aka  l-value ) is a path to a memory location holding a storage\nentity ( ID_int ) or a native symbol\n( ID_nat ).  Locations appear in assignments, event manipulation, iterators, and\nexpressions.  The list that follows summarizes all valid locations:   storage entity: variable, vector, internal event (but not external), or pool  native expression or symbol  data field (which are storage entities)  vector index  vector length  $  pointer dereferencing  *  option unwrapping  !   Locations are detailed in  Locations and Expressions .  Examples:  emit e(1);          //  e  is an internal event\n_UDR = 10;          //  _UDR  is a native symbol\nperson.age = 70;    //  age  is a variable in  person \nvec[0] = $vec;      //  vec[0]  is a vector index\n$vec = 1;           //  $vec  is a vector length\n*ptr = 1;           //  ptr  is a pointer to a variable\na! = 1;             //  a  is of an option type", 
            "title": "Locations"
        }, 
        {
            "location": "/storage_entities/#references", 
            "text": "C\u00e9u supports  aliases  and  pointers  as references to entities, aka  strong \nand  weak  references, respectively.  An alias is an alternate view for an entity: after the entity and alias are\nbounded, they are indistinguishable.  A pointer is a value that is the address of an entity, providing indirect\naccess to it.  As an analogy with a person's identity,\na family nickname referring to a person is an alias;\na job position referring to a person is a pointer.", 
            "title": "References"
        }, 
        {
            "location": "/storage_entities/#aliases", 
            "text": "C\u00e9u support aliases to all storage entity classes, except external events and\npointer types.\nC\u00e9u also supports option variable aliases which are aliases that may remain or\nbecome unassigned.  An alias is declared by suffixing the entity class with the modifier  and is acquired by prefixing an entity with the operator  .  An alias must have a narrower scope than the entity it refers to.\nThe  assignment  to the alias is immutable and must\noccur between its declaration and first access or next yielding statement .  Example:  var  int v = 0;\nvar  int a =  v;        //  a  is an alias to  v \n...\na = 1;                  //  a  and  v  are indistinguishable\n_printf( %d\\n , v);     // prints 1  An option variable alias, declared as  var ? , serves two purposes:   Map a  native resource  to a variable\n  in C\u00e9u.\n  The alias is acquired by prefixing the associated\n   native call  with the operator  .\n  Since the allocation may fail, the alias may remain unassigned.  Track the lifetime of a variable.\n  The alias is acquired by prefixing the associated variable with\n  the operator  .\n  Since the tracked variable may go out of scope, the alias may become\n  unassigned.   Accesses to option variable aliases must always use option checking or unwrapping .  Examples:  var ? _FILE f =  _fopen( ... ) finalize with\n                    _fclose(f);\n                end;\nif f? then\n     ...    //  f  is assigned\nelse\n     ...    //  f  is not assigned\nend  var ? int x;\ndo\n    var int y = 10;\n    x =  y;\n    _printf( %d\\n , x!);    // prints 10\nend\n_printf( %d\\n , x!);        // error!", 
            "title": "Aliases"
        }, 
        {
            "location": "/storage_entities/#pointers", 
            "text": "A pointer is declared by suffixing the type with the modifier  and is acquired by prefixing an entity with the operator  .\nApplying the operator  *  to a pointer provides indirect access to its\nreferenced entity.  Example:  var int   v = 0;\nvar int  p =  v;      //  p  holds a pointer to  v \n...\n*p = 1;                 //  p  provides indirect access to  v \n_printf( %d\\n , v);     // prints 1  The following restrictions apply to pointers in C\u00e9u:    No support for pointers to events, vectors, or pools (only variables).  A pointer is only accessible between its declaration and the next\n   yielding statement .", 
            "title": "Pointers"
        }, 
        {
            "location": "/statements/", 
            "text": "Statements\n\n\nA program in C\u00e9u is a sequence of statements delimited by an implicit enclosing\nblock:\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\n\n\n\nNote: statements terminated with the \nend\n keyword do not require a\nterminating semicolon.\n\n\nNothing\n\n\nnothing\n is an innocuous statement:\n\n\nNothing ::= nothing\n\n\n\n\nBlocks\n\n\nA \nBlock\n creates a new lexical scope for\n\nstorage entities\n\nand\n\nabstractions\n,\nwhich are visible only for statements inside the block.\n\n\nCompound statements (e.g. \ndo-end\n, \nif-then-else\n, \nloops\n, etc.) create new\nblocks and can be nested to an arbitrary level.\n\n\ndo-end\n and \nescape\n\n\nThe \ndo-end\n statement creates an explicit block with an optional identifier\nfollowing the symbol \n/\n.\nThe \nescape\n statement aborts the deepest enclosing \ndo-end\n matching its\nidentifier:\n\n\nDo ::= do [`/\u00b4(ID_int|`_\u00b4)] [`(\u00b4 [LIST(ID_int)] `)\u00b4]\n           Block\n       end\n\nEscape ::= escape [`/\u00b4ID_int] [Exp]\n\n\n\n\nThe neutral identifier \n_\n which is guaranteed not to match any \nescape\n\nstatement.\n\n\nA \ndo-end\n also supports an optional list of identifiers in parenthesis which\nrestricts the visible variables inside the block to those matching the list.\n\n\nA \ndo-end\n can be \nassigned\n to a variable whose type must be\nmatched by nested \nescape\n statements.\nThe whole block evaluates to the value of a reached \nescape\n.\nIf the variable is of \noption type\n, the \ndo-end\n is allowed\nto terminate without an \nescape\n, otherwise it raises a runtime error.\n\n\nPrograms have an implicit enclosing \ndo-end\n that assigns to a\n\nprogram status variable\n of type \nint\n whose meaning is platform dependent.\n\n\nExamples:\n\n\ndo\n    do/a\n        do/_\n            escape;     // matches line 1\n        end\n        escape/a;       // matches line 2\n    end\nend\n\n\n\n\nvar int a;\nvar int b;\ndo (a)\n    a = 1;\n    b = 2;  // \nb\n is not visible\nend\n\n```ceu\nvar int? v =\n    do\n        if \ncnd\n then\n            escape 10;  // assigns 10 to \nv\n\n        else\n            nothing;    // \nv\n remains unassigned\n        end\n    end;\n\n\n\n\nescape 0;               // program terminates with a status value of 0\n\n\n\n\npre-do-end\n\n\nThe \npre-do-end\n statement prepends its statements in the beginning of the\nprogram:\n\n\nPre_Do ::= pre do\n               Block\n           end\n\n\n\n\nAll \npre-do-end\n statements are concatenated together in the order they appear\nand moved to the beginning of the top-level block, before all other statements.\n\n\nDeclarations\n\n\nA declaration introduces a \nstorage entity\n\nto the enclosing block.\nAll declarations are subject to \nlexical scope\n.\n\n\nC\u00e9u supports variables, vectors, pools, internal events, and external events:\n\n\n\nVar  ::= var [`\n\u00b4|`\n?\u00b4] [`/dynamic\u00b4|`/nohold\u00b4] Type ID_int [`=\u00b4 Sources]\nVec  ::= vector [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\nPool ::= pool [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\nInt  ::= event [`\n\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_int [`=\u00b4 Sources]\n\nExt  ::= input  (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_ext\n      |  output (Type | `(\u00b4 LIST([`\n\u00b4] Type) `)\u00b4) ID_ext\n\nSources ::= /* (see \nAssignments\n) */\n\n\n\n\nMost declarations support an initialization \nassignment\n.\n\n\n\n\n\nVariables\n\n\nA \nvariable\n declaration has an associated\n\ntype\n and can be optionally \ninitialized\n.\nDeclarations can also be\n\naliases or option aliases\n.\n\n\nExamples:\n\n\nvar  int v = 10;    // \nv\n is an integer variable initialized to 10\nvar  int a=0, b=3;  // \na\n and \nb\n are integer variables initialized to 0 and 3\nvar\n int z = \nv;    // \nz\n is an alias to \nv\n\n\n\n\n\nVectors\n\n\nA \nvector\n declaration specifies a\n\ndimension\n between brackets,\nan associated \ntype\n and can be optionally\n\ninitialized\n.\nDeclarations can also be \naliases\n.\n\n\n\n\n\nExamples:\n\n\nvar int n = 10;\nvector[10] int vs1 = [];    // \nvs1\n is a static vector of 10 elements max\nvector[n]  int vs2 = [];    // \nvs2\n is a dynamic vector of 10 elements max\nvector[]   int vs3 = [];    // \nvs3\n is an unbounded vector\nvector\n[]  int vs4 = \nvs1;  // \nvs4\n is an alias to \nvs1\n\n\n\n\n\nPools\n\n\nA \npool\n declaration specifies a dimension and an\nassociated \ntype\n.\nDeclarations for pools can also be \naliases\n.\nOnly in this case they can be \ninitialized\n.\n\n\nThe expression between the brackets specifies the \ndimension\n of\nthe pool.\n\n\nExamples:\n\n\ncode/await Play (...) do ... end\npool[10] Play plays;        // \nplays\n is a static pool of 10 elements max\npool\n[]  Play a = \nplays;   // \na\n is an alias to \nplays\n\n\n\n\n\n\n\n\nTODO: data\n\n\nDimension\n\n\nDeclarations for \nvectors\n or \npools\n require an expression\nbetween brackets to specify a dimension as follows:\n\n\n\n\nconstant expression\n: Maximum number of elements is fixed and space is\n                         statically pre-allocated.\n\n\nvariable expression\n: Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.\n\n\nomitted\n: Maximum number of elements is unbounded and space is dynamically\n             allocated.\n             The space for dynamic dimensions grow and shrink automatically.\n\n\n\n\nEvents\n\n\nAn \nevent\n declaration specifies a\n\ntype\n for the values it carries when occurring.\nIt can be also a list of types if the event communicates multiple values.\n\n\n\n\n\nExternal Events\n\n\nExamples:\n\n\ninput  void A,B;        // \nA\n and \nB\n are input events carrying no values\noutput int  MY_EVT;     // \nMY_EVT\n is an output event carrying integer values\ninput (int,byte\n) BUF; // \nBUF\n is an input event carrying an \n(int,byte\n)\n pair\n\n\n\n\nTODO: output \n\n\nInternal Events\n\n\nDeclarations for internal events can also be\n\naliases\n.\nOnly in this case they can be \ninitialized\n.\n\n\nExamples:\n\n\nevent  void a,b;        // \na\n and \nb\n are internal events carrying no values\nevent\n void z = \na;     // \nz\n is an alias to event \na\n\nevent (int,int) c;      // \nc\n is a internal event carrying an \n(int,int)\n pair\n\n\n\n\nAssignments\n\n\nAn assignment associates the statement or expression at the right side of the\nsymbol \n=\n with the \nlocation(s)\n at the left side:\n\n\nAssignment ::= (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Sources\n\nSources ::= ( Do\n            | Emit_Ext\n            | Await\n            | Watching\n            | Thread\n            | Lua_State\n            | Lua_Stmts\n            | Code_Await\n            | Code_Spawn\n            | Vec_Cons\n            | Data_Cons\n            | Exp\n            | `nil\u00b4\n            | `_\u00b4 )\n\n\n\n\nC\u00e9u supports the following constructs as assignment sources:\n\n\n\n\ndo-end\n block\n\n\nexternal emit\n\n\nawait\n\n\nwatching statement\n\n\nthread\n\n\nlua state\n\n\nlua statement\n\n\ncode await\n\n\ncode spawn\n\n\nvector \nlength\n \n \nconstructor\n\n\ndata constructor\n\n\nexpression\n\n\nthe \noption\n \nnil\n value\n\n\nthe anonymous identifier \n_\n\n\n\n\nThe option \nnil\n value unsets an \noption variable\n.\n\n\nThe anonymous identifier makes the assignment innocuous.\n\n\nTODO: required for uninitialized variables\n\n\nCopy Assignment\n\n\nA \ncopy assignment\n evaluates the statement or expression at the right side and\ncopies the result(s) to the location(s) at the left side.\n\n\nAlias Assignment\n\n\nAn \nalias assignment\n, aka \nbinding\n, makes the location at the left side to be\nan \nalias\n to the expression at the right side.\n\n\nThe right side of a binding is always prefixed by the operator \n.\n\n\nEvent Handling\n\n\nAwait\n\n\nThe \nawait\n statement halts the running trail until the specified event occurs.\nThe event can be an \ninput event\n, an\n\ninternal event\n, a timer, a\n\npausing event\n, or forever (i.e., never awakes):\n\n\nAwait ::= await (ID_ext | Loc) [until Exp]      /* events and option aliases */\n       |  await (WCLOCKK|WCLOCKE)               /* timers */\n       |  await (pause|resume)                  /* pausing events */\n       |  await FOREVER                         /* forever */\n\n\n\n\nExamples:\n\n\nawait A;                  // awaits the input event \nA\n\nawait a until v==10;      // awaits the internal event \na\n until the condition is satisfied\n\nawait 1min10s30ms100us;   // awaits the specified time\nawait (t)ms;              // awaits the current value of the variable \nt\n in milliseconds\n\nawait FOREVER;            // awaits forever\n\n\n\n\nAn \nawait\n evaluates to zero or more values which can be captured with an\noptional \nassignment\n.\n\n\nEvent\n\n\nThe \nawait\n statement for events halts the running trail until the specified\n\ninput event\n or\n\ninternal event\n occurs.\nThe \nawait\n evaluates to a value of the type of the event.\n\n\nThe optional clause \nuntil\n tests an awaking condition.\nThe condition can use the returned value from the \nawait\n.\nIt expands to a \nloop\n as follows:\n\n\nloop do\n    \nret\n = await \nevt\n;\n    if \nExp\n then   // \nExp\n can use \nret\n\n        break;\n    end\nend\n\n\n\n\nExamples:\n\n\ninput int E;                    // \nE\n is an input event carrying \nint\n values\nvar int v = await E until v\n10; // assigns occurring \nE\n to \nv\n, awaking only when \nv\n10\n\n\nevent (bool,int) e;             // \ne\n is an internal event carrying \n(bool,int)\n pairs\nvar bool v1;\nvar int  v2;\n(v1,v2) = await e;              // awakes on \ne\n and assigns its values to \nv1\n and \nv2\n\n\n\n\n\nOption Alias\n\n\nThe \nawait\n statement for \noption variable aliases\n\nhalts the running trail until the specified alias goes out of scope.\n\n\nThe \nawait\n evaluates to no value.\n\n\nExample:\n\n\nvar\n? int x;\nspawn Code() -\n (\nx);   // \nx\n is bounded to a variable inside \nCode\n\nawait x;                // awakes when the spawned \nCode\n terminates\n\n\n\n\nTimer\n\n\nThe \nawait\n statement for timers halts the running trail until the specified\ntimer expires:\n\n\n\n\nWCLOCKK\n specifies a constant timer expressed as a sequence of value/unit\n  pairs.\n\n\nWCLOCKE\n specifies an \ninteger\n expression in\n  parenthesis followed by a single unit of time.\n\n\n\n\nThe \nawait\n evaluates to a value of type \ns32\n and is the\n\nresidual delta time (\ndt\n)\n measured in microseconds:\n    the difference between the actual elapsed time and the requested time.\nThe residual \ndt\n is always greater than or equal to 0.\n\n\nIf a program awaits timers in sequence (or in a \nloop\n), the residual \ndt\n from\nthe preceding timer is reduced from the timer in sequence.\n\n\nExamples:\n\n\nvar int t = \n...\n;\nawait (t)ms;                // awakes after \nt\n milliseconds\n\n\n\n\nvar int dt = await 100us;   // if 1000us elapses, then dt=900us (1000-100)\nawait 100us;                // since dt=900, this timer is also expired, now dt=800us (900-100)\nawait 1ms;                  // this timer only awaits 200us (1000-800)\n\n\n\n\n\n\n\nPausing\n\n\nPausing events are dicussed in \nPausing\n.\n\n\nFOREVER\n\n\nThe \nawait\n statement for \nFOREVER\n halts the running trail forever.\nIt cannot be used in assignments because it never evaluates to anything.\n\n\nExample:\n\n\nif v==10 then\n    await FOREVER;  // this trail never awakes if condition is true\nend\n\n\n\n\nEmit\n\n\nThe \nemit\n statement broadcasts an event to the whole program.\nThe event can be an \nexternal event\n, an\n\ninternal event\n, or a timer:\n\n\nEmit_Int ::= emit Loc [`(\u00b4 [LIST(Exp)] `)\u00b4]\nEmit_Ext ::= emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n          |  emit (WCLOCKK|WCLOCKE)\n\n\n\n\nExamples:\n\n\nemit A;         // emits the output event `A` of type \nvoid\n\nemit a(1);      // emits the internal event `a` of type \nint\n\n\nemit 1s;        // emits the specified time\nemit (t)ms;     // emits the current value of the variable `t` in milliseconds\n\n\n\n\nEvents\n\n\nThe \nemit\n statement for events expects the arguments to match the event type.\n\n\nAn \nemit\n to an input or timer event can only occur inside\n\nasynchronous blocks\n.\n\n\nAn \nemit\n to an output event is also an expression that evaluates to a value of\ntype \ns32\n and can be captured with an optional \nassignment\n (its\nmeaning is platform dependent).\n\n\nAn \nemit\n to an internal event starts a new\n\ninternal reaction\n.\n\n\nExamples:\n\n\ninput int I;\nasync do\n    emit I(10);         // broadcasts \nI\n to the application itself, passing \n10\n\nend\n\noutput void O;\nvar int ret = emit O(); // outputs \nO\n to the environment and captures the result\n\nevent (int,int) e;\nemit e(1,2);            // broadcasts \ne\n passing a pair of \nint\n values\n\n\n\n\nTimer\n\n\nThe \nemit\n statement for timers expects a \ntimer expression\n.\n\n\nLike input events, time can only be emitted inside \nasynchronous \nblocks\n.\n\n\nExamples:\n\n\nasync do\n    emit 1s;    // broadcasts \n1s\n to the application itself\nend\n\n\n\n\nLock\n\n\nTODO\n\n\nConditional\n\n\nThe \nif-then-else\n statement provides conditional execution in C\u00e9u:\n\n\nIf ::= if Exp then\n           Block\n       { else/if Exp then\n           Block }\n       [ else\n           Block ]\n       end\n\n\n\n\nEach condition \nExp\n is tested in sequence, first for the \nif\n clause and then\nfor each of the optional \nelse/if\n clauses.\nOn the first condition that evaluates to \ntrue\n, the \nBlock\n following it\nexecutes.\nIf all conditions fail, the optional \nelse\n clause executes.\n\n\nAll conditions must evaluate to a value of type \nbool\n.\n\n\n\nLoops\n\n\nC\u00e9u supports simple loops, numeric iterators, event iterators, and pool\niterators:\n\n\nLoop ::=\n      /* simple loop */\n        loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] Numeric do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n            Block\n        end\n\nBreak    ::= break [`/\u00b4ID_int]\nContinue ::= continue [`/\u00b4ID_int]\n\nNumeric ::= /* (see \nNumeric Iterators\n) */\n\n\n\n\nThe body of a loop \nBlock\n executes an arbitrary number of times, depending on\nthe conditions imposed by each kind of loop.\n\n\nExcept for the \nevery\n iterator, all loops support an optional constant\nexpression \n/\nExp\n that limits the maximum number of\niterations to avoid \ninfinite execution\n.\nIf the number of iterations reaches the limit, a runtime error occurs.\n\n\n\n\n\nbreak\n and \ncontinue\n\n\nThe \nbreak\n statement aborts the deepest enclosing loop.\n\n\nThe \ncontinue\n statement aborts the body of the deepest enclosing loop and\nrestarts it in the next iteration.\n\n\nThe optional modifier \n/\nID_int\n in both statements\nonly applies to \nnumeric iterators\n.\n\n\nSimple Loop\n\n\nThe simple \nloop-do-end\n statement executes its body forever.\nThe only way to terminate a simple loop is with the \nbreak\n statement.\n\n\nExamples:\n\n\n// blinks a LED with a frequency of 1s forever\nloop do\n    emit LED(1);\n    await 1s;\n    emit LED(0);\n    await 1s;\nend\n\n\n\n\nloop do\n    loop do\n        if \ncnd-1\n then\n            break;      // aborts the loop at line 2 if \ncnd-1\n is satisfied\n        end\n    end\n    if \ncnd-2\n then\n        continue;       // restarts the loop at line 1 if \ncnd-2\n is satisfied\n    end\nend\n\n\n\n\nNumeric Iterator\n\n\nThe numeric loop executes its body a fixed number of times based on a numeric\nrange for a control variable:\n\n\nNumeric ::= (`_\u00b4|ID_int) in [ (`[\u00b4 | `]\u00b4)\n                                  ( (     Exp `-\n\u00b4 (`_\u00b4|Exp))\n                                  | (`_\u00b4|Exp) `\n-\u00b4 Exp      ) )\n                              (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp] ]\n\n\n\n\nThe control variable assumes the values specified in the interval, one by one,\nfor each iteration of the loop body:\n\n\n\n\ncontrol variable:\n\n    \nID_int\n is a read-only variable of a \nnumeric type\n.\n    Alternatively, the special anonymous identifier \n_\n can be used if the body\n    of the loop does not access the variable.\n\n\n\n\ninterval:\n\n    Specifies a direction, endpoints with open or closed modifiers, and a step.\n\n\n\n\ndirection\n:\n\n\n-\n: Starts from the endpoint \nExp\n on the left increasing towards \nExp\n on the right.\n\n\n-\n: Starts from the endpoint \nExp\n on the right decreasing towards \nExp\n on the left.\nTypically, the value on the left is smaller or equal to the value on\nthe right.\n\n\n\n\n\n\nendpoints\n:\n    \n[Exp\n and \nExp]\n are closed intervals which include \nExp\n as the\n    endpoints;\n    \n]Exp\n and \nExp[\n are open intervals which exclude \nExp\n as the\n    endpoints.\n    Alternatively, the finishing endpoint may be \n_\n which means that the\n    interval goes towards infinite.\n\n\nstep\n:\n    An optional positive number added or subtracted towards the limit.\n    If the step is omitted, it assumes the value \n1\n.\n    If the direction is \n-\n, the step is added, otherwise it is subtracted.\n\n\n\n\nIf the interval is not specified, it assumes the default \n[0 -\n _]\n.\n\n\n\n\n\n\nA numeric iterator executes as follows:\n\n\n\n\n\n\ninitialization:\n\n    The starting endpoint is assigned to the control variable.\n    If the starting enpoint is open, the control variable accumulates a step\n    immediately.\n\n\n\n\n\n\niteration:\n\n\n\n\nlimit check:\n\n    If the control variable crossed the finishing endpoint, the loop\n    terminates.\n\n\nbody execution:\n\n    The loop body executes.\n\n\nstep\n\n    Applies a step to the control variable. Goto step \n1\n.\n\n\n\n\n\n\n\n\nThe \nbreak\n and \ncontinue\n statements inside numeric iterators accept an\noptional modifier \n/\nID_int\n to affect the enclosing\nloop matching the control variable.\n\n\nExamples:\n\n\n// prints \ni=0\n, \ni=1\n, ...\nvar int i;\nloop i do\n    _printf(\ni=%d\\n\n, i);\nend\n\n\n\n\n// awaits 1s and prints \nHello World!\n 10 times\nloop _ in [0 -\n 10[ do\n    await 1s;\n    _printf(\nHello World!\\n\n);\nend\n\n\n\n\nvar int i;\nloop i do\n    var int j;\n    loop j do\n        if \ncnd-1\n then\n            continue/i;         // continues the loop at line 1\n        else/if \ncnd-2\n then\n            break/j;            // breaks the loop at line 4\n        end\n    end\nend\n\n\n\n\nNote : the runtime asserts that the step is a positive number and that the\n        control variable does not overflow.\n\n\nEvent Iterator\n\n\nThe \nevery\n statement iterates over an event continuously, executing its\nbody whenever the event occurs.\n\n\nThe event can be an \nexternal or internal event\n or a \ntimer\n.\n\n\nThe optional assignment to a variable (or list of variables) stores the\ncarrying value(s) of the event.\n\n\nAn \nevery\n expands to a \nloop\n as illustrated below:\n\n\nevery \nvars\n in \nevent\n do\n    \nbody\n\nend\n\n\n\n\nis equivalent to\n\n\nloop do\n    \nvars\n = await \nevent\n;\n    \nbody\n\nend\n\n\n\n\nHowever, the body of an \nevery\n cannot contain\n\nsynchronous control statements\n, ensuring\nthat no occurrences of the specified event are ever missed.\n\n\nExamples:\n\n\nevery 1s do\n    _printf(\nHello World!\\n\n);      // prints the \nHello World!\n message on every second\nend\n\n\n\n\nevent (bool,int) e;\nvar bool cnd;\nvar int  v;\nevery (cnd,v) in e do\n    if not cnd then\n        break;                      // terminates when the received \ncnd\n is false\n    else\n        _printf(\nv = %d\\n\n, v);     // prints the received \nv\n otherwise\n    end\nend\n\n\n\n\nPool Iterator\n\n\nTODO\n\n\n\n\n\nParallel Compositions\n\n\nPars ::= (par | par/and | par/or) do\n             Block\n         with\n             Block\n         { with\n             Block }\n         end\n\nSpawn ::= spawn [`(\u00b4 [LIST(ID_int)] `)\u00b4] do\n              Block\n          end\n\nWatching ::= watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Code_Cons_Init) do\n                 Block\n             end\n\n\n\n\nThe parallel statements \npar/and\n, \npar/or\n, and \npar\n fork the running trail \nin multiple others.\nThey differ only on how trails rejoin and terminate the composition.\n\n\nThe \nspawn\n statement starts to execute a block in parallel with the enclosing\nblock.\n\n\nThe \nwatching\n statement executes a block and terminates when one of its\nspecified events occur.\n\n\nSee also \nParallel Compositions and Abortion\n.\n\n\npar\n\n\nThe \npar\n statement never rejoins.\n\n\nExamples:\n\n\n// reacts continuously to \n1s\n and \nKEY_PRESSED\n and never terminates\ninput void KEY_PRESSED;\npar do\n    every 1s do\n        \n...\n           // does something every \n1s\n\n    end\nwith\n    every KEY_PRESSED do\n        \n...\n           // does something every \nKEY_PRESSED\n\n    end\nend\n\n\n\n\npar/and\n\n\nThe \npar/and\n statement stands for \nparallel-and\n and rejoins when all nested\ntrails terminate.\n\n\nExamples:\n\n\n// reacts once to \n1s\n and \nKEY_PRESSED\n and terminates\ninput void KEY_PRESSED;\npar/and do\n    await 1s;\n    \n...\n               // does something after \n1s\n\nwith\n    await KEY_PRESSED;\n    \n...\n               // does something after \nKEY_PRESSED\n\nend\n\n\n\n\npar/or\n\n\nThe \npar/or\n statement stands for \nparallel-or\n and rejoins when any of the \ntrails terminate, aborting all other trails.\n\n\nExamples:\n\n\n// reacts once to `1s` or `KEY_PRESSED` and terminates\ninput void KEY_PRESSED;\npar/or do\n    await 1s;\n    \n...\n               // does something after \n1s\n\nwith\n    await KEY_PRESSED;\n    \n...\n               // does something after \nKEY_PRESSED\n\nend\n\n\n\n\nspawn\n\n\nThe \nspawn\n statement starts to execute a block in parallel with the enclosing\nblock.\nWhen the enclosing block terminates, the spawned block is aborted.\n\n\nLike a \ndo-end\n block\n, a \nspawn\n also supports an\noptional list of identifiers in parenthesis which restricts the visible\nvariables inside the block to those matching the list.\n\n\nExamples:\n\n\nspawn do\n    every 1s do\n        \n...\n       // does something every \n1s\n...\n    end\nend\n\n\n...\n               // ...in parallel with whatever comes next\n\n\n\n\nwatching\n\n\nA \nwatching\n expands to a \npar/or\n with \nn+1\n trails:\none to await each of the listed events,\nand one to execute its body, i.e.:\n\n\nwatching \ne1\n,\ne2\n,... do\n    \nbody\n\nend\n\n\n\n\nexpands to\n\n\npar/or do\n    await \ne1\n;\nwith\n    await \ne2\n;\nwith\n    ...\nwith\n    \nbody\n\nend\n\n\n\n\nThe \nwatching\n statement accepts a list of events and terminates when any of\nthem occur.\nIt evaluates to what the occurring event value(s), which can be captured with\nan optional \nassignment\n.\n\n\nExamples:\n\n\n// reacts continuously to \nKEY_PRESSED\n during \n1s\n\ninput void KEY_PRESSED;\nwatching 1s do\n    every KEY_PRESSED do\n        \n...\n           // does something every \nKEY_PRESSED\n\n    end\nend\n\n\n\n\nPausing\n\n\nThe \npause/if\n statement controls if its body should temporarily stop to react\nto events:\n\n\nPause_If ::= pause/if (Loc|ID_ext) do\n                 Block\n             end\n\nPause_Await ::= await (pause|resume)\n\n\n\n\nA \npause/if\n specifies a pausing event of type \nbool\n which, when emitted,\ntoggles between pausing (\ntrue\n) and resuming (\nfalse\n) reactions for its body.\n\n\nWhen its body terminates, the whole \npause/if\n terminates and proceeds to the\nstatement in sequence.\n\n\nIn transition instants, the body can react to the special \npause\n and \nresume\n\nevents before the corresponding state applies.\n\n\nTODO: finalize/pause/resume\n\n\nExamples:\n\n\nevent bool e;\npause/if e do       // pauses/resumes the nested body on each \ne\n\n    every 1s do\n        \n...\n       // does something every \n1s\n\n    end\nend\n\n\n\n\nevent bool e;\npause/if e do               // pauses/resumes the nested body on each \ne\n\n    \n...\n\n        loop do\n            await pause;\n            \n...\n           // does something before pausing\n            await resume;\n            \n...\n           // does something before resuming\n        end\n    \n...\n\nend\n\n\n\n\n\n\n\nAsynchronous Execution\n\n\nAsynchronous execution allow programs to departure from the rigorous\nsynchronous model and preform computations under separate scheduling rules.\n\n\nC\u00e9u supports \nasynchronous blocks\n, \nthreads\n, and\n\ninterrupt service routines\n:\n\n\nAsync  ::= await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nThread ::= await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nIsr ::= spawn async/isr `[\u00b4 LIST(Exp) `]\u00b4 [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\nAtomic ::= atomic do\n               Block\n           end\n\n\n\n\nAsynchronous execution supports \ntight loops\n while\nkeeping the rest of the application, aka the \nsynchronous side\n, reactive to\nincoming events.  However, it does not support any\n\nsynchronous control statement\n (e.g.,\nparallel compositions, event handling, pausing, etc.).\n\n\nBy default, asynchronous bodies do not share variables with their enclosing\nscope, but the optional list of variables makes them visible to the block.\n\n\nEven though asynchronous blocks execute in separate, they are still managed by\nthe program hierarchy and are also subject to lexical scope and abortion.\n\n\n\n\n\nAsynchronous Block\n\n\nAsynchronous blocks, aka \nasyncs\n, intercalate execution with the synchronous\nside as follows:\n\n\n\n\nStart/Resume whenever the synchronous side is idle.\n   When multiple \nasyncs\n are active, they execute in lexical order.\n\n\nSuspend after each \nloop\n iteration.\n\n\nSuspend on every input \nemit\n (see \nSimulation\n).\n\n\nExecute atomically and to completion unless rules \n2\n and \n3\n apply.\n\n\n\n\nThis rules imply that \nasyncs\n never execute with real parallelism with the\nsynchronous side, preserving determinism in the program.\n\n\nExamples:\n\n\n// calculates the factorial of some \nv\n if it doesn't take too long\nvar u64  v   = \n...\n;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async (v,fat) do      // keeps \nv\n and \nfat\n visible\n        loop i in [1 -\n v] do   // reads from \nv\n\n            fat = fat * i;      // writes to \nfat\n\n        end\n    end\n    ok = true;                  // completed within \n1s\n\nend\n\n\n\n\nSimulation\n\n\nAn \nasync\n block can emit \ninput and timer events\n towards the\nsynchronous side, providing a way to test programs in the language itself.\nEvery time an \nasync\n emits an event, it suspends until the synchronous side\nreacts to the event (see \nrule 1\n above).\n\n\nExamples:\n\n\ninput int A;\n\n// tests a program with input simulation in parallel\npar do\n\n    // original program\n    var int v = await A;\n    loop i in [0 -\n _[ do\n        await 10ms;\n        _printf(\nv = %d\\n\n, v+i);\n    end\n\nwith\n\n    // input simulation\n    async do\n        emit A(0);      // initial value for \nv\n\n        emit 1s35ms;    // the loop in the original program executes 103 times\n    end\n    escape 0;\n\nend\n\n// The example prints the message `v = \nv+i\n` exactly 103 times.\n\n\n\n\nThread\n\n\nThreads provide real parallelism for applications in C\u00e9u.\nOnce started, a thread executes completely detached from the synchronous side.\nFor this reason, thread execution is non deterministic and require explicit\n\natomic blocks\n on accesses to variables to avoid race\nconditions.\n\n\nA thread evaluates to a boolean value which indicates whether it started\nsuccessfully or not.\nThe value can be captured with an optional \nassignment\n.\n\n\nExamples:\n\n\n// calculates the factorial of some \nv\n if it doesn't take too long\nvar u64  v   = \n...\n;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async/thread (v,fat) do   // keeps \nv\n and \nfat\n visible\n        loop i in [1 -\n v] do       // reads from \nv\n\n            fat = fat * i;          // writes to \nfat\n\n        end\n    end\n    ok = true;                      // completed within \n1s\n\nend\n\n\n\n\nAsynchronous Interrupt Service Routine\n\n\nTODO\n\n\nAtomic Block\n\n\nAtomic blocks provide mutual exclusion among threads, interrupts, and the\nsynchronous side of application.\nOnce an atomic block starts to execute, no other atomic block in the program\nstarts.\n\n\nExamples:\n\n\n// A \nrace\n between two threads: one incrementing, the other decrementing \ncount\n.\n\nvar s64 count = 0;                              // \ncount\n is a shared variable\npar do\n    every 1s do\n        atomic do\n            _printf(\ncount = %d\\n\n, count);     // prints current value of \ncount\n every \n1s\n\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count - 1;              // decrements \ncount\n as fast as possible\n            end\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count + 1;              // increments \ncount\n as fast as possible\n            end\n        end\n    end\nend\n\n\n\n\nC Integration\n\n\n\n\n\nC\u00e9u provides \nnative declarations\n to import C symbols,\n\nnative blocks\n to define new code in C,\n\nnative statements\n to inline C statements,\n\nnative calls\n to call C functions,\nand \nfinalization\n to deal with C pointers safely:\n\n\nNat_Symbol ::= native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\nNat_Block  ::= native `/\u00b4(pre|pos) do\n                   \ncode definitions in C\n\n               end\nNat_End    ::= native `/\u00b4 end\n\nNat_Stmts  ::= `{\u00b4 {\ncode in C\n | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} `}\u00b4     /* `@@\u00b4 escapes to `@\u00b4 */\n\nNat_Call   ::= [call] (Loc | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\nList_Nat ::= LIST(ID_nat)\n\nFinalization ::= do [Stmt] Finalize\n              |  var `\n?\u00b4 Type ID_int `=\u00b4 `\n\u00b4 (Call_Nat | Call_Code) Finalize\nFinalize ::= finalize `(\u00b4 LIST(Loc) `)\u00b4 with\n                 Block\n             [ pause  with Block ]\n             [ resume with Block ]\n             end\n\n\n\n\nNative calls and statements transfer execution to C, losing the guarantees of\nthe \nsynchronous model\n.\nFor this reason, programs should only resort to C for asynchronous\nfunctionality (e.g., non-blocking I/O) or simple \nstruct\n accessors, but\nnever for control purposes.\n\n\nTODO: Nat_End\n\n\nNative Declaration\n\n\nIn C\u00e9u, any \nidentifier\n prefixed with an\nunderscore is a native symbol defined externally in C.\nHowever, all external symbols must be declared before their first use in a\nprogram.\n\n\nNative declarations support four modifiers as follows:\n\n\n\n\nconst\n: declares the listed symbols as constants.\n    Constants can be used as bounded limits in \nvectors\n,\n    \npools\n, and \nnumeric loops\n.\n    Also, constants cannot be \nassigned\n.\n\n\nplain\n: declares the listed symbols as \nplain\n types, i.e., types (or\n    composite types) that do not contain pointers.\n    A value of a plain type passed as argument to a function does not require\n    \nfinalization\n.\n\n\nnohold\n: declares the listed symbols as \nnon-holding\n functions, i.e.,\n    functions that do not retain received pointers after returning.\n    Pointers passed to non-holding functions do not require\n    \nfinalization\n.\n\n\npure\n: declares the listed symbols as pure functions.\n    In addition to the \nnohold\n properties, pure functions never allocate\n    resources that require \nfinalization\n\n    and have no side effects to take into account for the \nsafety checks\n.\n\n\n\n\nExamples:\n\n\n// values\nnative/const  _LOW, _HIGH;      // Arduino \nLOW\n and \nHIGH\n are constants\nnative        _errno;           // POSIX \nerrno\n is a global variable\n\n// types\nnative/plain  _char;            // \nchar\n is a \nplain\n type\nnative        _SDL_PixelFormat; // SDL \nSDL_PixelFormat\n is a type holding a pointer\n\n// functions\nnative        _uv_read_start;   // Libuv \nuv_read_start\n retains the received pointer\nnative/nohold _free;            // POSIX \nfree\n receives a pointer but does not retain it\nnative/pure   _strlen;          // POSIX \nstrlen\n is a \npure\n function\n\n\n\n\nNative Block\n\n\nA native block allows programs to define new external symbols in C.\n\n\nThe contents of native blocks is copied unchanged to the output in C depending\non the modifier specified:\n\n\n\n\npre\n: code is placed before the declarations for the C\u00e9u program.\n    Symbols defined in \npre\n blocks are visible to C\u00e9u.\n\n\npos\n: code is placed after the declarations for the C\u00e9u program.\n    Symbols implicitly defined by the compiler of C\u00e9u are visible to \npos\n\n    blocks.\n\n\n\n\nNative blocks are copied in the order they appear in the source code.\n\n\nSince C\u00e9u uses the \nC preprocessor\n, hash\ndirectives \n#\n inside native blocks must be quoted as \n##\n to be considered\nonly in the C compilation phase.\n\n\nIf the code in C contains the terminating \nend\n keyword of C\u00e9u, the \nnative\n\nblock should be delimited with matching comments to avoid confusing the parser:\n\n\nSymbols defined in native blocks still need to be\n\ndeclared\n for use in the program.\n\n\nExamples:\n\n\nnative/plain _t;\nnative/pre do\n    typedef int t;              // definition for \nt\n is placed before C\u00e9u declarations\nend\nvar _t x = 10;                  // requires \nt\n to be already defined\n\n\n\n\ninput void A;                   // declaration for \nA\n is placed before \npos\n blocks\nnative _get_A_id;\nnative/pos do\n    int get_A_id (void) {\n        return CEU_INPUT_A;     // requires \nA\n to be already declared\n    }\nend\n\n\n\n\nnative/nohold _printf;\nnative/pre do\n    ##include \nstdio.h\n         // include the relevant header for \nprintf\n\nend\n\n\n\n\nnative/pos do\n    /******/\n    char str = \nThis `end` confuses the parser\n;\n    /******/\nend\n\n\n\n\nNative Statement\n\n\nThe contents of native statements in between \n{\n and \n}\n are inlined in the\nprogram.\n\n\nNative statements support interpolation of expressions in C\u00e9u which are\nexpanded when preceded by the symbol \n@\n.\n\n\nExamples:\n\n\nvar int v_ceu = 10;\n{\n    int v_c = @v_ceu * 2;       // yields 20\n}\nv_ceu = { v_c + @v_ceu };       // yields 30\n{\n    printf(\n%d\\n\n, @v_ceu);     // prints 30\n}\n\n\n\n\nNative Call\n\n\nExpressions that evaluate to a \nnative type\n can be called\nfrom C\u00e9u.\n\n\nIf a call passes or returns pointers, it may require an accompanying\n\nfinalization statement\n.\n\n\nExamples:\n\n\n// all expressions below evaluate to a native type and can be called\n\n_printf(\nHello World!\\n\n);\n\nvar _t f = \n...\n;\nf();\n\nvar _s s = \n...\n;\ns.f();\n\n\n\n\n\n\n\nResources \n Finalization\n\n\nA finalization statement unconditionally executes a series of statements when\nits associated block terminates or is aborted.\n\n\nC\u00e9u tracks the interaction of native calls with pointers and requires \n\nfinalize\n clauses to accompany the calls:\n\n\n\n\nIf C\u00e9u \npasses\n a pointer to a native call, the pointer represents a\n  \nlocal resource\n that requires finalization.\n  Finalization executes when the block of the local resource goes out of scope.\n\n\nIf C\u00e9u \nreceives\n a pointer from a native call return, the pointer\n  represents an \nexternal resource\n that requires finalization.\n  Finalization executes when the block of the receiving pointer goes out of\n  scope.\n\n\n\n\nIn both cases, the program does not compile without the \nfinalize\n statement.\n\n\nA \nfinalize\n cannot contain\n\nsynchronous control statements\n.\n\n\nExamples:\n\n\n// Local resource finalization\nwatching \n...\n do\n    var _buffer_t msg;\n    \n...\n                       // prepares msg\n    do\n        _send_request(\nmsg);\n    finalize with\n        _send_cancel(\nmsg);\n    end\n    await SEND_ACK;             // transmission is complete\nend\n\n\n\n\nIn the example above, the local variable \nmsg\n is an internal resource passed\nas a pointer to \n_send_request\n, which is an asynchronous call that transmits\nthe buffer in the background.\nIf the enclosing \nwatching\n aborts before awaking from the \nawait SEND_ACK\n,\nthe local \nmsg\n goes out of scope and the external transmission would hold a\n\ndangling pointer\n.\nThe \nfinalize\n ensures that \n_send_cancel\n also aborts the transmission.\n\n\n// External resource finalization\nwatching \n...\n do\n    var\n? _FILE f = \n_fopen(\n...\n) finalize with\n                        _fclose(f);\n                    end;\n    _fwrite(\n...\n, f);\n    await A;\n    _fwrite(\n...\n, f);\nend\n\n\n\n\nIn the example above, the call to \n_fopen\n returns an external file resource as\na pointer.\nIf the enclosing \nwatching\n aborts before awaking from the \nawait A\n, the file\nwould remain open as a \nmemory leak\n.\nThe \nfinalize\n ensures that \n_fclose\n closes the file properly.\n\n\nTo access an external resource from C\u00e9u requires an\n\nalias assignment\n to a\n\nvariable alias\n.\nIf the external call returns \nNULL\n and the variable is an option alias\n\nvar\n?\n, the alias remains unbounded.\nIf the variable is an alias \nvar\n, the assigment raises a runtime error.\n\n\nNote: the compiler only forces the programmer to write finalization clauses,\n       but cannot check if they handle the resource properly.\n\n\nDeclaration\n and \nexpression\n\nmodifiers may suppress the requirement for finalization in calls:\n\n\n\n\nnohold\n modifiers or \n/nohold\n typecasts make passing pointers safe.\n\n\npure\n   modifiers or \n/pure\n   typecasts make passing pointers and returning\n                                  pointers safe.\n\n\n/plain\n typecasts make return values safe.\n\n\n\n\nExamples:\n\n\n// \n_free\n does not retain \nptr\n\nnative/nohold _free;\n_free(ptr);\n// or\n(_free as /nohold)(ptr);\n\n\n\n\n// \n_strchr\n does retain \nptr\n or allocates resources\nnative/pure _strchr;\nvar _char\n found = _strchr(ptr);\n// or\nvar _char\n found = (_strchr as /pure)(ptr);\n\n\n\n\n// \n_f\n returns a non-pointer type\nvar _tp v = _f() as /plain;\n\n\n\n\nLua Integration\n\n\nC\u00e9u provides \nLua states\n to delimit the effects of inlined\n\nLua statements\n:\n\n\nLua_State ::= lua `[\u00b4 [Exp] `]\u00b4 do\n                 Block\n              end\nLua_Stmts ::= `[\u00b4 {`=\u00b4} `[\u00b4\n                  { {\ncode in Lua\n | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} }   /* `@@\u00b4 escapes to `@\u00b4 */\n              `]\u00b4 {`=\u00b4} `]\u00b4\n\n\n\n\nLua statements transfer execution to Lua, losing the guarantees of the\n\nsynchronous model\n.\nFor this reason, programs should only resort to C for asynchronous\nfunctionality (e.g., non-blocking I/O) or simple \nstruct\n accessors, but\nnever for control purposes.\n\n\nAll programs have an implicit enclosing \nglobal Lua state\n which all orphan\nstatements apply.\n\n\nLua State\n\n\nA Lua state creates an isolated state for inlined\n\nLua statements\n.\n\n\nExample:\n\n\n// \nv\n is not shared between the two statements\npar do\n    // global Lua state\n    [[ v = 0 ]];\n    var int v = 0;\n    every 1s do\n        [[print('Lua 1', v, @v) ]];\n        v = v + 1;\n        [[ v = v + 1 ]];\n    end\nwith\n    // local Lua state\n    lua[] do\n        [[ v = 0 ]];\n        var int v = 0;\n        every 1s do\n            [[print('Lua 2', v, @v) ]];\n            v = v + 1;\n            [[ v = v + 1 ]];\n        end\n    end\nend\n\n\n\n\nTODO: dynamic scope, assignment/error, [dim]\n\n\nLua Statement\n\n\nThe contents of Lua statements in between \n[[\n and \n]]\n are inlined in the\nprogram.\n\n\nLike \nnative statements\n, Lua statements support\ninterpolation of expressions in C\u00e9u which are expanded when preceded by a \n@\n.\n\n\nLua statements only affect the \nLua state\n in which they are embedded.\n\n\nIf a Lua statement is used in an \nassignment\n, it is evaluated as\nan expression that either satisfies the destination or generates a runtime\nerror.\nThe list that follows specifies the \nC\u00e9u destination\n and expected\n\nLua source\n:\n\n\n\n\na \nvar\n \nbool\n                            expects a \nboolean\n\n\na \nnumeric\n \nvar\n   expects a \nnumber\n\n\na pointer \nvar\n                           expects a \nlightuserdata\n\n\na \nvector\n \nbyte\n                         expects a \nstring\n\n\n\n\nTODO: lua state captures errors\n\n\nExamples:\n\n\nvar int v_ceu = 10;\n[[\n    v_lua = @v_ceu * 2          -- yields 20\n]]\nv_ceu = [[ v_lua + @v_ceu ]];   // yields 30\n[[\n    print(@v_ceu)               -- prints 30\n]]\n\n\n\n\nAbstractions\n\n\nC\u00e9u supports reuse with \ndata\n declarations to define new types, and \ncode\n\ndeclarations to define new subprograms.\n\n\nDeclarations are subject to \nlexical scope\n.\n\n\nData\n\n\nA \ndata\n declaration creates a new data type:\n\n\nData ::= data ID_abs [as (nothing|Exp)] [ with\n             (Var|Vec|Pool|Int) `;\u00b4 {`;\u00b4}\n             { (Var|Vec|Pool|Int) `;\u00b4 {`;\u00b4} }\n         end\n\nData_Cons ::= (val|new) Abs_Cons\nAbs_Cons  ::= [Loc `.\u00b4] ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`nil\u00b4|`_\u00b4) `)\u00b4\n\n\n\n\nA declaration may pack fields with\n\nstorage declarations\n which become publicly\naccessible in the new type.\nField declarations may \nassign\n default values for\nuninitialized instances.\n\n\nData types can form hierarchies using dots (\n.\n) in identifiers:\n\n\n\n\nAn isolated identifier such as \nA\n makes \nA\n a base type.\n\n\nA dotted identifier such as \nA.B\n makes \nA.B\n a subtype of its supertype \nA\n.\n\n\n\n\nA subtype inherits all fields from its supertype.\n\n\nThe optional modifier \nas\n expects the keyword \nnothing\n or a constant\nexpression of type \nint\n:\n\n\n\n\nnothing\n: the \ndata\n cannot be instantiated.\n\n\nconstant expression\n: \ntypecasting\n a value of\n                         the type to \nint\n evaluates to the specified\n                         enumeration expression.\n\n\n\n\nExamples:\n\n\ndata Rect with\n    var int x, y, h, w;\n    var int z = 0;\nend\nvar Rect r = val Rect(10,10, 100,100, _);  // \nr.z\n defaults to 0\n\n\n\n\ndata Dir       as nothing;  // \nDir\n is a base type and cannot be intantiated\ndata Dir.Right as  1;       // \nDir.Right\n is a subtype of \nDir\n\ndata Dir.Left  as -1;       // \nDir.Left\n  is a subtype of \nDir\n\nvar  Dir dir = \n...\n;       // receives one of \nDir.Right\n or \nDir.Left\n\nescape (dir as int);        // returns 1 or -1\n\n\n\n\nTODO: new, pool, recursive types\n\n\nData Constructor\n\n\nA new static value constructor is created in the contexts as follows:\n\n\n\n\nPrefixed by the keyword \nval\n in an \nassignment\n to a variable.\n\n\nAs an argument to a \ncode\n invocation\n.\n\n\nNested as an argument in a \ndata\n creation (i.e., a \ndata\n that contains\n  another \ndata\n).\n\n\n\n\nIn all cases, the arguments are copied to a destination with static storage.\nThe destination must be a plain declaration (i.e., not an alias or pointer).\n\n\nThe constructor uses the \ndata\n identifier followed by a list of arguments\nmatching the fields of the type.\n\n\nVariables of the exact same type can be copied in \nassignments\n.\n\n\nFor assignments from a subtype to a supertype, the rules are as follows:\n\n\n\n\nCopy assignments\n\n\nplain values: only if the subtype contains no extra fields\n\n\npointers: allowed\n\n\n\n\n\n\nAlias assignment\n: allowed.\n\n\n\n\ndata Object with\n    var Rect rect;\n    var Dir  dir;\nend\nvar Object o1 = val Object(Rect(0,0,10,10,_), Dir.Right());\n\n\n\n\nvar Object o2 = o1;         // makes a deep copy of all fields from \no1\n to \no2\n\n\n\n\n\nCode\n\n\nThe \ncode/tight\n and \ncode/await\n declarations specify new subprograms that can\nbe invoked from arbitrary points in programs:\n\n\n// prototype declaration\nCode_Tight ::= code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `-\n\u00b4 Type\nCode_Await ::= code/await Mods ID_abs `(\u00b4 Params `)\u00b4 [`-\n\u00b4 `(\u00b4 Params `)\u00b4] `-\n\u00b4 (Type | FOREVER)\nParams ::= void | LIST(Var|Vec|Pool|Int)\n\n// full declaration\nCode_Impl ::= (Code_Tight | Code_Await) do\n                  Block\n              end\n\n// invocation\nCode_Call  ::= call  Mods Abs_Cons\nCode_Await ::= await Mods Abs_Cons\nCode_Spawn ::= spawn Mods Abs_Cons [in Loc]\n\nMods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n\n\n\n\nA \ncode/tight\n is a subprogram that cannot contain\n\nsynchronous control statements\n and runs to\ncompletion in the current \ninternal reaction\n.\n\n\nA \ncode/await\n is a subprogram with no restrictions (e.g., it can manipulate\nevents and use parallel compositions) and its execution may outlive multiple\nreactions.\n\n\nA \nprototype declaration\n specifies the interface parameters of the\nabstraction which invocations must satisfy.\nA \nfull declaration\n (aka \ndefinition\n) also specifies an implementation\nwith a block of code.\nAn \ninvocation\n specifies the name of the code abstraction and arguments\nmatching its declaration.\n\n\nTo support recursive abstractions, a code invocation can appear before the\nimplementation is known, but after the prototype declaration.\nIn this case, the declaration must use the modifier \n/recursive\n.\n\n\nExamples:\n\n\ncode/tight Absolute (var int v) -\n int do   // declares the prototype for \nAbsolute\n\n    if v \n 0 then                           // implements the behavior\n        escape  v;\n    else\n        escape -v;\n    end\nend\nvar int abs = call Absolute(-10);           // invokes \nAbsolute\n (yields 10)\n\n\n\n\ncode/await Hello_World (void) -\n FOREVER do\n    every 1s do\n        _printf(\nHello World!\\n\n);  // prints \nHello World!\n every second\n    end\nend\nawait Hello_World();                // never awakes\n\n\n\n\ncode/tight/recursive Fat (var int v) -\n int;    // \nFat\n is a recursive code\ncode/tight/recursive Fat (var int v) -\n int do\n    if v \n 1 then\n        escape v * (call/recursive Fat(v-1));   // recursive invocation before full declaration\n    else\n        escape 1;\n    end\nend\nvar int fat = call/recursive Fat(10);           // invokes \nFat\n (yields 3628800)\n\n\n\n\nTODO: hold\n\n\nCode Declaration\n\n\nCode abstractions specify a list of input parameters in between the symbols\n\n(\n and \n)\n.\nEach parameter specifies an \nentity class\n\nwith modifiers, a type and an identifier.\nA \nvoid\n list specifies that the abstraction has no parameters.\n\n\nCode abstractions also specify an output return type.\nA \ncode/await\n may use \nFOREVER\n as output to indicate that it never returns.\n\n\nA \ncode/await\n may also specify an optional \npublic parameter list\n, which are\nlocal storage entities living the outermost scope of the abstraction body.\nThese entities are visible to the invoking context which may access them while\nthe abstraction executes.\n\n\n\n\n\nCode Invocation\n\n\nA \ncode/tight\n is invoked with the keyword \ncall\n followed by the abstraction\nname and list of arguments.\nA \ncode/await\n is invoked with the keywords \nawait\n or \nspawn\n followed by the\nabstraction name and list of arguments.\n\n\nThe list of arguments must satisfy the list of parameters in the\n\ncode declaration\n.\n\n\nThe \ncall\n and \nawait\n invocations suspend the current trail and transfer\ncontrol to the code abstraction.\nThe invoking point only resumes after the abstraction terminates and evaluates\nto a value of its return type which can be captured with an optional\n\nassignment\n.\n\n\nThe \nspawn\n invocation also suspends and transfers control to the code\nabstraction.\nHowever, when the abstraction becomes idle (or terminates), the invoking point\nresumes.\nThis makes the invocation point and a non-terminating abstraction to execute\nconcurrently.\n\n\n\n\n\nThe \nspawn\n invocation also accepts an optional \npool\n which provides\nstorage and scope for invoked abstractions.\n\n\nIf the \nspawn\n provides the pool, the invocation evaluates to a boolean that\nindicates whether the pool has space to execute the code.\nThe result can be captured with an optional \nassignment\n.\nIf the pool goes out of scope, all invoked abstractions residing in that pool\nare aborted.\n\n\nIf the \nspawn\n omits the pool, the invocation always succeed and has the same\nscope as the invoking point: when the enclosing block terminates, the invoked\ncode is also aborted.\n\n\nDynamic Dispatching\n\n\nC\u00e9u supports dynamic code dispatching based on multiple parameters.\n\n\nThe modifier \n/dynamic\n in a declaration specifies that the code is dynamically\ndispatched.\nA dynamic code must have at least one \ndynamic\n parameter.\nAlso, all dynamic parameters must be pointers or aliases to a\n\ndata type\n in some hierarchy.\n\n\nA dynamic declaration requires other compatible dynamic declarations with the\nsame name, modifiers, parameters, and return type.\nThe exceptions are the \ndynamic\n parameters, which must be in the same\nhierarchy of their corresponding parameters in other declarations.\n\n\nTo determine which declaration to execute during runtime, the actual argument\nruntime type is checked against the first formal \ndynamic\n parameter of each\ndeclaration.\nThe declaration with the most specific type matching the argument wins.\nIn the case of a tie, the next dynamic parameter is checked.\n\n\nA \ncatchall\n declaration with the most general dynamic types must always be\nprovided.\n\n\nIf the argument is explicitly \ntypecast\n to a\nsupertype, then dispatching considers that type instead.\n\n\nExample:\n\n\ndata Media as nothing;\ndata Media.Audio     with \n...\n end\ndata Media.Video     with \n...\n end\ndata Media.Video.Avi with \n...\n end\n\ncode/await/dynamic Play (dynamic var\n Media media) -\n void do\n    _assert(0);             // never dispatched\nend\ncode/await/dynamic Play (dynamic var\n Media.Audio media) -\n void do\n    \n...\n                   // plays an audio\nend\ncode/await/dynamic Play (dynamic var\n Media.Video media) -\n void do\n    \n...\n                   // plays a video\nend\ncode/await/dynamic Play (dynamic var\n Media.Video.Avi media) -\n void do\n    \n...\n                                   // prepare the avi video\n    await/dynamic Play(\nm as Media.Video);  // dispatches the supertype\nend\n\nvar\n Media m = \n...\n;       // receives one of \nMedia.Audio\n or \nMedia.Video\n\nawait/dynamic Play(\nm);     // dispatches the appropriate subprogram to play the media\n\n\n\n\nSynchronous Control Statements\n\n\nThe \nsynchronous control statements\n which follow cannot appear in\n\nevent iterators\n,\n\npool iterators\n,\n\nasynchronous execution\n,\n\nfinalization\n,\nand\n\ntight code abstractions\n:\n\nawait\n, \nspawn\n, \nemit\n (internal events), \nevery\n, \nfinalize\n, \npause/if\n,\n\npar\n, \npar/and\n, \npar/or\n, and \nwatching\n.\n\n\nAs exceptions, an \nevery\n can \nemit\n internal events, and a \ncode/tight\n can\ncontain empty \nfinalize\n statements.", 
            "title": "Statements"
        }, 
        {
            "location": "/statements/#statements", 
            "text": "A program in C\u00e9u is a sequence of statements delimited by an implicit enclosing\nblock:  Program ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}  Note: statements terminated with the  end  keyword do not require a\nterminating semicolon.", 
            "title": "Statements"
        }, 
        {
            "location": "/statements/#nothing", 
            "text": "nothing  is an innocuous statement:  Nothing ::= nothing", 
            "title": "Nothing"
        }, 
        {
            "location": "/statements/#blocks", 
            "text": "A  Block  creates a new lexical scope for storage entities \nand abstractions ,\nwhich are visible only for statements inside the block.  Compound statements (e.g.  do-end ,  if-then-else ,  loops , etc.) create new\nblocks and can be nested to an arbitrary level.", 
            "title": "Blocks"
        }, 
        {
            "location": "/statements/#do-end-and-escape", 
            "text": "The  do-end  statement creates an explicit block with an optional identifier\nfollowing the symbol  / .\nThe  escape  statement aborts the deepest enclosing  do-end  matching its\nidentifier:  Do ::= do [`/\u00b4(ID_int|`_\u00b4)] [`(\u00b4 [LIST(ID_int)] `)\u00b4]\n           Block\n       end\n\nEscape ::= escape [`/\u00b4ID_int] [Exp]  The neutral identifier  _  which is guaranteed not to match any  escape \nstatement.  A  do-end  also supports an optional list of identifiers in parenthesis which\nrestricts the visible variables inside the block to those matching the list.  A  do-end  can be  assigned  to a variable whose type must be\nmatched by nested  escape  statements.\nThe whole block evaluates to the value of a reached  escape .\nIf the variable is of  option type , the  do-end  is allowed\nto terminate without an  escape , otherwise it raises a runtime error.  Programs have an implicit enclosing  do-end  that assigns to a program status variable  of type  int  whose meaning is platform dependent.  Examples:  do\n    do/a\n        do/_\n            escape;     // matches line 1\n        end\n        escape/a;       // matches line 2\n    end\nend  var int a;\nvar int b;\ndo (a)\n    a = 1;\n    b = 2;  //  b  is not visible\nend\n\n```ceu\nvar int? v =\n    do\n        if  cnd  then\n            escape 10;  // assigns 10 to  v \n        else\n            nothing;    //  v  remains unassigned\n        end\n    end;  escape 0;               // program terminates with a status value of 0", 
            "title": "do-end and escape"
        }, 
        {
            "location": "/statements/#pre-do-end", 
            "text": "The  pre-do-end  statement prepends its statements in the beginning of the\nprogram:  Pre_Do ::= pre do\n               Block\n           end  All  pre-do-end  statements are concatenated together in the order they appear\nand moved to the beginning of the top-level block, before all other statements.", 
            "title": "pre-do-end"
        }, 
        {
            "location": "/statements/#declarations", 
            "text": "A declaration introduces a  storage entity \nto the enclosing block.\nAll declarations are subject to  lexical scope .  C\u00e9u supports variables, vectors, pools, internal events, and external events:  \nVar  ::= var [` \u00b4|` ?\u00b4] [`/dynamic\u00b4|`/nohold\u00b4] Type ID_int [`=\u00b4 Sources]\nVec  ::= vector [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\nPool ::= pool [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\nInt  ::= event [` \u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_int [`=\u00b4 Sources]\n\nExt  ::= input  (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_ext\n      |  output (Type | `(\u00b4 LIST([` \u00b4] Type) `)\u00b4) ID_ext\n\nSources ::= /* (see  Assignments ) */  Most declarations support an initialization  assignment .", 
            "title": "Declarations"
        }, 
        {
            "location": "/statements/#variables", 
            "text": "A  variable  declaration has an associated type  and can be optionally  initialized .\nDeclarations can also be aliases or option aliases .  Examples:  var  int v = 10;    //  v  is an integer variable initialized to 10\nvar  int a=0, b=3;  //  a  and  b  are integer variables initialized to 0 and 3\nvar  int z =  v;    //  z  is an alias to  v", 
            "title": "Variables"
        }, 
        {
            "location": "/statements/#vectors", 
            "text": "A  vector  declaration specifies a dimension  between brackets,\nan associated  type  and can be optionally initialized .\nDeclarations can also be  aliases .   Examples:  var int n = 10;\nvector[10] int vs1 = [];    //  vs1  is a static vector of 10 elements max\nvector[n]  int vs2 = [];    //  vs2  is a dynamic vector of 10 elements max\nvector[]   int vs3 = [];    //  vs3  is an unbounded vector\nvector []  int vs4 =  vs1;  //  vs4  is an alias to  vs1", 
            "title": "Vectors"
        }, 
        {
            "location": "/statements/#pools", 
            "text": "A  pool  declaration specifies a dimension and an\nassociated  type .\nDeclarations for pools can also be  aliases .\nOnly in this case they can be  initialized .  The expression between the brackets specifies the  dimension  of\nthe pool.  Examples:  code/await Play (...) do ... end\npool[10] Play plays;        //  plays  is a static pool of 10 elements max\npool []  Play a =  plays;   //  a  is an alias to  plays    TODO: data", 
            "title": "Pools"
        }, 
        {
            "location": "/statements/#dimension", 
            "text": "Declarations for  vectors  or  pools  require an expression\nbetween brackets to specify a dimension as follows:   constant expression : Maximum number of elements is fixed and space is\n                         statically pre-allocated.  variable expression : Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.  omitted : Maximum number of elements is unbounded and space is dynamically\n             allocated.\n             The space for dynamic dimensions grow and shrink automatically.", 
            "title": "Dimension"
        }, 
        {
            "location": "/statements/#events", 
            "text": "An  event  declaration specifies a type  for the values it carries when occurring.\nIt can be also a list of types if the event communicates multiple values.", 
            "title": "Events"
        }, 
        {
            "location": "/statements/#external-events", 
            "text": "Examples:  input  void A,B;        //  A  and  B  are input events carrying no values\noutput int  MY_EVT;     //  MY_EVT  is an output event carrying integer values\ninput (int,byte ) BUF; //  BUF  is an input event carrying an  (int,byte )  pair  TODO: output", 
            "title": "External Events"
        }, 
        {
            "location": "/statements/#internal-events", 
            "text": "Declarations for internal events can also be aliases .\nOnly in this case they can be  initialized .  Examples:  event  void a,b;        //  a  and  b  are internal events carrying no values\nevent  void z =  a;     //  z  is an alias to event  a \nevent (int,int) c;      //  c  is a internal event carrying an  (int,int)  pair", 
            "title": "Internal Events"
        }, 
        {
            "location": "/statements/#assignments", 
            "text": "An assignment associates the statement or expression at the right side of the\nsymbol  =  with the  location(s)  at the left side:  Assignment ::= (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Sources\n\nSources ::= ( Do\n            | Emit_Ext\n            | Await\n            | Watching\n            | Thread\n            | Lua_State\n            | Lua_Stmts\n            | Code_Await\n            | Code_Spawn\n            | Vec_Cons\n            | Data_Cons\n            | Exp\n            | `nil\u00b4\n            | `_\u00b4 )  C\u00e9u supports the following constructs as assignment sources:   do-end  block  external emit  await  watching statement  thread  lua state  lua statement  code await  code spawn  vector  length     constructor  data constructor  expression  the  option   nil  value  the anonymous identifier  _   The option  nil  value unsets an  option variable .  The anonymous identifier makes the assignment innocuous.  TODO: required for uninitialized variables", 
            "title": "Assignments"
        }, 
        {
            "location": "/statements/#copy-assignment", 
            "text": "A  copy assignment  evaluates the statement or expression at the right side and\ncopies the result(s) to the location(s) at the left side.", 
            "title": "Copy Assignment"
        }, 
        {
            "location": "/statements/#alias-assignment", 
            "text": "An  alias assignment , aka  binding , makes the location at the left side to be\nan  alias  to the expression at the right side.  The right side of a binding is always prefixed by the operator  .", 
            "title": "Alias Assignment"
        }, 
        {
            "location": "/statements/#event-handling", 
            "text": "", 
            "title": "Event Handling"
        }, 
        {
            "location": "/statements/#await", 
            "text": "The  await  statement halts the running trail until the specified event occurs.\nThe event can be an  input event , an internal event , a timer, a pausing event , or forever (i.e., never awakes):  Await ::= await (ID_ext | Loc) [until Exp]      /* events and option aliases */\n       |  await (WCLOCKK|WCLOCKE)               /* timers */\n       |  await (pause|resume)                  /* pausing events */\n       |  await FOREVER                         /* forever */  Examples:  await A;                  // awaits the input event  A \nawait a until v==10;      // awaits the internal event  a  until the condition is satisfied\n\nawait 1min10s30ms100us;   // awaits the specified time\nawait (t)ms;              // awaits the current value of the variable  t  in milliseconds\n\nawait FOREVER;            // awaits forever  An  await  evaluates to zero or more values which can be captured with an\noptional  assignment .", 
            "title": "Await"
        }, 
        {
            "location": "/statements/#event", 
            "text": "The  await  statement for events halts the running trail until the specified input event  or internal event  occurs.\nThe  await  evaluates to a value of the type of the event.  The optional clause  until  tests an awaking condition.\nThe condition can use the returned value from the  await .\nIt expands to a  loop  as follows:  loop do\n     ret  = await  evt ;\n    if  Exp  then   //  Exp  can use  ret \n        break;\n    end\nend  Examples:  input int E;                    //  E  is an input event carrying  int  values\nvar int v = await E until v 10; // assigns occurring  E  to  v , awaking only when  v 10 \n\nevent (bool,int) e;             //  e  is an internal event carrying  (bool,int)  pairs\nvar bool v1;\nvar int  v2;\n(v1,v2) = await e;              // awakes on  e  and assigns its values to  v1  and  v2", 
            "title": "Event"
        }, 
        {
            "location": "/statements/#option-alias", 
            "text": "The  await  statement for  option variable aliases \nhalts the running trail until the specified alias goes out of scope.  The  await  evaluates to no value.  Example:  var ? int x;\nspawn Code() -  ( x);   //  x  is bounded to a variable inside  Code \nawait x;                // awakes when the spawned  Code  terminates", 
            "title": "Option Alias"
        }, 
        {
            "location": "/statements/#timer", 
            "text": "The  await  statement for timers halts the running trail until the specified\ntimer expires:   WCLOCKK  specifies a constant timer expressed as a sequence of value/unit\n  pairs.  WCLOCKE  specifies an  integer  expression in\n  parenthesis followed by a single unit of time.   The  await  evaluates to a value of type  s32  and is the residual delta time ( dt )  measured in microseconds:\n    the difference between the actual elapsed time and the requested time.\nThe residual  dt  is always greater than or equal to 0.  If a program awaits timers in sequence (or in a  loop ), the residual  dt  from\nthe preceding timer is reduced from the timer in sequence.  Examples:  var int t =  ... ;\nawait (t)ms;                // awakes after  t  milliseconds  var int dt = await 100us;   // if 1000us elapses, then dt=900us (1000-100)\nawait 100us;                // since dt=900, this timer is also expired, now dt=800us (900-100)\nawait 1ms;                  // this timer only awaits 200us (1000-800)", 
            "title": "Timer"
        }, 
        {
            "location": "/statements/#pausing", 
            "text": "Pausing events are dicussed in  Pausing .", 
            "title": "Pausing"
        }, 
        {
            "location": "/statements/#forever", 
            "text": "The  await  statement for  FOREVER  halts the running trail forever.\nIt cannot be used in assignments because it never evaluates to anything.  Example:  if v==10 then\n    await FOREVER;  // this trail never awakes if condition is true\nend", 
            "title": "FOREVER"
        }, 
        {
            "location": "/statements/#emit", 
            "text": "The  emit  statement broadcasts an event to the whole program.\nThe event can be an  external event , an internal event , or a timer:  Emit_Int ::= emit Loc [`(\u00b4 [LIST(Exp)] `)\u00b4]\nEmit_Ext ::= emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n          |  emit (WCLOCKK|WCLOCKE)  Examples:  emit A;         // emits the output event `A` of type  void \nemit a(1);      // emits the internal event `a` of type  int \n\nemit 1s;        // emits the specified time\nemit (t)ms;     // emits the current value of the variable `t` in milliseconds", 
            "title": "Emit"
        }, 
        {
            "location": "/statements/#events_1", 
            "text": "The  emit  statement for events expects the arguments to match the event type.  An  emit  to an input or timer event can only occur inside asynchronous blocks .  An  emit  to an output event is also an expression that evaluates to a value of\ntype  s32  and can be captured with an optional  assignment  (its\nmeaning is platform dependent).  An  emit  to an internal event starts a new internal reaction .  Examples:  input int I;\nasync do\n    emit I(10);         // broadcasts  I  to the application itself, passing  10 \nend\n\noutput void O;\nvar int ret = emit O(); // outputs  O  to the environment and captures the result\n\nevent (int,int) e;\nemit e(1,2);            // broadcasts  e  passing a pair of  int  values", 
            "title": "Events"
        }, 
        {
            "location": "/statements/#timer_1", 
            "text": "The  emit  statement for timers expects a  timer expression .  Like input events, time can only be emitted inside  asynchronous \nblocks .  Examples:  async do\n    emit 1s;    // broadcasts  1s  to the application itself\nend", 
            "title": "Timer"
        }, 
        {
            "location": "/statements/#lock", 
            "text": "TODO", 
            "title": "Lock"
        }, 
        {
            "location": "/statements/#conditional", 
            "text": "The  if-then-else  statement provides conditional execution in C\u00e9u:  If ::= if Exp then\n           Block\n       { else/if Exp then\n           Block }\n       [ else\n           Block ]\n       end  Each condition  Exp  is tested in sequence, first for the  if  clause and then\nfor each of the optional  else/if  clauses.\nOn the first condition that evaluates to  true , the  Block  following it\nexecutes.\nIf all conditions fail, the optional  else  clause executes.  All conditions must evaluate to a value of type  bool .", 
            "title": "Conditional"
        }, 
        {
            "location": "/statements/#loops", 
            "text": "C\u00e9u supports simple loops, numeric iterators, event iterators, and pool\niterators:  Loop ::=\n      /* simple loop */\n        loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] Numeric do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n            Block\n        end\n\nBreak    ::= break [`/\u00b4ID_int]\nContinue ::= continue [`/\u00b4ID_int]\n\nNumeric ::= /* (see  Numeric Iterators ) */  The body of a loop  Block  executes an arbitrary number of times, depending on\nthe conditions imposed by each kind of loop.  Except for the  every  iterator, all loops support an optional constant\nexpression  / Exp  that limits the maximum number of\niterations to avoid  infinite execution .\nIf the number of iterations reaches the limit, a runtime error occurs.", 
            "title": "Loops"
        }, 
        {
            "location": "/statements/#break-and-continue", 
            "text": "The  break  statement aborts the deepest enclosing loop.  The  continue  statement aborts the body of the deepest enclosing loop and\nrestarts it in the next iteration.  The optional modifier  / ID_int  in both statements\nonly applies to  numeric iterators .", 
            "title": "break and continue"
        }, 
        {
            "location": "/statements/#simple-loop", 
            "text": "The simple  loop-do-end  statement executes its body forever.\nThe only way to terminate a simple loop is with the  break  statement.  Examples:  // blinks a LED with a frequency of 1s forever\nloop do\n    emit LED(1);\n    await 1s;\n    emit LED(0);\n    await 1s;\nend  loop do\n    loop do\n        if  cnd-1  then\n            break;      // aborts the loop at line 2 if  cnd-1  is satisfied\n        end\n    end\n    if  cnd-2  then\n        continue;       // restarts the loop at line 1 if  cnd-2  is satisfied\n    end\nend", 
            "title": "Simple Loop"
        }, 
        {
            "location": "/statements/#numeric-iterator", 
            "text": "The numeric loop executes its body a fixed number of times based on a numeric\nrange for a control variable:  Numeric ::= (`_\u00b4|ID_int) in [ (`[\u00b4 | `]\u00b4)\n                                  ( (     Exp `- \u00b4 (`_\u00b4|Exp))\n                                  | (`_\u00b4|Exp) ` -\u00b4 Exp      ) )\n                              (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp] ]  The control variable assumes the values specified in the interval, one by one,\nfor each iteration of the loop body:   control variable: \n     ID_int  is a read-only variable of a  numeric type .\n    Alternatively, the special anonymous identifier  _  can be used if the body\n    of the loop does not access the variable.   interval: \n    Specifies a direction, endpoints with open or closed modifiers, and a step.   direction :  - : Starts from the endpoint  Exp  on the left increasing towards  Exp  on the right.  - : Starts from the endpoint  Exp  on the right decreasing towards  Exp  on the left.\nTypically, the value on the left is smaller or equal to the value on\nthe right.    endpoints :\n     [Exp  and  Exp]  are closed intervals which include  Exp  as the\n    endpoints;\n     ]Exp  and  Exp[  are open intervals which exclude  Exp  as the\n    endpoints.\n    Alternatively, the finishing endpoint may be  _  which means that the\n    interval goes towards infinite.  step :\n    An optional positive number added or subtracted towards the limit.\n    If the step is omitted, it assumes the value  1 .\n    If the direction is  - , the step is added, otherwise it is subtracted.   If the interval is not specified, it assumes the default  [0 -  _] .    A numeric iterator executes as follows:    initialization: \n    The starting endpoint is assigned to the control variable.\n    If the starting enpoint is open, the control variable accumulates a step\n    immediately.    iteration:   limit check: \n    If the control variable crossed the finishing endpoint, the loop\n    terminates.  body execution: \n    The loop body executes.  step \n    Applies a step to the control variable. Goto step  1 .     The  break  and  continue  statements inside numeric iterators accept an\noptional modifier  / ID_int  to affect the enclosing\nloop matching the control variable.  Examples:  // prints  i=0 ,  i=1 , ...\nvar int i;\nloop i do\n    _printf( i=%d\\n , i);\nend  // awaits 1s and prints  Hello World!  10 times\nloop _ in [0 -  10[ do\n    await 1s;\n    _printf( Hello World!\\n );\nend  var int i;\nloop i do\n    var int j;\n    loop j do\n        if  cnd-1  then\n            continue/i;         // continues the loop at line 1\n        else/if  cnd-2  then\n            break/j;            // breaks the loop at line 4\n        end\n    end\nend  Note : the runtime asserts that the step is a positive number and that the\n        control variable does not overflow.", 
            "title": "Numeric Iterator"
        }, 
        {
            "location": "/statements/#event-iterator", 
            "text": "The  every  statement iterates over an event continuously, executing its\nbody whenever the event occurs.  The event can be an  external or internal event  or a  timer .  The optional assignment to a variable (or list of variables) stores the\ncarrying value(s) of the event.  An  every  expands to a  loop  as illustrated below:  every  vars  in  event  do\n     body \nend  is equivalent to  loop do\n     vars  = await  event ;\n     body \nend  However, the body of an  every  cannot contain synchronous control statements , ensuring\nthat no occurrences of the specified event are ever missed.  Examples:  every 1s do\n    _printf( Hello World!\\n );      // prints the  Hello World!  message on every second\nend  event (bool,int) e;\nvar bool cnd;\nvar int  v;\nevery (cnd,v) in e do\n    if not cnd then\n        break;                      // terminates when the received  cnd  is false\n    else\n        _printf( v = %d\\n , v);     // prints the received  v  otherwise\n    end\nend", 
            "title": "Event Iterator"
        }, 
        {
            "location": "/statements/#pool-iterator", 
            "text": "TODO", 
            "title": "Pool Iterator"
        }, 
        {
            "location": "/statements/#parallel-compositions", 
            "text": "Pars ::= (par | par/and | par/or) do\n             Block\n         with\n             Block\n         { with\n             Block }\n         end\n\nSpawn ::= spawn [`(\u00b4 [LIST(ID_int)] `)\u00b4] do\n              Block\n          end\n\nWatching ::= watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Code_Cons_Init) do\n                 Block\n             end  The parallel statements  par/and ,  par/or , and  par  fork the running trail \nin multiple others.\nThey differ only on how trails rejoin and terminate the composition.  The  spawn  statement starts to execute a block in parallel with the enclosing\nblock.  The  watching  statement executes a block and terminates when one of its\nspecified events occur.  See also  Parallel Compositions and Abortion .", 
            "title": "Parallel Compositions"
        }, 
        {
            "location": "/statements/#par", 
            "text": "The  par  statement never rejoins.  Examples:  // reacts continuously to  1s  and  KEY_PRESSED  and never terminates\ninput void KEY_PRESSED;\npar do\n    every 1s do\n         ...            // does something every  1s \n    end\nwith\n    every KEY_PRESSED do\n         ...            // does something every  KEY_PRESSED \n    end\nend", 
            "title": "par"
        }, 
        {
            "location": "/statements/#parand", 
            "text": "The  par/and  statement stands for  parallel-and  and rejoins when all nested\ntrails terminate.  Examples:  // reacts once to  1s  and  KEY_PRESSED  and terminates\ninput void KEY_PRESSED;\npar/and do\n    await 1s;\n     ...                // does something after  1s \nwith\n    await KEY_PRESSED;\n     ...                // does something after  KEY_PRESSED \nend", 
            "title": "par/and"
        }, 
        {
            "location": "/statements/#paror", 
            "text": "The  par/or  statement stands for  parallel-or  and rejoins when any of the \ntrails terminate, aborting all other trails.  Examples:  // reacts once to `1s` or `KEY_PRESSED` and terminates\ninput void KEY_PRESSED;\npar/or do\n    await 1s;\n     ...                // does something after  1s \nwith\n    await KEY_PRESSED;\n     ...                // does something after  KEY_PRESSED \nend", 
            "title": "par/or"
        }, 
        {
            "location": "/statements/#spawn", 
            "text": "The  spawn  statement starts to execute a block in parallel with the enclosing\nblock.\nWhen the enclosing block terminates, the spawned block is aborted.  Like a  do-end  block , a  spawn  also supports an\noptional list of identifiers in parenthesis which restricts the visible\nvariables inside the block to those matching the list.  Examples:  spawn do\n    every 1s do\n         ...        // does something every  1s ...\n    end\nend ...                // ...in parallel with whatever comes next", 
            "title": "spawn"
        }, 
        {
            "location": "/statements/#watching", 
            "text": "A  watching  expands to a  par/or  with  n+1  trails:\none to await each of the listed events,\nand one to execute its body, i.e.:  watching  e1 , e2 ,... do\n     body \nend  expands to  par/or do\n    await  e1 ;\nwith\n    await  e2 ;\nwith\n    ...\nwith\n     body \nend  The  watching  statement accepts a list of events and terminates when any of\nthem occur.\nIt evaluates to what the occurring event value(s), which can be captured with\nan optional  assignment .  Examples:  // reacts continuously to  KEY_PRESSED  during  1s \ninput void KEY_PRESSED;\nwatching 1s do\n    every KEY_PRESSED do\n         ...            // does something every  KEY_PRESSED \n    end\nend", 
            "title": "watching"
        }, 
        {
            "location": "/statements/#pausing_1", 
            "text": "The  pause/if  statement controls if its body should temporarily stop to react\nto events:  Pause_If ::= pause/if (Loc|ID_ext) do\n                 Block\n             end\n\nPause_Await ::= await (pause|resume)  A  pause/if  specifies a pausing event of type  bool  which, when emitted,\ntoggles between pausing ( true ) and resuming ( false ) reactions for its body.  When its body terminates, the whole  pause/if  terminates and proceeds to the\nstatement in sequence.  In transition instants, the body can react to the special  pause  and  resume \nevents before the corresponding state applies.  TODO: finalize/pause/resume  Examples:  event bool e;\npause/if e do       // pauses/resumes the nested body on each  e \n    every 1s do\n         ...        // does something every  1s \n    end\nend  event bool e;\npause/if e do               // pauses/resumes the nested body on each  e \n     ... \n        loop do\n            await pause;\n             ...            // does something before pausing\n            await resume;\n             ...            // does something before resuming\n        end\n     ... \nend", 
            "title": "Pausing"
        }, 
        {
            "location": "/statements/#asynchronous-execution", 
            "text": "Asynchronous execution allow programs to departure from the rigorous\nsynchronous model and preform computations under separate scheduling rules.  C\u00e9u supports  asynchronous blocks ,  threads , and interrupt service routines :  Async  ::= await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nThread ::= await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nIsr ::= spawn async/isr `[\u00b4 LIST(Exp) `]\u00b4 [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\nAtomic ::= atomic do\n               Block\n           end  Asynchronous execution supports  tight loops  while\nkeeping the rest of the application, aka the  synchronous side , reactive to\nincoming events.  However, it does not support any synchronous control statement  (e.g.,\nparallel compositions, event handling, pausing, etc.).  By default, asynchronous bodies do not share variables with their enclosing\nscope, but the optional list of variables makes them visible to the block.  Even though asynchronous blocks execute in separate, they are still managed by\nthe program hierarchy and are also subject to lexical scope and abortion.", 
            "title": "Asynchronous Execution"
        }, 
        {
            "location": "/statements/#asynchronous-block", 
            "text": "Asynchronous blocks, aka  asyncs , intercalate execution with the synchronous\nside as follows:   Start/Resume whenever the synchronous side is idle.\n   When multiple  asyncs  are active, they execute in lexical order.  Suspend after each  loop  iteration.  Suspend on every input  emit  (see  Simulation ).  Execute atomically and to completion unless rules  2  and  3  apply.   This rules imply that  asyncs  never execute with real parallelism with the\nsynchronous side, preserving determinism in the program.  Examples:  // calculates the factorial of some  v  if it doesn't take too long\nvar u64  v   =  ... ;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async (v,fat) do      // keeps  v  and  fat  visible\n        loop i in [1 -  v] do   // reads from  v \n            fat = fat * i;      // writes to  fat \n        end\n    end\n    ok = true;                  // completed within  1s \nend", 
            "title": "Asynchronous Block"
        }, 
        {
            "location": "/statements/#simulation", 
            "text": "An  async  block can emit  input and timer events  towards the\nsynchronous side, providing a way to test programs in the language itself.\nEvery time an  async  emits an event, it suspends until the synchronous side\nreacts to the event (see  rule 1  above).  Examples:  input int A;\n\n// tests a program with input simulation in parallel\npar do\n\n    // original program\n    var int v = await A;\n    loop i in [0 -  _[ do\n        await 10ms;\n        _printf( v = %d\\n , v+i);\n    end\n\nwith\n\n    // input simulation\n    async do\n        emit A(0);      // initial value for  v \n        emit 1s35ms;    // the loop in the original program executes 103 times\n    end\n    escape 0;\n\nend\n\n// The example prints the message `v =  v+i ` exactly 103 times.", 
            "title": "Simulation"
        }, 
        {
            "location": "/statements/#thread", 
            "text": "Threads provide real parallelism for applications in C\u00e9u.\nOnce started, a thread executes completely detached from the synchronous side.\nFor this reason, thread execution is non deterministic and require explicit atomic blocks  on accesses to variables to avoid race\nconditions.  A thread evaluates to a boolean value which indicates whether it started\nsuccessfully or not.\nThe value can be captured with an optional  assignment .  Examples:  // calculates the factorial of some  v  if it doesn't take too long\nvar u64  v   =  ... ;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async/thread (v,fat) do   // keeps  v  and  fat  visible\n        loop i in [1 -  v] do       // reads from  v \n            fat = fat * i;          // writes to  fat \n        end\n    end\n    ok = true;                      // completed within  1s \nend", 
            "title": "Thread"
        }, 
        {
            "location": "/statements/#asynchronous-interrupt-service-routine", 
            "text": "TODO", 
            "title": "Asynchronous Interrupt Service Routine"
        }, 
        {
            "location": "/statements/#atomic-block", 
            "text": "Atomic blocks provide mutual exclusion among threads, interrupts, and the\nsynchronous side of application.\nOnce an atomic block starts to execute, no other atomic block in the program\nstarts.  Examples:  // A  race  between two threads: one incrementing, the other decrementing  count .\n\nvar s64 count = 0;                              //  count  is a shared variable\npar do\n    every 1s do\n        atomic do\n            _printf( count = %d\\n , count);     // prints current value of  count  every  1s \n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count - 1;              // decrements  count  as fast as possible\n            end\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count + 1;              // increments  count  as fast as possible\n            end\n        end\n    end\nend", 
            "title": "Atomic Block"
        }, 
        {
            "location": "/statements/#c-integration", 
            "text": "C\u00e9u provides  native declarations  to import C symbols, native blocks  to define new code in C, native statements  to inline C statements, native calls  to call C functions,\nand  finalization  to deal with C pointers safely:  Nat_Symbol ::= native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\nNat_Block  ::= native `/\u00b4(pre|pos) do\n                    code definitions in C \n               end\nNat_End    ::= native `/\u00b4 end\n\nNat_Stmts  ::= `{\u00b4 { code in C  | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} `}\u00b4     /* `@@\u00b4 escapes to `@\u00b4 */\n\nNat_Call   ::= [call] (Loc | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\nList_Nat ::= LIST(ID_nat)\n\nFinalization ::= do [Stmt] Finalize\n              |  var ` ?\u00b4 Type ID_int `=\u00b4 ` \u00b4 (Call_Nat | Call_Code) Finalize\nFinalize ::= finalize `(\u00b4 LIST(Loc) `)\u00b4 with\n                 Block\n             [ pause  with Block ]\n             [ resume with Block ]\n             end  Native calls and statements transfer execution to C, losing the guarantees of\nthe  synchronous model .\nFor this reason, programs should only resort to C for asynchronous\nfunctionality (e.g., non-blocking I/O) or simple  struct  accessors, but\nnever for control purposes.  TODO: Nat_End", 
            "title": "C Integration"
        }, 
        {
            "location": "/statements/#native-declaration", 
            "text": "In C\u00e9u, any  identifier  prefixed with an\nunderscore is a native symbol defined externally in C.\nHowever, all external symbols must be declared before their first use in a\nprogram.  Native declarations support four modifiers as follows:   const : declares the listed symbols as constants.\n    Constants can be used as bounded limits in  vectors ,\n     pools , and  numeric loops .\n    Also, constants cannot be  assigned .  plain : declares the listed symbols as  plain  types, i.e., types (or\n    composite types) that do not contain pointers.\n    A value of a plain type passed as argument to a function does not require\n     finalization .  nohold : declares the listed symbols as  non-holding  functions, i.e.,\n    functions that do not retain received pointers after returning.\n    Pointers passed to non-holding functions do not require\n     finalization .  pure : declares the listed symbols as pure functions.\n    In addition to the  nohold  properties, pure functions never allocate\n    resources that require  finalization \n    and have no side effects to take into account for the  safety checks .   Examples:  // values\nnative/const  _LOW, _HIGH;      // Arduino  LOW  and  HIGH  are constants\nnative        _errno;           // POSIX  errno  is a global variable\n\n// types\nnative/plain  _char;            //  char  is a  plain  type\nnative        _SDL_PixelFormat; // SDL  SDL_PixelFormat  is a type holding a pointer\n\n// functions\nnative        _uv_read_start;   // Libuv  uv_read_start  retains the received pointer\nnative/nohold _free;            // POSIX  free  receives a pointer but does not retain it\nnative/pure   _strlen;          // POSIX  strlen  is a  pure  function", 
            "title": "Native Declaration"
        }, 
        {
            "location": "/statements/#native-block", 
            "text": "A native block allows programs to define new external symbols in C.  The contents of native blocks is copied unchanged to the output in C depending\non the modifier specified:   pre : code is placed before the declarations for the C\u00e9u program.\n    Symbols defined in  pre  blocks are visible to C\u00e9u.  pos : code is placed after the declarations for the C\u00e9u program.\n    Symbols implicitly defined by the compiler of C\u00e9u are visible to  pos \n    blocks.   Native blocks are copied in the order they appear in the source code.  Since C\u00e9u uses the  C preprocessor , hash\ndirectives  #  inside native blocks must be quoted as  ##  to be considered\nonly in the C compilation phase.  If the code in C contains the terminating  end  keyword of C\u00e9u, the  native \nblock should be delimited with matching comments to avoid confusing the parser:  Symbols defined in native blocks still need to be declared  for use in the program.  Examples:  native/plain _t;\nnative/pre do\n    typedef int t;              // definition for  t  is placed before C\u00e9u declarations\nend\nvar _t x = 10;                  // requires  t  to be already defined  input void A;                   // declaration for  A  is placed before  pos  blocks\nnative _get_A_id;\nnative/pos do\n    int get_A_id (void) {\n        return CEU_INPUT_A;     // requires  A  to be already declared\n    }\nend  native/nohold _printf;\nnative/pre do\n    ##include  stdio.h          // include the relevant header for  printf \nend  native/pos do\n    /******/\n    char str =  This `end` confuses the parser ;\n    /******/\nend", 
            "title": "Native Block"
        }, 
        {
            "location": "/statements/#native-statement", 
            "text": "The contents of native statements in between  {  and  }  are inlined in the\nprogram.  Native statements support interpolation of expressions in C\u00e9u which are\nexpanded when preceded by the symbol  @ .  Examples:  var int v_ceu = 10;\n{\n    int v_c = @v_ceu * 2;       // yields 20\n}\nv_ceu = { v_c + @v_ceu };       // yields 30\n{\n    printf( %d\\n , @v_ceu);     // prints 30\n}", 
            "title": "Native Statement"
        }, 
        {
            "location": "/statements/#native-call", 
            "text": "Expressions that evaluate to a  native type  can be called\nfrom C\u00e9u.  If a call passes or returns pointers, it may require an accompanying finalization statement .  Examples:  // all expressions below evaluate to a native type and can be called\n\n_printf( Hello World!\\n );\n\nvar _t f =  ... ;\nf();\n\nvar _s s =  ... ;\ns.f();", 
            "title": "Native Call"
        }, 
        {
            "location": "/statements/#resources-finalization", 
            "text": "A finalization statement unconditionally executes a series of statements when\nits associated block terminates or is aborted.  C\u00e9u tracks the interaction of native calls with pointers and requires  finalize  clauses to accompany the calls:   If C\u00e9u  passes  a pointer to a native call, the pointer represents a\n   local resource  that requires finalization.\n  Finalization executes when the block of the local resource goes out of scope.  If C\u00e9u  receives  a pointer from a native call return, the pointer\n  represents an  external resource  that requires finalization.\n  Finalization executes when the block of the receiving pointer goes out of\n  scope.   In both cases, the program does not compile without the  finalize  statement.  A  finalize  cannot contain synchronous control statements .  Examples:  // Local resource finalization\nwatching  ...  do\n    var _buffer_t msg;\n     ...                        // prepares msg\n    do\n        _send_request( msg);\n    finalize with\n        _send_cancel( msg);\n    end\n    await SEND_ACK;             // transmission is complete\nend  In the example above, the local variable  msg  is an internal resource passed\nas a pointer to  _send_request , which is an asynchronous call that transmits\nthe buffer in the background.\nIf the enclosing  watching  aborts before awaking from the  await SEND_ACK ,\nthe local  msg  goes out of scope and the external transmission would hold a dangling pointer .\nThe  finalize  ensures that  _send_cancel  also aborts the transmission.  // External resource finalization\nwatching  ...  do\n    var ? _FILE f =  _fopen( ... ) finalize with\n                        _fclose(f);\n                    end;\n    _fwrite( ... , f);\n    await A;\n    _fwrite( ... , f);\nend  In the example above, the call to  _fopen  returns an external file resource as\na pointer.\nIf the enclosing  watching  aborts before awaking from the  await A , the file\nwould remain open as a  memory leak .\nThe  finalize  ensures that  _fclose  closes the file properly.  To access an external resource from C\u00e9u requires an alias assignment  to a variable alias .\nIf the external call returns  NULL  and the variable is an option alias var ? , the alias remains unbounded.\nIf the variable is an alias  var , the assigment raises a runtime error.  Note: the compiler only forces the programmer to write finalization clauses,\n       but cannot check if they handle the resource properly.  Declaration  and  expression \nmodifiers may suppress the requirement for finalization in calls:   nohold  modifiers or  /nohold  typecasts make passing pointers safe.  pure    modifiers or  /pure    typecasts make passing pointers and returning\n                                  pointers safe.  /plain  typecasts make return values safe.   Examples:  //  _free  does not retain  ptr \nnative/nohold _free;\n_free(ptr);\n// or\n(_free as /nohold)(ptr);  //  _strchr  does retain  ptr  or allocates resources\nnative/pure _strchr;\nvar _char  found = _strchr(ptr);\n// or\nvar _char  found = (_strchr as /pure)(ptr);  //  _f  returns a non-pointer type\nvar _tp v = _f() as /plain;", 
            "title": "Resources &amp; Finalization"
        }, 
        {
            "location": "/statements/#lua-integration", 
            "text": "C\u00e9u provides  Lua states  to delimit the effects of inlined Lua statements :  Lua_State ::= lua `[\u00b4 [Exp] `]\u00b4 do\n                 Block\n              end\nLua_Stmts ::= `[\u00b4 {`=\u00b4} `[\u00b4\n                  { { code in Lua  | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} }   /* `@@\u00b4 escapes to `@\u00b4 */\n              `]\u00b4 {`=\u00b4} `]\u00b4  Lua statements transfer execution to Lua, losing the guarantees of the synchronous model .\nFor this reason, programs should only resort to C for asynchronous\nfunctionality (e.g., non-blocking I/O) or simple  struct  accessors, but\nnever for control purposes.  All programs have an implicit enclosing  global Lua state  which all orphan\nstatements apply.", 
            "title": "Lua Integration"
        }, 
        {
            "location": "/statements/#lua-state", 
            "text": "A Lua state creates an isolated state for inlined Lua statements .  Example:  //  v  is not shared between the two statements\npar do\n    // global Lua state\n    [[ v = 0 ]];\n    var int v = 0;\n    every 1s do\n        [[print('Lua 1', v, @v) ]];\n        v = v + 1;\n        [[ v = v + 1 ]];\n    end\nwith\n    // local Lua state\n    lua[] do\n        [[ v = 0 ]];\n        var int v = 0;\n        every 1s do\n            [[print('Lua 2', v, @v) ]];\n            v = v + 1;\n            [[ v = v + 1 ]];\n        end\n    end\nend  TODO: dynamic scope, assignment/error, [dim]", 
            "title": "Lua State"
        }, 
        {
            "location": "/statements/#lua-statement", 
            "text": "The contents of Lua statements in between  [[  and  ]]  are inlined in the\nprogram.  Like  native statements , Lua statements support\ninterpolation of expressions in C\u00e9u which are expanded when preceded by a  @ .  Lua statements only affect the  Lua state  in which they are embedded.  If a Lua statement is used in an  assignment , it is evaluated as\nan expression that either satisfies the destination or generates a runtime\nerror.\nThe list that follows specifies the  C\u00e9u destination  and expected Lua source :   a  var   bool                             expects a  boolean  a  numeric   var    expects a  number  a pointer  var                            expects a  lightuserdata  a  vector   byte                          expects a  string   TODO: lua state captures errors  Examples:  var int v_ceu = 10;\n[[\n    v_lua = @v_ceu * 2          -- yields 20\n]]\nv_ceu = [[ v_lua + @v_ceu ]];   // yields 30\n[[\n    print(@v_ceu)               -- prints 30\n]]", 
            "title": "Lua Statement"
        }, 
        {
            "location": "/statements/#abstractions", 
            "text": "C\u00e9u supports reuse with  data  declarations to define new types, and  code \ndeclarations to define new subprograms.  Declarations are subject to  lexical scope .", 
            "title": "Abstractions"
        }, 
        {
            "location": "/statements/#data", 
            "text": "A  data  declaration creates a new data type:  Data ::= data ID_abs [as (nothing|Exp)] [ with\n             (Var|Vec|Pool|Int) `;\u00b4 {`;\u00b4}\n             { (Var|Vec|Pool|Int) `;\u00b4 {`;\u00b4} }\n         end\n\nData_Cons ::= (val|new) Abs_Cons\nAbs_Cons  ::= [Loc `.\u00b4] ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`nil\u00b4|`_\u00b4) `)\u00b4  A declaration may pack fields with storage declarations  which become publicly\naccessible in the new type.\nField declarations may  assign  default values for\nuninitialized instances.  Data types can form hierarchies using dots ( . ) in identifiers:   An isolated identifier such as  A  makes  A  a base type.  A dotted identifier such as  A.B  makes  A.B  a subtype of its supertype  A .   A subtype inherits all fields from its supertype.  The optional modifier  as  expects the keyword  nothing  or a constant\nexpression of type  int :   nothing : the  data  cannot be instantiated.  constant expression :  typecasting  a value of\n                         the type to  int  evaluates to the specified\n                         enumeration expression.   Examples:  data Rect with\n    var int x, y, h, w;\n    var int z = 0;\nend\nvar Rect r = val Rect(10,10, 100,100, _);  //  r.z  defaults to 0  data Dir       as nothing;  //  Dir  is a base type and cannot be intantiated\ndata Dir.Right as  1;       //  Dir.Right  is a subtype of  Dir \ndata Dir.Left  as -1;       //  Dir.Left   is a subtype of  Dir \nvar  Dir dir =  ... ;       // receives one of  Dir.Right  or  Dir.Left \nescape (dir as int);        // returns 1 or -1  TODO: new, pool, recursive types", 
            "title": "Data"
        }, 
        {
            "location": "/statements/#data-constructor", 
            "text": "A new static value constructor is created in the contexts as follows:   Prefixed by the keyword  val  in an  assignment  to a variable.  As an argument to a  code  invocation .  Nested as an argument in a  data  creation (i.e., a  data  that contains\n  another  data ).   In all cases, the arguments are copied to a destination with static storage.\nThe destination must be a plain declaration (i.e., not an alias or pointer).  The constructor uses the  data  identifier followed by a list of arguments\nmatching the fields of the type.  Variables of the exact same type can be copied in  assignments .  For assignments from a subtype to a supertype, the rules are as follows:   Copy assignments  plain values: only if the subtype contains no extra fields  pointers: allowed    Alias assignment : allowed.   data Object with\n    var Rect rect;\n    var Dir  dir;\nend\nvar Object o1 = val Object(Rect(0,0,10,10,_), Dir.Right());  var Object o2 = o1;         // makes a deep copy of all fields from  o1  to  o2", 
            "title": "Data Constructor"
        }, 
        {
            "location": "/statements/#code", 
            "text": "The  code/tight  and  code/await  declarations specify new subprograms that can\nbe invoked from arbitrary points in programs:  // prototype declaration\nCode_Tight ::= code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `- \u00b4 Type\nCode_Await ::= code/await Mods ID_abs `(\u00b4 Params `)\u00b4 [`- \u00b4 `(\u00b4 Params `)\u00b4] `- \u00b4 (Type | FOREVER)\nParams ::= void | LIST(Var|Vec|Pool|Int)\n\n// full declaration\nCode_Impl ::= (Code_Tight | Code_Await) do\n                  Block\n              end\n\n// invocation\nCode_Call  ::= call  Mods Abs_Cons\nCode_Await ::= await Mods Abs_Cons\nCode_Spawn ::= spawn Mods Abs_Cons [in Loc]\n\nMods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]  A  code/tight  is a subprogram that cannot contain synchronous control statements  and runs to\ncompletion in the current  internal reaction .  A  code/await  is a subprogram with no restrictions (e.g., it can manipulate\nevents and use parallel compositions) and its execution may outlive multiple\nreactions.  A  prototype declaration  specifies the interface parameters of the\nabstraction which invocations must satisfy.\nA  full declaration  (aka  definition ) also specifies an implementation\nwith a block of code.\nAn  invocation  specifies the name of the code abstraction and arguments\nmatching its declaration.  To support recursive abstractions, a code invocation can appear before the\nimplementation is known, but after the prototype declaration.\nIn this case, the declaration must use the modifier  /recursive .  Examples:  code/tight Absolute (var int v) -  int do   // declares the prototype for  Absolute \n    if v   0 then                           // implements the behavior\n        escape  v;\n    else\n        escape -v;\n    end\nend\nvar int abs = call Absolute(-10);           // invokes  Absolute  (yields 10)  code/await Hello_World (void) -  FOREVER do\n    every 1s do\n        _printf( Hello World!\\n );  // prints  Hello World!  every second\n    end\nend\nawait Hello_World();                // never awakes  code/tight/recursive Fat (var int v) -  int;    //  Fat  is a recursive code\ncode/tight/recursive Fat (var int v) -  int do\n    if v   1 then\n        escape v * (call/recursive Fat(v-1));   // recursive invocation before full declaration\n    else\n        escape 1;\n    end\nend\nvar int fat = call/recursive Fat(10);           // invokes  Fat  (yields 3628800)  TODO: hold", 
            "title": "Code"
        }, 
        {
            "location": "/statements/#code-declaration", 
            "text": "Code abstractions specify a list of input parameters in between the symbols (  and  ) .\nEach parameter specifies an  entity class \nwith modifiers, a type and an identifier.\nA  void  list specifies that the abstraction has no parameters.  Code abstractions also specify an output return type.\nA  code/await  may use  FOREVER  as output to indicate that it never returns.  A  code/await  may also specify an optional  public parameter list , which are\nlocal storage entities living the outermost scope of the abstraction body.\nThese entities are visible to the invoking context which may access them while\nthe abstraction executes.", 
            "title": "Code Declaration"
        }, 
        {
            "location": "/statements/#code-invocation", 
            "text": "A  code/tight  is invoked with the keyword  call  followed by the abstraction\nname and list of arguments.\nA  code/await  is invoked with the keywords  await  or  spawn  followed by the\nabstraction name and list of arguments.  The list of arguments must satisfy the list of parameters in the code declaration .  The  call  and  await  invocations suspend the current trail and transfer\ncontrol to the code abstraction.\nThe invoking point only resumes after the abstraction terminates and evaluates\nto a value of its return type which can be captured with an optional assignment .  The  spawn  invocation also suspends and transfers control to the code\nabstraction.\nHowever, when the abstraction becomes idle (or terminates), the invoking point\nresumes.\nThis makes the invocation point and a non-terminating abstraction to execute\nconcurrently.   The  spawn  invocation also accepts an optional  pool  which provides\nstorage and scope for invoked abstractions.  If the  spawn  provides the pool, the invocation evaluates to a boolean that\nindicates whether the pool has space to execute the code.\nThe result can be captured with an optional  assignment .\nIf the pool goes out of scope, all invoked abstractions residing in that pool\nare aborted.  If the  spawn  omits the pool, the invocation always succeed and has the same\nscope as the invoking point: when the enclosing block terminates, the invoked\ncode is also aborted.", 
            "title": "Code Invocation"
        }, 
        {
            "location": "/statements/#dynamic-dispatching", 
            "text": "C\u00e9u supports dynamic code dispatching based on multiple parameters.  The modifier  /dynamic  in a declaration specifies that the code is dynamically\ndispatched.\nA dynamic code must have at least one  dynamic  parameter.\nAlso, all dynamic parameters must be pointers or aliases to a data type  in some hierarchy.  A dynamic declaration requires other compatible dynamic declarations with the\nsame name, modifiers, parameters, and return type.\nThe exceptions are the  dynamic  parameters, which must be in the same\nhierarchy of their corresponding parameters in other declarations.  To determine which declaration to execute during runtime, the actual argument\nruntime type is checked against the first formal  dynamic  parameter of each\ndeclaration.\nThe declaration with the most specific type matching the argument wins.\nIn the case of a tie, the next dynamic parameter is checked.  A  catchall  declaration with the most general dynamic types must always be\nprovided.  If the argument is explicitly  typecast  to a\nsupertype, then dispatching considers that type instead.  Example:  data Media as nothing;\ndata Media.Audio     with  ...  end\ndata Media.Video     with  ...  end\ndata Media.Video.Avi with  ...  end\n\ncode/await/dynamic Play (dynamic var  Media media) -  void do\n    _assert(0);             // never dispatched\nend\ncode/await/dynamic Play (dynamic var  Media.Audio media) -  void do\n     ...                    // plays an audio\nend\ncode/await/dynamic Play (dynamic var  Media.Video media) -  void do\n     ...                    // plays a video\nend\ncode/await/dynamic Play (dynamic var  Media.Video.Avi media) -  void do\n     ...                                    // prepare the avi video\n    await/dynamic Play( m as Media.Video);  // dispatches the supertype\nend\n\nvar  Media m =  ... ;       // receives one of  Media.Audio  or  Media.Video \nawait/dynamic Play( m);     // dispatches the appropriate subprogram to play the media", 
            "title": "Dynamic Dispatching"
        }, 
        {
            "location": "/statements/#synchronous-control-statements", 
            "text": "The  synchronous control statements  which follow cannot appear in event iterators , pool iterators , asynchronous execution , finalization ,\nand tight code abstractions : await ,  spawn ,  emit  (internal events),  every ,  finalize ,  pause/if , par ,  par/and ,  par/or , and  watching .  As exceptions, an  every  can  emit  internal events, and a  code/tight  can\ncontain empty  finalize  statements.", 
            "title": "Synchronous Control Statements"
        }, 
        {
            "location": "/expressions/", 
            "text": "Locations \n Expressions\n\n\nC\u00e9u specifies \nlocations\n and expressions as\nfollows:\n\n\nExp ::= NUM | STR | null | true | false\n     |  `(\u00b4 Exp `)\u00b4\n     |  Exp \nbinop\n Exp\n     |  \nunop\n Exp\n     |  Exp `[\u00b4 Exp `]\u00b4\n     |  Exp is Type\n     |  Exp as Type\n     |  Exp as `/\u00b4(nohold|plain|pure)\n     |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n     |  Nat_Call | Code_Call\n\n/* Locations */\n\nLoc ::= Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n     |  [`*\u00b4|`$\u00b4] Loc\n     |  Loc { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\n     |  ID_int\n     |  ID_nat\n     |  outer\n     |  `{\u00b4 \ncode in C\n `}\u00b4\n     |  `(\u00b4 Loc `)\u00b4\n\n/* Operator Precedence */\n\n    /* lowest priority */\n\n    // locations\n    *     $\n    :     .     !     []\n    as\n\n    // expressions\n    is    as                                            // binops\n    or\n    and\n    !=    ==    \n=    \n=    \n     \n\n    |\n    ^\n    \n\n    \n    \n\n    +     -\n    *     /     %\n    not   +     -     ~     $$    $     *     \n    \n   // unops\n    :     .     !     ?     ()    []\n\n    /* highest priority */\n\n\n\n\nPrimary\n\n\nTODO\n\n\n\n\n\nArithmetic\n\n\nC\u00e9u supports the arithmetic expressions \naddition\n, \nsubtraction\n,\n\nmodulo (remainder)\n, \nmultiplication\n, \ndivision\n, \nunary-plus\n, and\n\nunary-minus\n through the operators that follow:\n\n\n    +      -      %      *      /      +      -\n\n\n\n\n\n\n\nBitwise\n\n\nC\u00e9u supports the bitwise expressions \nnot\n, \nand\n, \nor\n, \nxor\n, \nleft-shift\n,\nand \nright-shift\n through the operators that follow:\n\n\n    ~      \n      |      ^      \n      \n\n\n\n\n\nRelational\n\n\nC\u00e9u supports the relational expressions \nequal-to\n, \nnot-equal-to\n,\n\ngreater-than\n, \nless-than\n, \ngreater-than-or-equal-to\n, and\n\nless-than-or-equal-to\n through the operators that follow:\n\n\n    ==      !=      \n      \n      \n=      \n=\n\n\n\n\nRelational expressions evaluate to \ntrue\n or \nfalse\n.\n\n\nLogical\n\n\nC\u00e9u supports the logical expressions \nnot\n, \nand\n, and \nor\n through the\noperators that follow:\n\n\n    not      and      or\n\n\n\n\nLogical expressions evaluate to \ntrue\n or \nfalse\n.\n\n\nTypes\n\n\nC\u00e9u supports type checks and casts:\n\n\nCheck ::= Exp is Type\nCast  ::= Exp as Type\n\n\n\n\nType Check\n\n\nA type check evaluates to \ntrue\n or \nfalse\n depending on whether the runtime\ntype of the expression is a subtype of the checked type or not.\n\n\nThe static type of the expression must be a supertype of the checked type.\n\n\nExample:\n\n\ndata Aa;\ndata Aa.Bb;\nvar Aa a = \n...\n;       // \na\n is of static type \nAa\n\n\n...\n\nif a is Aa.Bb then      // is the runtime type of \na\n a subtype of \nAa.Bb\n?\n    \n...\n\nend\n\n\n\n\nType Cast\n\n\nA type cast converts the type of an expression into a new type as follows:\n\n\n\n\nThe expression type is a \ndata type\n:\n\n\nThe new type is \nint\n:\n    Evaluates to the \ntype enumeration\n for the\n    expression type.\n\n\nThe new type is a subtype of the expression static type:\n\n\nThe expression runtime type is a subtype of the new type:\n    Evaluates to the new type.\n\n\nEvaluates to error.\n\n\n\n\n\n\nThe new type is a supertype of the expression static type:\n    Always succeeds and evaluates to the new type.\n    See also \nDynamic Dispatching\n.\n\n\nEvaluates to error.\n\n\n\n\n\n\nEvaluates to the new type (i.e., a \nweak typecast\n, as in C).\n\n\n\n\nExamples:\n\n\nvar Direction dir = \n...\n;\n_printf(\ndir = %d\\n\n, dir as int);\n\nvar Aa a = \n...\n;\n_printf(\na.v = %d\\n\n, (a as Aa.Bb).v);\n\nvar Media.Video vid = \n...\n;\nawait/dynamic Play(\nm as Media);\n\nvar bool b = \n...\n;\n_printf(\nb= %d\\n\n, b as int);\n\n\n\n\nModifiers\n\n\nExpressions that evaluate to native types can be modified as follows:\n\n\nMod ::= Exp as `/\u00b4(nohold|plain|pure)\n\n\n\n\nModifiers may suppress the requirement for\n\nresource finalization\n.\n\n\nReferences\n\n\nC\u00e9u supports \naliases\n and \npointers\n as\n\nreferences\n.\n\n\nAliases\n\n\nAn alias is acquired by prefixing a \nnative call\n\nor a \nlocation\n with the operator \n:\n\n\nAlias ::= `\n\u00b4 (Nat_Call | Loc)\n\n\n\n\nSee also the \nunwrap operator\n \n!\n for option variable aliases.\n\n\nPointers\n\n\nThe operator \n returns the address of a\n\nlocation\n, while the operator \n*\n dereferences\na pointer:\n\n\nAddr  ::= `\n\u00b4 Loc\nDeref ::= `*\u00b4 Loc\n\n\n\n\nOption\n\n\nThe operator \n?\n checks if the \nlocation\n of an\n\noption type\n is set, while the operator \n!\n unwraps the\nlocation, raising an \nerror\n if it is unset:\n\n\nCheck  ::= Loc `?\u00b4\nUnwrap ::= Loc `!\u00b4\n\n\n\n\nSizeof\n\n\nA \nsizeof\n expression returns the size of a type or expression, in bytes:\n\n\nSizeof ::= sizeof `(\u00b4 (Type|Exp) `)\u00b4\n\n\n\n\n\n\n\nCalls\n\n\nSee \nNative Call\n and\n\nCode Invocation\n.\n\n\nVectors\n\n\nIndex\n\n\nC\u00e9u uses square brackets to index \nvectors\n:\n\n\nVec_Idx ::= Loc `[\u00b4 Exp `]\u00b4\n\n\n\n\nThe index expression must be of type \nusize\n.\n\n\nVectors start at index zero.\nC\u00e9u generates an \nerror\n for out-of-bounds vector accesses.\n\n\nLength\n\n\nThe operator \n$\n returns the current length of a vector, while the operator\n\n$$\n returns the max length:\n\n\nVec_Len ::= `$\u00b4  Loc\nVec_Max ::= `$$\u00b4 Loc\n\n\n\n\nTODO: max\n\n\nThe vector length can also be assigned:\n\n\nvector[] int vec = [ 1, 2, 3 ];\n$vec = 1;\n\n\n\n\nThe new length must be smaller or equal to the current length, otherwise the\nassignment raises a runtime error.\nThe space for \ndynamic vectors\n shrinks automatically.\n\n\nConstructor\n\n\nVector constructors are only valid in \nassignments\n:\n\n\nVec_Cons   ::= (Loc | Exp) Vec_Concat { Vec_Concat }\n            |  `[\u00b4 [LIST(Exp)] `]\u00b4 { Vec_Concat }\nVec_Concat ::= `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4)\n\n\n\n\nExamples:\n\n\nvector[3] int v;     // declare an empty vector of length 3     (v = [])\nv = v .. [8];        // append value '8' to the empty vector    (v = [8])\nv = v .. [1] .. [5]; // append values '1' and '5' to the vector (v = [8, 1, 5])\n\n\n\n\nFields\n\n\nThe operators \n.\u00b4 and\n:\u00b4 specify fields of\n\ndata abstractions\n and\n\nnative\n structs:\n\n\nDot   ::= Loc `.\u00b4 (ID_int|ID_nat)\nColon ::= Loc `:\u00b4 (ID_int|ID_nat)\n\n\n\n\nThe expression \ne:f\n is a sugar for \n(*e).f\n.\n\n\nTODO: ID_nat to avoid clashing with C\u00e9u keywords.", 
            "title": "Locations & Expressions"
        }, 
        {
            "location": "/expressions/#locations-expressions", 
            "text": "C\u00e9u specifies  locations  and expressions as\nfollows:  Exp ::= NUM | STR | null | true | false\n     |  `(\u00b4 Exp `)\u00b4\n     |  Exp  binop  Exp\n     |   unop  Exp\n     |  Exp `[\u00b4 Exp `]\u00b4\n     |  Exp is Type\n     |  Exp as Type\n     |  Exp as `/\u00b4(nohold|plain|pure)\n     |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n     |  Nat_Call | Code_Call\n\n/* Locations */\n\nLoc ::= Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n     |  [`*\u00b4|`$\u00b4] Loc\n     |  Loc { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\n     |  ID_int\n     |  ID_nat\n     |  outer\n     |  `{\u00b4  code in C  `}\u00b4\n     |  `(\u00b4 Loc `)\u00b4\n\n/* Operator Precedence */\n\n    /* lowest priority */\n\n    // locations\n    *     $\n    :     .     !     []\n    as\n\n    // expressions\n    is    as                                            // binops\n    or\n    and\n    !=    ==     =     =           \n    |\n    ^\n     \n          \n    +     -\n    *     /     %\n    not   +     -     ~     $$    $     *              // unops\n    :     .     !     ?     ()    []\n\n    /* highest priority */", 
            "title": "Locations &amp; Expressions"
        }, 
        {
            "location": "/expressions/#primary", 
            "text": "TODO", 
            "title": "Primary"
        }, 
        {
            "location": "/expressions/#arithmetic", 
            "text": "C\u00e9u supports the arithmetic expressions  addition ,  subtraction , modulo (remainder) ,  multiplication ,  division ,  unary-plus , and unary-minus  through the operators that follow:      +      -      %      *      /      +      -", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/expressions/#bitwise", 
            "text": "C\u00e9u supports the bitwise expressions  not ,  and ,  or ,  xor ,  left-shift ,\nand  right-shift  through the operators that follow:      ~             |      ^", 
            "title": "Bitwise"
        }, 
        {
            "location": "/expressions/#relational", 
            "text": "C\u00e9u supports the relational expressions  equal-to ,  not-equal-to , greater-than ,  less-than ,  greater-than-or-equal-to , and less-than-or-equal-to  through the operators that follow:      ==      !=                     =       =  Relational expressions evaluate to  true  or  false .", 
            "title": "Relational"
        }, 
        {
            "location": "/expressions/#logical", 
            "text": "C\u00e9u supports the logical expressions  not ,  and , and  or  through the\noperators that follow:      not      and      or  Logical expressions evaluate to  true  or  false .", 
            "title": "Logical"
        }, 
        {
            "location": "/expressions/#types", 
            "text": "C\u00e9u supports type checks and casts:  Check ::= Exp is Type\nCast  ::= Exp as Type", 
            "title": "Types"
        }, 
        {
            "location": "/expressions/#type-check", 
            "text": "A type check evaluates to  true  or  false  depending on whether the runtime\ntype of the expression is a subtype of the checked type or not.  The static type of the expression must be a supertype of the checked type.  Example:  data Aa;\ndata Aa.Bb;\nvar Aa a =  ... ;       //  a  is of static type  Aa  ... \nif a is Aa.Bb then      // is the runtime type of  a  a subtype of  Aa.Bb ?\n     ... \nend", 
            "title": "Type Check"
        }, 
        {
            "location": "/expressions/#type-cast", 
            "text": "A type cast converts the type of an expression into a new type as follows:   The expression type is a  data type :  The new type is  int :\n    Evaluates to the  type enumeration  for the\n    expression type.  The new type is a subtype of the expression static type:  The expression runtime type is a subtype of the new type:\n    Evaluates to the new type.  Evaluates to error.    The new type is a supertype of the expression static type:\n    Always succeeds and evaluates to the new type.\n    See also  Dynamic Dispatching .  Evaluates to error.    Evaluates to the new type (i.e., a  weak typecast , as in C).   Examples:  var Direction dir =  ... ;\n_printf( dir = %d\\n , dir as int);\n\nvar Aa a =  ... ;\n_printf( a.v = %d\\n , (a as Aa.Bb).v);\n\nvar Media.Video vid =  ... ;\nawait/dynamic Play( m as Media);\n\nvar bool b =  ... ;\n_printf( b= %d\\n , b as int);", 
            "title": "Type Cast"
        }, 
        {
            "location": "/expressions/#modifiers", 
            "text": "Expressions that evaluate to native types can be modified as follows:  Mod ::= Exp as `/\u00b4(nohold|plain|pure)  Modifiers may suppress the requirement for resource finalization .", 
            "title": "Modifiers"
        }, 
        {
            "location": "/expressions/#references", 
            "text": "C\u00e9u supports  aliases  and  pointers  as references .", 
            "title": "References"
        }, 
        {
            "location": "/expressions/#aliases", 
            "text": "An alias is acquired by prefixing a  native call \nor a  location  with the operator  :  Alias ::= ` \u00b4 (Nat_Call | Loc)  See also the  unwrap operator   !  for option variable aliases.", 
            "title": "Aliases"
        }, 
        {
            "location": "/expressions/#pointers", 
            "text": "The operator   returns the address of a location , while the operator  *  dereferences\na pointer:  Addr  ::= ` \u00b4 Loc\nDeref ::= `*\u00b4 Loc", 
            "title": "Pointers"
        }, 
        {
            "location": "/expressions/#option", 
            "text": "The operator  ?  checks if the  location  of an option type  is set, while the operator  !  unwraps the\nlocation, raising an  error  if it is unset:  Check  ::= Loc `?\u00b4\nUnwrap ::= Loc `!\u00b4", 
            "title": "Option"
        }, 
        {
            "location": "/expressions/#sizeof", 
            "text": "A  sizeof  expression returns the size of a type or expression, in bytes:  Sizeof ::= sizeof `(\u00b4 (Type|Exp) `)\u00b4", 
            "title": "Sizeof"
        }, 
        {
            "location": "/expressions/#calls", 
            "text": "See  Native Call  and Code Invocation .", 
            "title": "Calls"
        }, 
        {
            "location": "/expressions/#vectors", 
            "text": "", 
            "title": "Vectors"
        }, 
        {
            "location": "/expressions/#index", 
            "text": "C\u00e9u uses square brackets to index  vectors :  Vec_Idx ::= Loc `[\u00b4 Exp `]\u00b4  The index expression must be of type  usize .  Vectors start at index zero.\nC\u00e9u generates an  error  for out-of-bounds vector accesses.", 
            "title": "Index"
        }, 
        {
            "location": "/expressions/#length", 
            "text": "The operator  $  returns the current length of a vector, while the operator $$  returns the max length:  Vec_Len ::= `$\u00b4  Loc\nVec_Max ::= `$$\u00b4 Loc  TODO: max  The vector length can also be assigned:  vector[] int vec = [ 1, 2, 3 ];\n$vec = 1;  The new length must be smaller or equal to the current length, otherwise the\nassignment raises a runtime error.\nThe space for  dynamic vectors  shrinks automatically.", 
            "title": "Length"
        }, 
        {
            "location": "/expressions/#constructor", 
            "text": "Vector constructors are only valid in  assignments :  Vec_Cons   ::= (Loc | Exp) Vec_Concat { Vec_Concat }\n            |  `[\u00b4 [LIST(Exp)] `]\u00b4 { Vec_Concat }\nVec_Concat ::= `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4)  Examples:  vector[3] int v;     // declare an empty vector of length 3     (v = [])\nv = v .. [8];        // append value '8' to the empty vector    (v = [8])\nv = v .. [1] .. [5]; // append values '1' and '5' to the vector (v = [8, 1, 5])", 
            "title": "Constructor"
        }, 
        {
            "location": "/expressions/#fields", 
            "text": "The operators  .\u00b4 and :\u00b4 specify fields of data abstractions  and native  structs:  Dot   ::= Loc `.\u00b4 (ID_int|ID_nat)\nColon ::= Loc `:\u00b4 (ID_int|ID_nat)  The expression  e:f  is a sugar for  (*e).f .  TODO: ID_nat to avoid clashing with C\u00e9u keywords.", 
            "title": "Fields"
        }, 
        {
            "location": "/compilation/", 
            "text": "Compilation\n\n\nThe compiler converts an input program in C\u00e9u to an output in C, which is\nfurther embedded in an \nenvironment\n satisfying a\n\nC API\n, which is finally compiled to an executable:\n\n\n\n\nCommand Line\n\n\nThe single command \nceu\n is used for all compilation phases:\n\n\nUsage: ceu [\noptions\n] \nfile\n...\n\nOptions:\n\n    --help                      display this help, then exit\n    --version                   display version information, then exit\n\n    --pre                       Preprocessor Phase: preprocess C\u00e9u into C\u00e9u\n    --pre-exe=FILE                  preprocessor executable\n    --pre-args=ARGS                 preprocessor arguments\n    --pre-input=FILE                input file to compile (C\u00e9u source)\n    --pre-output=FILE               output file to generate (C\u00e9u source)\n\n    --ceu                       C\u00e9u Phase: compiles C\u00e9u into C\n    --ceu-input=FILE                input file to compile (C\u00e9u source)\n    --ceu-output=FILE               output source file to generate (C source)\n    --ceu-line-directives=BOOL      insert `#line\u00b4 directives in the C output\n\n    --ceu-features-lua=BOOL         enable `lua\u00b4 support\n    --ceu-features-thread=BOOL      enable `async/thread\u00b4 support\n    --ceu-features-isr=BOOL         enable `async/isr\u00b4 support\n\n    --ceu-err-unused=OPT            effect for unused identifier: error|warning|pass\n    --ceu-err-unused-native=OPT                unused native identifier\n    --ceu-err-unused-code=OPT                  unused code identifier\n    --ceu-err-uninitialized=OPT     effect for uninitialized variable: error|warning|pass\n\n    --env                       Environment Phase: packs all C files together\n    --env-types=FILE                header file with type declarations (C source)\n    --env-threads=FILE              header file with thread declarations (C source)\n    --env-ceu=FILE                  output file from C\u00e9u phase (C source)\n    --env-main=FILE                 source file with main function (C source)\n    --env-output=FILE               output file to generate (C source)\n\n    --cc                        C Compiler Phase: compiles C into binary\n    --cc-exe=FILE                   C compiler executable\n    --cc-args=ARGS                  compiler arguments\n    --cc-input=FILE                 input file to compile (C source)\n    --cc-output=FILE                output file to generate (binary)\n\n\n\n\nAll phases are optional.\nTo enable a phase, the associated prefix must be enabled.\nIf two consecutive phases are enabled, the output of the preceding and the\ninput of the succeeding phases can be omitted.\n\n\nExamples:\n\n\n# Preprocess \nuser.ceu\n, and converts the output to \nuser.c\n\n$ ceu --pre --pre-input=\nuser.ceu\n --ceu --ceu-output=\nuser.c\n\n\n\n\n\n# Packs \nuser.c\n, \ntypes.h\n, and \nmain.c\n, compiling them to \napp.out\n\n$ ceu --env --env-ceu=user.c --env-types=types.h --env-main=main.c \\\n      --cc --cc-output=app.out\n\n\n\n\nC API\n\n\nThe environment phase of the compiler packs the converted C\u00e9u program and\nadditional files in the order as follows:\n\n\n\n\ntype declarations    (option \n--env-types\n)\n\n\nthread declarations  (option \n--env-threads\n, optional)\n\n\na callback prototype (fixed, see below)\n\n\nC\u00e9u program          (option \n--env-ceu\n, auto generated)\n\n\nmain program         (option \n--env-main\n)\n\n\n\n\nThe C\u00e9u program uses standardized types and calls, which must be previously\nmapped from the host environment in steps \n1-3\n.\n\n\nThe main program depends on declarations from the C\u00e9u program.\n\n\nTypes\n\n\nThe type declarations must map the types of the host environment to all\n\nprimitive types\n of C\u00e9u.\n\n\nExample:\n\n\n#include \nstdint.h\n\n#include \nsys/types.h\n\n\ntypedef unsigned char bool;\ntypedef unsigned char byte;\ntypedef unsigned int  uint;\n\ntypedef ssize_t  ssize;\ntypedef size_t   usize;\n\ntypedef int8_t    s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\ntypedef uint8_t   u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n\ntypedef float    f32;\ntypedef double   f64;\n\n\n\n\nThreads\n\n\nIf the user program uses \nthreads\n and the option\n\n--ceu-features-thread\n is set, the host environment must provide declarations\nfor types and functions expected by C\u00e9u.\n\n\nExample:\n\n\n#include \npthread.h\n\n#include \nunistd.h\n\n#define CEU_THREADS_T               pthread_t\n#define CEU_THREADS_MUTEX_T         pthread_mutex_t\n#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)\n#define CEU_THREADS_CANCEL(t)       ceu_dbg_assert(pthread_cancel(t)==0)\n#define CEU_THREADS_JOIN_TRY(t)     0\n#define CEU_THREADS_JOIN(t)         ceu_dbg_assert(pthread_join(t,NULL)==0)\n#define CEU_THREADS_MUTEX_LOCK(m)   ceu_dbg_assert(pthread_mutex_lock(m)==0)\n#define CEU_THREADS_MUTEX_UNLOCK(m) ceu_dbg_assert(pthread_mutex_unlock(m)==0)\n#define CEU_THREADS_SLEEP(us)       usleep(us)\n#define CEU_THREADS_PROTOTYPE(f,p)  void* f (p)\n#define CEU_THREADS_RETURN(v)       return v\n\n\n\n\nTODO: describe them\n\n\nC\u00e9u\n\n\nThe converted program generates types and constants required by the main\nprogram.\n\n\nExternal Events\n\n\nFor each \nexternal input and output event\n\n\nID\n defined in C\u00e9u, the compiler generates corresponding declarations as\nfollows:\n\n\n\n\nAn enumeration item \nCEU_INPUT_\nID\n that univocally identifies the event.\n\n\nA \ndefine\n macro \n_CEU_INPUT_\nID\n_\n.\n\n\nA struct type \ntceu_input_\nID\n with fields corresponding to the types in\n   of the event payload.\n\n\n\n\nExample:\n\n\nC\u00e9u program:\n\n\ninput (int,u8\n) MY_EVT;\n\n\n\n\nConverted program:\n\n\nenum {\n    ...\n    CEU_INPUT_MY_EVT,\n    ...\n};\n\n#define _CEU_INPUT_MY_EVT_                                                         \n\ntypedef struct tceu_input_MY_EVT {                                               \n    int _1;                                                                     \n    u8* _2;                                                                     \n} tceu_input_MY_EVT;\n\n\n\n\nData\n\n\nThe global \nCEU_APP\n of type \ntceu_app\n holds all program memory and runtime\ninformation:\n\n\ntypedef struct tceu_app {\n    bool end_ok;                /* if the program terminated */\n    int  end_val;               /* final value of the program */\n    bool async_pending;         /* if there is a pending \nasync\n to execute */\n    ...\n    tceu_code_mem_ROOT root;    /* all C\u00e9u program memory */\n} tceu_app;\n\nstatic tceu_app CEU_APP;\n\n\n\n\nThe struct \ntceu_code_mem_ROOT\n holds the whole memory of the C\u00e9u program.\nThe identifiers for global variables are preserved, making them directly\naccessible.\n\n\nExample:\n\n\nvar int x = 10;\n\n\n\n\ntypedef struct tceu_code_mem_ROOT {                                             \n    ...\n    int  x;                                                                         \n} tceu_code_mem_ROOT;    \n\n\n\n\nMain\n\n\nThe main program provides the entry point for the host platform (i.e., the\n\nmain\n function), implementing the event loop that senses the world and\nnotifies the C\u00e9u program about changes.\n\n\nThe main program interfaces with the C\u00e9u program in both directions:\n\n\n\n\nThrough direct calls, in the direction \nmain -\n C\u00e9u\n, typically when new input is available.\n\n\nThrough callbacks, in the direction \nC\u00e9u -\n main\n, typically when new output is available.\n\n\n\n\nCalls\n\n\nThe functions that follow are called by the main program to command the\nexecution of C\u00e9u programs:\n\n\n\n\n\n\nvoid ceu_start (void)\n\n\nInitializes and starts the program.\nShould be called once.\n\n\n\n\n\n\nvoid ceu_stop  (void)\n\n\nFinalizes the program.\nShould be called once.\n\n\n\n\n\n\nvoid ceu_input (tceu_nevt evt_id, void* evt_params)\n\n\nNotifies the program about an input \nevt_id\n with a payload \nevt_params\n.\nShould be called whenever the event loop senses a change.\nThe call to \nceu_input(CEU_INPUT__ASYNC, NULL)\n makes\n\nasynchronous blocks\n to execute a step.\n\n\n\n\n\n\nint ceu_loop (void)\n\n\nImplements a simple loop encapsulating \nceu_start\n, \nceu_input\n, and\n\nceu_stop\n.\nOn each loop iteration, make a \nCEU_CALLBACK_STEP\n callback and generates\na \nCEU_INPUT__ASYNC\n input.\nShould be called once.\nReturns the final value of the program.\n\n\n\n\n\n\nCallbacks\n\n\nThe C\u00e9u program makes callbacks to the main program in specific situations:\n\n\ntceu_callback_ret ceu_callback (int cmd, tceu_callback_arg p1, tceu_callback_arg p2);\n\nenum {\n    CEU_CALLBACK_START,                 /* once in the beginning of `ceu_start`             */\n    CEU_CALLBACK_STOP,                  /* once in the end of `ceu_stop`                    */\n    CEU_CALLBACK_STEP,                  /* on every iteration of `ceu_loop`                 */\n    CEU_CALLBACK_ABORT,                 /* whenever an error occurs                         */\n    CEU_CALLBACK_LOG,                   /* on error and debugging messages                  */\n    CEU_CALLBACK_TERMINATING,           /* once after executing the last statement          */\n    CEU_CALLBACK_ASYNC_PENDING,         /* whenever there's a pending \nasync\n block         */\n    CEU_CALLBACK_THREAD_TERMINATING,    /* whenever a thread terminates                     */\n    CEU_CALLBACK_ISR_ENABLE,            /* whenever interrupts should be enabled/disabled   */\n    CEU_CALLBACK_ISR_ATTACH,            /* whenever an \nasync/isr\n starts                   */\n    CEU_CALLBACK_ISR_DETACH,            /* whenever an \nasync/isr\n is aborted               */\n    CEU_CALLBACK_ISR_EMIT,              /* whenever an \nasync/isr\n emits an innput          */\n    CEU_CALLBACK_WCLOCK_MIN,            /* whenever a next minimum timer is required        */\n    CEU_CALLBACK_WCLOCK_DT,             /* whenever the elapsed time is requested           */\n    CEU_CALLBACK_OUTPUT,                /* whenever an output is emitted                    */\n    CEU_CALLBACK_REALLOC,               /* whenever memory is allocated/deallocated         */\n};\n\n\n\n\nTODO: payloads\n\n\nThe main program must implement the \nceu_callback\n prototype above to handle\nthe enumerated commands.\n\n\n\n\n\nExample\n\n\nSuppose the environment supports the events that follow:\n\n\ninput  int I;\noutput int O;\n\n\n\n\nThe \nmain.c\n implements an event loop to sense occurrences of \nI\n and a\ncallback handler for occurrences of \nO\n:\n\n\n#include \ntypes.h\n      // as illustrated above in \nTypes\n\n\nint ceu_is_running;     // detects program termination\n\ntceu_callback_ret ceu_callback (int cmd, tceu_callback_arg p1, tceu_callback_arg p2) {\n    tceu_callback_ret ret = { .is_handled=1 };\n    switch (cmd) {\n        case CEU_CALLBACK_TERMINATING:\n            ceu_is_running = 0;\n            break;\n        case CEU_CALLBACK_OUTPUT:\n            if (p1.num == CEU_OUTPUT_O) {\n                printf(\noutput O has been emitted with %d\\n\n, p2.num);\n            }\n            break;\n        default:\n            ret.is_handled = 0;\n    }\n    return ret;\n}\n\nint main (void) {\n    ceu_is_running = 1;\n\n    ceu_start();\n\n    while (ceu_is_running) {\n        if detects(CEU_INPUT_A) {\n            int v = \n...\n;\n            ceu_input(CEU_INPUT_A, \nv);\n        }\n        ceu_input(CEU_INPUT__ASYNC, NULL);\n    }\n\n    ceu_stop();\n}", 
            "title": "Compilation"
        }, 
        {
            "location": "/compilation/#compilation", 
            "text": "The compiler converts an input program in C\u00e9u to an output in C, which is\nfurther embedded in an  environment  satisfying a C API , which is finally compiled to an executable:", 
            "title": "Compilation"
        }, 
        {
            "location": "/compilation/#command-line", 
            "text": "The single command  ceu  is used for all compilation phases:  Usage: ceu [ options ]  file ...\n\nOptions:\n\n    --help                      display this help, then exit\n    --version                   display version information, then exit\n\n    --pre                       Preprocessor Phase: preprocess C\u00e9u into C\u00e9u\n    --pre-exe=FILE                  preprocessor executable\n    --pre-args=ARGS                 preprocessor arguments\n    --pre-input=FILE                input file to compile (C\u00e9u source)\n    --pre-output=FILE               output file to generate (C\u00e9u source)\n\n    --ceu                       C\u00e9u Phase: compiles C\u00e9u into C\n    --ceu-input=FILE                input file to compile (C\u00e9u source)\n    --ceu-output=FILE               output source file to generate (C source)\n    --ceu-line-directives=BOOL      insert `#line\u00b4 directives in the C output\n\n    --ceu-features-lua=BOOL         enable `lua\u00b4 support\n    --ceu-features-thread=BOOL      enable `async/thread\u00b4 support\n    --ceu-features-isr=BOOL         enable `async/isr\u00b4 support\n\n    --ceu-err-unused=OPT            effect for unused identifier: error|warning|pass\n    --ceu-err-unused-native=OPT                unused native identifier\n    --ceu-err-unused-code=OPT                  unused code identifier\n    --ceu-err-uninitialized=OPT     effect for uninitialized variable: error|warning|pass\n\n    --env                       Environment Phase: packs all C files together\n    --env-types=FILE                header file with type declarations (C source)\n    --env-threads=FILE              header file with thread declarations (C source)\n    --env-ceu=FILE                  output file from C\u00e9u phase (C source)\n    --env-main=FILE                 source file with main function (C source)\n    --env-output=FILE               output file to generate (C source)\n\n    --cc                        C Compiler Phase: compiles C into binary\n    --cc-exe=FILE                   C compiler executable\n    --cc-args=ARGS                  compiler arguments\n    --cc-input=FILE                 input file to compile (C source)\n    --cc-output=FILE                output file to generate (binary)  All phases are optional.\nTo enable a phase, the associated prefix must be enabled.\nIf two consecutive phases are enabled, the output of the preceding and the\ninput of the succeeding phases can be omitted.  Examples:  # Preprocess  user.ceu , and converts the output to  user.c \n$ ceu --pre --pre-input= user.ceu  --ceu --ceu-output= user.c   # Packs  user.c ,  types.h , and  main.c , compiling them to  app.out \n$ ceu --env --env-ceu=user.c --env-types=types.h --env-main=main.c \\\n      --cc --cc-output=app.out", 
            "title": "Command Line"
        }, 
        {
            "location": "/compilation/#c-api", 
            "text": "The environment phase of the compiler packs the converted C\u00e9u program and\nadditional files in the order as follows:   type declarations    (option  --env-types )  thread declarations  (option  --env-threads , optional)  a callback prototype (fixed, see below)  C\u00e9u program          (option  --env-ceu , auto generated)  main program         (option  --env-main )   The C\u00e9u program uses standardized types and calls, which must be previously\nmapped from the host environment in steps  1-3 .  The main program depends on declarations from the C\u00e9u program.", 
            "title": "C API"
        }, 
        {
            "location": "/compilation/#types", 
            "text": "The type declarations must map the types of the host environment to all primitive types  of C\u00e9u.  Example:  #include  stdint.h \n#include  sys/types.h \n\ntypedef unsigned char bool;\ntypedef unsigned char byte;\ntypedef unsigned int  uint;\n\ntypedef ssize_t  ssize;\ntypedef size_t   usize;\n\ntypedef int8_t    s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\ntypedef uint8_t   u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n\ntypedef float    f32;\ntypedef double   f64;", 
            "title": "Types"
        }, 
        {
            "location": "/compilation/#threads", 
            "text": "If the user program uses  threads  and the option --ceu-features-thread  is set, the host environment must provide declarations\nfor types and functions expected by C\u00e9u.  Example:  #include  pthread.h \n#include  unistd.h \n#define CEU_THREADS_T               pthread_t\n#define CEU_THREADS_MUTEX_T         pthread_mutex_t\n#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)\n#define CEU_THREADS_CANCEL(t)       ceu_dbg_assert(pthread_cancel(t)==0)\n#define CEU_THREADS_JOIN_TRY(t)     0\n#define CEU_THREADS_JOIN(t)         ceu_dbg_assert(pthread_join(t,NULL)==0)\n#define CEU_THREADS_MUTEX_LOCK(m)   ceu_dbg_assert(pthread_mutex_lock(m)==0)\n#define CEU_THREADS_MUTEX_UNLOCK(m) ceu_dbg_assert(pthread_mutex_unlock(m)==0)\n#define CEU_THREADS_SLEEP(us)       usleep(us)\n#define CEU_THREADS_PROTOTYPE(f,p)  void* f (p)\n#define CEU_THREADS_RETURN(v)       return v  TODO: describe them", 
            "title": "Threads"
        }, 
        {
            "location": "/compilation/#ceu", 
            "text": "The converted program generates types and constants required by the main\nprogram.", 
            "title": "C\u00e9u"
        }, 
        {
            "location": "/compilation/#external-events", 
            "text": "For each  external input and output event  ID  defined in C\u00e9u, the compiler generates corresponding declarations as\nfollows:   An enumeration item  CEU_INPUT_ ID  that univocally identifies the event.  A  define  macro  _CEU_INPUT_ ID _ .  A struct type  tceu_input_ ID  with fields corresponding to the types in\n   of the event payload.   Example:  C\u00e9u program:  input (int,u8 ) MY_EVT;  Converted program:  enum {\n    ...\n    CEU_INPUT_MY_EVT,\n    ...\n};\n\n#define _CEU_INPUT_MY_EVT_                                                         \n\ntypedef struct tceu_input_MY_EVT {                                               \n    int _1;                                                                     \n    u8* _2;                                                                     \n} tceu_input_MY_EVT;", 
            "title": "External Events"
        }, 
        {
            "location": "/compilation/#data", 
            "text": "The global  CEU_APP  of type  tceu_app  holds all program memory and runtime\ninformation:  typedef struct tceu_app {\n    bool end_ok;                /* if the program terminated */\n    int  end_val;               /* final value of the program */\n    bool async_pending;         /* if there is a pending  async  to execute */\n    ...\n    tceu_code_mem_ROOT root;    /* all C\u00e9u program memory */\n} tceu_app;\n\nstatic tceu_app CEU_APP;  The struct  tceu_code_mem_ROOT  holds the whole memory of the C\u00e9u program.\nThe identifiers for global variables are preserved, making them directly\naccessible.  Example:  var int x = 10;  typedef struct tceu_code_mem_ROOT {                                             \n    ...\n    int  x;                                                                         \n} tceu_code_mem_ROOT;", 
            "title": "Data"
        }, 
        {
            "location": "/compilation/#main", 
            "text": "The main program provides the entry point for the host platform (i.e., the main  function), implementing the event loop that senses the world and\nnotifies the C\u00e9u program about changes.  The main program interfaces with the C\u00e9u program in both directions:   Through direct calls, in the direction  main -  C\u00e9u , typically when new input is available.  Through callbacks, in the direction  C\u00e9u -  main , typically when new output is available.", 
            "title": "Main"
        }, 
        {
            "location": "/compilation/#calls", 
            "text": "The functions that follow are called by the main program to command the\nexecution of C\u00e9u programs:    void ceu_start (void)  Initializes and starts the program.\nShould be called once.    void ceu_stop  (void)  Finalizes the program.\nShould be called once.    void ceu_input (tceu_nevt evt_id, void* evt_params)  Notifies the program about an input  evt_id  with a payload  evt_params .\nShould be called whenever the event loop senses a change.\nThe call to  ceu_input(CEU_INPUT__ASYNC, NULL)  makes asynchronous blocks  to execute a step.    int ceu_loop (void)  Implements a simple loop encapsulating  ceu_start ,  ceu_input , and ceu_stop .\nOn each loop iteration, make a  CEU_CALLBACK_STEP  callback and generates\na  CEU_INPUT__ASYNC  input.\nShould be called once.\nReturns the final value of the program.", 
            "title": "Calls"
        }, 
        {
            "location": "/compilation/#callbacks", 
            "text": "The C\u00e9u program makes callbacks to the main program in specific situations:  tceu_callback_ret ceu_callback (int cmd, tceu_callback_arg p1, tceu_callback_arg p2);\n\nenum {\n    CEU_CALLBACK_START,                 /* once in the beginning of `ceu_start`             */\n    CEU_CALLBACK_STOP,                  /* once in the end of `ceu_stop`                    */\n    CEU_CALLBACK_STEP,                  /* on every iteration of `ceu_loop`                 */\n    CEU_CALLBACK_ABORT,                 /* whenever an error occurs                         */\n    CEU_CALLBACK_LOG,                   /* on error and debugging messages                  */\n    CEU_CALLBACK_TERMINATING,           /* once after executing the last statement          */\n    CEU_CALLBACK_ASYNC_PENDING,         /* whenever there's a pending  async  block         */\n    CEU_CALLBACK_THREAD_TERMINATING,    /* whenever a thread terminates                     */\n    CEU_CALLBACK_ISR_ENABLE,            /* whenever interrupts should be enabled/disabled   */\n    CEU_CALLBACK_ISR_ATTACH,            /* whenever an  async/isr  starts                   */\n    CEU_CALLBACK_ISR_DETACH,            /* whenever an  async/isr  is aborted               */\n    CEU_CALLBACK_ISR_EMIT,              /* whenever an  async/isr  emits an innput          */\n    CEU_CALLBACK_WCLOCK_MIN,            /* whenever a next minimum timer is required        */\n    CEU_CALLBACK_WCLOCK_DT,             /* whenever the elapsed time is requested           */\n    CEU_CALLBACK_OUTPUT,                /* whenever an output is emitted                    */\n    CEU_CALLBACK_REALLOC,               /* whenever memory is allocated/deallocated         */\n};  TODO: payloads  The main program must implement the  ceu_callback  prototype above to handle\nthe enumerated commands.", 
            "title": "Callbacks"
        }, 
        {
            "location": "/compilation/#example", 
            "text": "Suppose the environment supports the events that follow:  input  int I;\noutput int O;  The  main.c  implements an event loop to sense occurrences of  I  and a\ncallback handler for occurrences of  O :  #include  types.h       // as illustrated above in  Types \n\nint ceu_is_running;     // detects program termination\n\ntceu_callback_ret ceu_callback (int cmd, tceu_callback_arg p1, tceu_callback_arg p2) {\n    tceu_callback_ret ret = { .is_handled=1 };\n    switch (cmd) {\n        case CEU_CALLBACK_TERMINATING:\n            ceu_is_running = 0;\n            break;\n        case CEU_CALLBACK_OUTPUT:\n            if (p1.num == CEU_OUTPUT_O) {\n                printf( output O has been emitted with %d\\n , p2.num);\n            }\n            break;\n        default:\n            ret.is_handled = 0;\n    }\n    return ret;\n}\n\nint main (void) {\n    ceu_is_running = 1;\n\n    ceu_start();\n\n    while (ceu_is_running) {\n        if detects(CEU_INPUT_A) {\n            int v =  ... ;\n            ceu_input(CEU_INPUT_A,  v);\n        }\n        ceu_input(CEU_INPUT__ASYNC, NULL);\n    }\n\n    ceu_stop();\n}", 
            "title": "Example"
        }, 
        {
            "location": "/syntax/", 
            "text": "Syntax\n\n\nFollows the complete syntax of C\u00e9u in a BNF-like syntax:\n\n\n\n\nA\n : non terminal (starting in uppercase)\n\n\na\n : terminal (in bold and lowercase)\n\n\n.\n : terminal (non-alphanumeric characters)\n\n\nA ::= ...\n : defines \nA\n as \n...\n\n\nx y\n : \nx\n in sequence with \ny\n\n\nx|y\n : \nx\n or \ny\n\n\n{x}\n : zero or more xs\n\n\n[x]\n : optional x\n\n\nLIST(x)\n : expands to \nx {\n,\n x} [\n,\n]\n\n\n(...)\n : groups \n...\n\n\n...\n : special informal rule\n\n\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      | do [`/\u00b4(ID_int|`_\u00b4)] [`(\u00b4 [LIST(ID_int)] `)\u00b4]\n            Block\n        end\n      |  escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Entities / Declarations */\n\n      // Dcls ::=\n      | var [`\n\u00b4|`\n?\u00b4] [`/dynamic\u00b4|`/nohold\u00b4] Type ID_int [`=\u00b4 Sources]\n      | vector [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\n      | pool [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\n      | event [`\n\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_int [`=\u00b4 Sources]\n\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_ext\n      | output (Type | `(\u00b4 LIST([`\n\u00b4] Type) `)\u00b4) ID_ext\n\n  /* Event Handling */\n\n      // Await ::=\n      | await (ID_ext | Loc) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await (FOREVER | pause | resume)\n\n      // Emit_Ext ::=\n      | emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Loc [`(\u00b4 [LIST(Exp)] `)\u00b4]\n\n      | lock Loc do\n            Block\n        end\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in [Range] do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( (      Exp `-\n\u00b4 (Exp|`_\u00b4))\n                        | ((Exp|`_\u00b4) `\n-\u00b4 Exp      ) )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Code_Cons_Init) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn [`(\u00b4 [LIST(ID_int)] `)\u00b4] do\n            Block\n        end\n\n  /* Pause */\n\n      | pause/if (Loc|ID_ext) do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      // Thread ::=\n      | await async/thread [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      | spawn async/isr `[\u00b4 LIST(Exp) `]\u00b4 [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\n        // where\n            List_Nat ::= LIST(ID_nat)\n      | native `/\u00b4(pre|pos) do\n            \ncode definitions in C\n\n        end\n      | native `/\u00b4 end\n      | `{\u00b4 {\ncode in C\n | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} `}\u00b4     /* `@@\u00b4 escapes to `@\u00b4 */\n\n      // Nat_Call ::=\n      | [call] Exp\n\n      /* finalization */\n      | do [Stmt] Finalize\n      | var `\n?\u00b4 Type ID_int `=\u00b4 `\n\u00b4 (Nat_Call | Code_Call) Finalize\n        // where\n            Finalize ::= finalize `(\u00b4 LIST(Loc) `)\u00b4 with\n                             Block\n                         [ pause  with Block ]\n                         [ resume with Block ]\n                         end\n\n  /* Lua integration */\n\n      // Lua_State ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      // Lua_Stmts ::=\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            { {\ncode in Lua\n | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} }   /* `@@\u00b4 escapes to `@\u00b4 */\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [as (nothing|Exp)] [ with\n            Dcls `;\u00b4 {`;\u00b4}\n            { Dcls `;\u00b4 {`;\u00b4} }\n        end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `-\n\u00b4 Type\n\n      // Code_Await ::=\n      | code/await Mods ID_abs `(\u00b4 Params `)\u00b4 [ `-\n\u00b4 `(\u00b4 Params `)\u00b4 ] `-\n\u00b4 (Type | FOREVER)\n        // where\n            Params ::= void | LIST(Dcls)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code invocation */\n\n      // Code_Call ::=\n      | call  Mods Abs_Cons\n\n      // Code_Await ::=\n      | await Mods Abs_Cons\n\n      // Code_Spawn ::=\n      | spawn Mods Abs_Cons [in Loc]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Abs_Cons ::= [Loc `.\u00b4] ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`nil\u00b4|`_\u00b4) `)\u00b4\n\n  /* Assignments */\n\n      | (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Sources\n        // where\n            Sources ::= ( Do\n                        | Emit_Ext\n                        | Await\n                        | Watching\n                        | Thread\n                        | Lua_State\n                        | Lua_Stmts\n                        | Code_Await\n                        | Code_Spawn\n                        | Vec_Cons\n                        | Data_Cons\n                        | Exp\n                        | `nil\u00b4\n                        | `_\u00b4 )\n            Vec_Cons  ::= (Loc | Exp) Vec_Concat { Vec_Concat }\n                       |  `[\u00b4 [LIST(Exp)] `]\u00b4 { Vec_Concat }\n                        // where\n                            Vec_Concat ::= `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4)\n            Data_Cons ::= (val|new) Abs_Cons\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n/* Types */\n\nType ::= ID_type { `\n\u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::= \n [^\\\n\\n]* \n                        // regex\n\n/* Expressions */\n\nExp ::= NUM | STR | null | true | false\n     |  `(\u00b4 Exp `)\u00b4\n     |  Exp \nbinop\n Exp\n     |  \nunop\n Exp\n     |  Exp `[\u00b4 Exp `]\u00b4\n     |  Exp is Type\n     |  Exp as Type\n     |  Exp as `/\u00b4(nohold|plain|pure)\n     |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n     |  Nat_Call | Code_Call\n\n/* Locations */\n\nLoc ::= Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n     |  [`*\u00b4|`$\u00b4] Loc\n     |  Loc { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\n     |  ID_int\n     |  ID_nat\n     |  outer\n     |  `{\u00b4 \ncode in C\n `}\u00b4\n     |  `(\u00b4 Loc `)\u00b4\n\n/* Operator Precedence */\n\n    /* lowest priority */\n\n    // locations\n    *     $\n    :     .     !     []\n    as\n\n    // expressions\n    is    as                                            // binops\n    or\n    and\n    !=    ==    \n=    \n=    \n     \n\n    |\n    ^\n    \n\n    \n    \n\n    +     -\n    *     /     %\n    not   +     -     ~     $$    $     *     \n    \n   // unops\n    :     .     !     ?     ()    []\n\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive\n\n\n\n\n\nTODO: statements that do not require ;", 
            "title": "Syntax"
        }, 
        {
            "location": "/syntax/#syntax", 
            "text": "Follows the complete syntax of C\u00e9u in a BNF-like syntax:   A  : non terminal (starting in uppercase)  a  : terminal (in bold and lowercase)  .  : terminal (non-alphanumeric characters)  A ::= ...  : defines  A  as  ...  x y  :  x  in sequence with  y  x|y  :  x  or  y  {x}  : zero or more xs  [x]  : optional x  LIST(x)  : expands to  x { ,  x} [ , ]  (...)  : groups  ...  ...  : special informal rule   Program ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      | do [`/\u00b4(ID_int|`_\u00b4)] [`(\u00b4 [LIST(ID_int)] `)\u00b4]\n            Block\n        end\n      |  escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Entities / Declarations */\n\n      // Dcls ::=\n      | var [` \u00b4|` ?\u00b4] [`/dynamic\u00b4|`/nohold\u00b4] Type ID_int [`=\u00b4 Sources]\n      | vector [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\n      | pool [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type ID_int [`=\u00b4 Sources]\n      | event [` \u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_int [`=\u00b4 Sources]\n\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) ID_ext\n      | output (Type | `(\u00b4 LIST([` \u00b4] Type) `)\u00b4) ID_ext\n\n  /* Event Handling */\n\n      // Await ::=\n      | await (ID_ext | Loc) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await (FOREVER | pause | resume)\n\n      // Emit_Ext ::=\n      | emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Loc [`(\u00b4 [LIST(Exp)] `)\u00b4]\n\n      | lock Loc do\n            Block\n        end\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in [Range] do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( (      Exp `- \u00b4 (Exp|`_\u00b4))\n                        | ((Exp|`_\u00b4) ` -\u00b4 Exp      ) )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] (ID_int|`_\u00b4) in Loc do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Code_Cons_Init) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn [`(\u00b4 [LIST(ID_int)] `)\u00b4] do\n            Block\n        end\n\n  /* Pause */\n\n      | pause/if (Loc|ID_ext) do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      // Thread ::=\n      | await async/thread [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      | spawn async/isr `[\u00b4 LIST(Exp) `]\u00b4 [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\n        // where\n            List_Nat ::= LIST(ID_nat)\n      | native `/\u00b4(pre|pos) do\n             code definitions in C \n        end\n      | native `/\u00b4 end\n      | `{\u00b4 { code in C  | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} `}\u00b4     /* `@@\u00b4 escapes to `@\u00b4 */\n\n      // Nat_Call ::=\n      | [call] Exp\n\n      /* finalization */\n      | do [Stmt] Finalize\n      | var ` ?\u00b4 Type ID_int `=\u00b4 ` \u00b4 (Nat_Call | Code_Call) Finalize\n        // where\n            Finalize ::= finalize `(\u00b4 LIST(Loc) `)\u00b4 with\n                             Block\n                         [ pause  with Block ]\n                         [ resume with Block ]\n                         end\n\n  /* Lua integration */\n\n      // Lua_State ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      // Lua_Stmts ::=\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            { { code in Lua  | `@\u00b4 (`(\u00b4Exp`)\u00b4|Exp)} }   /* `@@\u00b4 escapes to `@\u00b4 */\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [as (nothing|Exp)] [ with\n            Dcls `;\u00b4 {`;\u00b4}\n            { Dcls `;\u00b4 {`;\u00b4} }\n        end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `- \u00b4 Type\n\n      // Code_Await ::=\n      | code/await Mods ID_abs `(\u00b4 Params `)\u00b4 [ `- \u00b4 `(\u00b4 Params `)\u00b4 ] `- \u00b4 (Type | FOREVER)\n        // where\n            Params ::= void | LIST(Dcls)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code invocation */\n\n      // Code_Call ::=\n      | call  Mods Abs_Cons\n\n      // Code_Await ::=\n      | await Mods Abs_Cons\n\n      // Code_Spawn ::=\n      | spawn Mods Abs_Cons [in Loc]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Abs_Cons ::= [Loc `.\u00b4] ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`nil\u00b4|`_\u00b4) `)\u00b4\n\n  /* Assignments */\n\n      | (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Sources\n        // where\n            Sources ::= ( Do\n                        | Emit_Ext\n                        | Await\n                        | Watching\n                        | Thread\n                        | Lua_State\n                        | Lua_Stmts\n                        | Code_Await\n                        | Code_Spawn\n                        | Vec_Cons\n                        | Data_Cons\n                        | Exp\n                        | `nil\u00b4\n                        | `_\u00b4 )\n            Vec_Cons  ::= (Loc | Exp) Vec_Concat { Vec_Concat }\n                       |  `[\u00b4 [LIST(Exp)] `]\u00b4 { Vec_Concat }\n                        // where\n                            Vec_Concat ::= `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4)\n            Data_Cons ::= (val|new) Abs_Cons\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n/* Types */\n\nType ::= ID_type { ` \u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::=   [^\\ \\n]*                          // regex\n\n/* Expressions */\n\nExp ::= NUM | STR | null | true | false\n     |  `(\u00b4 Exp `)\u00b4\n     |  Exp  binop  Exp\n     |   unop  Exp\n     |  Exp `[\u00b4 Exp `]\u00b4\n     |  Exp is Type\n     |  Exp as Type\n     |  Exp as `/\u00b4(nohold|plain|pure)\n     |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n     |  Nat_Call | Code_Call\n\n/* Locations */\n\nLoc ::= Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n     |  [`*\u00b4|`$\u00b4] Loc\n     |  Loc { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\n     |  ID_int\n     |  ID_nat\n     |  outer\n     |  `{\u00b4  code in C  `}\u00b4\n     |  `(\u00b4 Loc `)\u00b4\n\n/* Operator Precedence */\n\n    /* lowest priority */\n\n    // locations\n    *     $\n    :     .     !     []\n    as\n\n    // expressions\n    is    as                                            // binops\n    or\n    and\n    !=    ==     =     =           \n    |\n    ^\n     \n          \n    +     -\n    *     /     %\n    not   +     -     ~     $$    $     *              // unops\n    :     .     !     ?     ()    []\n\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive  TODO: statements that do not require ;", 
            "title": "Syntax"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nC\u00e9u is distributed under the MIT license reproduced below:\n\n\n Copyright (C) 2012-2017 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \nSoftware\n), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "C\u00e9u is distributed under the MIT license reproduced below:   Copyright (C) 2012-2017 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the  Software ), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }
    ]
}